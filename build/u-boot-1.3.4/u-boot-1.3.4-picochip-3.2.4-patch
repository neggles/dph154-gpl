diff --git a/MAKEALL b/MAKEALL
index ee83cca..3c11831 100755
--- a/MAKEALL
+++ b/MAKEALL
@@ -365,6 +365,7 @@ LIST_85xx="		\
 	TQM8548		\
 	TQM8555		\
 	TQM8560		\
+        picochiphdp203  \
 "
 
 #########################################################################
@@ -495,6 +496,10 @@ LIST_ARM9="			\
 	davinci_schmoogie	\
 	davinci_sffsdr		\
 	davinci_sonata		\
+        picochipcpe20x          \  
+        picochipsvb302          \
+        picochippc7302          \
+        picochippc7802          \
 "
 
 #########################################################################
diff --git a/Makefile b/Makefile
index 082b08e..0e49c6f 100644
--- a/Makefile
+++ b/Makefile
@@ -2996,6 +2996,24 @@ grsim_config : unconfig
 grsim_leon2_config : unconfig
 	@$(MKCONFIG) $(@:_config=) sparc leon2 grsim_leon2 gaisler
 
+#========================================================================
+# picoChip Platforms
+#========================================================================       
+picochiphdp203_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc85xx hdp203 picochip
+
+picochipcpe20x_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs cpe20x picochip pc20x
+
+picochipsvb302_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs svb302 picochip pc302
+        
+picochippc7302_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs pc7302 picochip pc302
+        
+picochippc7802_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs pc7802 picochip pc20x                
+ 
 #########################################################################
 #########################################################################
 #########################################################################
diff --git a/board/picochip/cpe20x/Makefile b/board/picochip/cpe20x/Makefile
new file mode 100644
index 0000000..c8cb6f8
--- /dev/null
+++ b/board/picochip/cpe20x/Makefile
@@ -0,0 +1,37 @@
+#/*!
+#* \file Makefile
+#* \brief Used during the build process.
+#*
+#* Copyright (c) 2006-2009 picoChip Designs Ltd
+#*
+#* This program is free software; you can redistribute it and/or modify
+#* it under the terms of the GNU General Public License version 2 as
+#* published by the Free Software Foundation.
+#*
+#* All enquiries to support@picochip.com
+#*/
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= cpe20x.o
+SOBJS	:= lowlevel_init.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $^
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff --git a/board/picochip/cpe20x/config.mk b/board/picochip/cpe20x/config.mk
new file mode 100644
index 0000000..c32c626
--- /dev/null
+++ b/board/picochip/cpe20x/config.mk
@@ -0,0 +1,33 @@
+#/*****************************************************************************
+# * $picoChipHeaderSubst$
+# *****************************************************************************/
+
+#/*!
+#* \file config.mk
+#* \brief Used during the build process.
+#*
+#* Copyright (c) 2006-2009 picoChip Designs Ltd
+#*
+#* This program is free software; you can redistribute it and/or modify
+#* it under the terms of the GNU General Public License version 2 as
+#* published by the Free Software Foundation.
+#*
+#* All enquiries to support@picochip.com
+#*/
+
+TEXT_BASE = 0x05000000
+
+ifdef BSP_ARCH
+ifeq ($(CPE20X_2BANKS), Y)
+PLATFORM_CPPFLAGS += -DCONFIG_PC20X_2_DDR_RAM_BANKS
+endif
+endif
+
+ifdef BSP_DIR
+include $(BSP_DIR)/config
+PLATFORM_CPPFLAGS += -DPICOCHIP_PLATFORM_VERSION=\"$(RELEASE_VERSION)\"
+endif
+
+ifeq ($(CPE20X_RUN_FROM_RAM), Y)
+PLATFORM_CPPFLAGS += -DCONFIG_RUN_FROM_RAM
+endif
diff --git a/board/picochip/cpe20x/cpe20x.c b/board/picochip/cpe20x/cpe20x.c
new file mode 100644
index 0000000..3086d0a
--- /dev/null
+++ b/board/picochip/cpe20x/cpe20x.c
@@ -0,0 +1,513 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file cpe20x.c
+* \brief Various useful functions for use on a CPE20X Platform.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+#include <asm/arch/pc20x.h>
+#include <asm/arch/timer.h>
+#include <asm/arch/gpio.h>
+
+/* Constants --------------------------------------------------------------- */
+DECLARE_GLOBAL_DATA_PTR;
+
+/* Macros ------------------------------------------------------------------ */
+#define PA_TIMECOUNT 32
+#define PROCIFCONFIGREADREGOFFSET   0x78
+#define PROCIFCONFIGWRITEREGOFFSET  0x7C
+#define PA_CONFIG_WRITE             0x00010000
+#define PA_CONFIG_READ              0x00020000
+#define PA_CONFIG_ADDR              0x00040000
+#define PA_CONFIG_AEID              0x00080000
+#define PA_CONFIG_VALID             0x00010000
+#define PA_CONFIG_FAIL              0x00020000
+#define PA_CONFIG_TIMEOUTOCCURED    0x00040000
+#define PA_AEID_PROCINT2            0x0048
+#define PA_PROCINT2_DEVICEID        0x0030
+
+#define PA_DEVICE_ID_MASK           0xFFFF
+#define PC202_DEVICE_ID             0x00000010
+#define PC203_DEVICE_ID             0x00000011
+#define PC205_DEVICE_ID             0x00000012
+
+/* FPGA Device ID register */
+#define FPGA_DID_REG                (0)
+
+/* The device ID reg changed between v1 and v2 */
+#define V1_FPGA_DID_BOARD_TYPE_SHIFT   (4)
+#define V1_FPGA_DID_BOARD_TYPE_MASK    (0xff << V1_FPGA_DID_BOARD_TYPE_SHIFT)
+
+#define V2_FPGA_DID_BOARD_TYPE_SHIFT   (8)
+#define V2_FPGA_DID_BOARD_TYPE_MASK    (0xff << V2_FPGA_DID_BOARD_TYPE_SHIFT)
+#define V2_FPGA_DID_PCB_BUILD_SHIFT    (4)
+#define V2_FPGA_DID_PCB_BUILD_MASK     (0x0f << V2_FPGA_DID_PCB_BUILD_SHIFT)
+
+#define FPGA_DID_DEVICE_ID_SHIFT    (0)
+#define FPGA_DID_DEVICE_ID_MASK     (0x0f << FPGA_DID_DEVICE_ID_SHIFT)
+
+/* Board types: */
+#define BOARD_TYPE_PC7205           (6)
+#define BOARD_TYPE_HDP203           (7)
+
+/* PCB Builds: TODO validate */
+#define PCB_BUILD_PC72052_I10_REVB  (0)
+
+/* Device IDs: */
+#define DID_RC_FPGA                 (1)
+#define DID_AD_FPGA                 (2)
+
+/* FPGA version register */
+#define FPGA_VERSION_REG            (1)
+
+#define FPGA_VERS_CODE_REL_SHIFT    (8)
+#define FPGA_VERS_CODE_REL_MASK     (0xff << FPGA_VERS_CODE_REL_SHIFT)
+#define FPGA_VERS_CODE_REV_SHIFT    (0)
+#define FPGA_VERS_CODE_REV_MASK     (0xff << FPGA_VERS_CODE_REV_SHIFT)
+
+/* Prototypes--------------------------------------------------------------- */
+/*!
+ *
+ * Start timer #0 in free running mode
+ *
+ */
+static void pc20xTimer0Start(void);
+
+/*!
+ *
+ *  Read proc-if configuration space
+ *
+ * \param procAEID AEID of block in picoArray being accessed
+ * \param procConfigAddress Address in the picoArray being accessed
+ * \return Data read from AEID & Addr + state of read
+ *         bit 16 = valid
+ *         bit 17 = fail from picoArray
+ *         bit 18 = timeout occured
+ */
+static unsigned int procConfigRead (unsigned int procAEID, unsigned int procConfigAddress);
+
+/*!
+ *
+ *  Read FPGA registers via bit bashed SPI
+ *
+ * \param fpga The FPGA we want to read from
+ * \param reg The FPGA register number to read
+ * \return Data read from FPGA
+ */
+static unsigned short FPGARead(unsigned int fpga, unsigned char reg);
+
+/*!
+ *
+ *  Display the board type
+ *
+ * \param vers_reg The version register contents read from the FPGA(s).
+ * \param id_reg The id register contents read from the FPGA(s)
+ */
+static void display_board_type (unsigned short vers_reg,
+                                unsigned short id_reg);
+
+/*!
+ *
+ *  Display some FPGA version information
+ *
+ * \param vers_reg The version register contents read from the FPGA(s).
+ * \param id_reg The id register contents read from the FPGA(s)
+ */
+static void display_fpga_info (unsigned short vers_reg,
+                               unsigned short id_reg);
+
+
+#if defined(CONFIG_SHOW_BOOT_PROGRESS)
+void show_boot_progress(int progress)
+{
+	printf("Boot reached stage %d\n", progress);
+}
+#endif
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x00000100;
+        gd->bd->bi_arch_number = MACH_TYPE_PC72052_I10_REVB;
+	gd->flags = 0;
+
+	icache_enable ();
+
+        pc20xTimer0Start();
+
+	return 0;
+}
+
+int checkboard (void)
+{
+    unsigned int deviceType;
+
+    puts("Build: picoChip "PICOCHIP_PLATFORM" \n");
+
+    /* What device are we running on ? */
+    puts("Device: ");
+
+    deviceType = procConfigRead (PA_AEID_PROCINT2, PA_PROCINT2_DEVICEID);
+    if ((deviceType & PA_CONFIG_VALID) == PA_CONFIG_VALID)
+    {
+        /* We have a successful read... */
+        deviceType = deviceType & PA_DEVICE_ID_MASK;
+        switch (deviceType)
+        {
+            case PC202_DEVICE_ID:
+            {
+                puts("PC202\n");
+                break;
+            }
+            case PC203_DEVICE_ID:
+            {
+                puts("PC203\n");
+                break;
+            }
+            case PC205_DEVICE_ID:
+            {
+                puts("PC205\n");
+                break;
+            }
+            default:
+            {
+                puts("Unknown !\n");
+            }
+        }
+    }
+    else
+    {
+        /* Didn't have a successful read */
+        puts("Failed to read the device id !\n");
+    }
+
+    /* Obtain some information from the FPGA(s) */
+    {
+        unsigned short rc_id_reg = FPGARead(DID_RC_FPGA, FPGA_DID_REG);
+        unsigned short rc_vers_reg = FPGARead(DID_RC_FPGA, FPGA_VERSION_REG);
+
+        unsigned short ad_id_reg = FPGARead(DID_AD_FPGA, FPGA_DID_REG);
+        unsigned short ad_vers_reg = FPGARead(DID_AD_FPGA, FPGA_VERSION_REG);
+
+        /* Print out the board info */
+        if (rc_id_reg != 0xffff)
+        {
+            /* We have an RC FPGA */
+            display_board_type (rc_vers_reg, rc_id_reg);
+        }
+        else if (ad_id_reg != 0xffff)
+        {
+            /* We have an AD FPGA */
+            display_board_type (ad_vers_reg, ad_id_reg);
+        }
+        else
+        {
+            puts("Failed to read the FPGA(s) !\n");
+        }
+
+        /* Print out the FPGA info */
+        if (rc_id_reg != 0xffff)
+        {
+            /* We have an RC FPGA */
+            display_fpga_info (rc_vers_reg, rc_id_reg);
+        }
+
+        if (ad_id_reg != 0xffff)
+        {
+            /* We have an AD FPGA */
+            display_fpga_info (ad_vers_reg, ad_id_reg);
+        }
+    }
+
+    return 0;
+}
+
+/*****************************************************************************
+ *
+ * misc_init_r()
+ *
+ * Purpose: Not used right now, function template left here as a place holder
+ *
+ ****************************************************************************/
+int misc_init_r (void)
+{
+    /* Not used right now, function template left here as a place holder */
+    return 0;
+}
+
+/*****************************************************************************
+ *
+ * dram_init()
+ *
+ * Purpose: Initialize the DDR-RAM info in the board data structure
+ *
+ ****************************************************************************/
+int dram_init (void)
+{
+
+#ifndef CONFIG_PC20X_2_DDR_RAM_BANKS
+/* We want a 4 DDR Bank setup then */
+
+    gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+    gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+    gd->bd->bi_dram[1].start = PHYS_SDRAM_2;
+    gd->bd->bi_dram[1].size = PHYS_SDRAM_2_SIZE;
+    gd->bd->bi_dram[2].start = PHYS_SDRAM_3;
+    gd->bd->bi_dram[2].size = PHYS_SDRAM_3_SIZE;
+    gd->bd->bi_dram[3].start = PHYS_SDRAM_4;
+    gd->bd->bi_dram[3].size = PHYS_SDRAM_4_SIZE;
+
+#else   /* We want a 2 DDR Bank setup then */
+
+    gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+    gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+    gd->bd->bi_dram[1].start = PHYS_SDRAM_2;
+    gd->bd->bi_dram[1].size = PHYS_SDRAM_2_SIZE;
+
+#endif
+
+    return 0;
+}
+
+static void pc20xTimer0Start(void)
+{
+    /* Make sure timer #0 is disabled */
+    *(volatile unsigned int *)(CFG_TIMERBASE + TimerNControlRegOffset(0)) = 0;
+
+    /* Initialise the timer #0 to all 1's.  We do this  because we want to run
+       the timer in free running mode. */
+    *(volatile unsigned int *)(CFG_TIMERBASE + TimerNLoadCountRegOffset(0)) =
+                               0xFFFFFFFF;
+
+    /* Start timer #0 in free running mode */
+    *(volatile unsigned int *)(CFG_TIMERBASE + TimerNControlRegOffset(0)) =
+                              (TimerInterruptMask | TimerEnable);
+}
+
+static unsigned int procConfigRead ( unsigned int procAEID, unsigned int procConfigAddress)
+{
+    unsigned int failed = 0;
+    unsigned int valid  = 0;
+    unsigned int timeout = PA_TIMECOUNT;
+    unsigned int procReadData;
+
+    /* Write the AEID */
+    *(volatile unsigned int *)(PC20X_SLAVE_PROCIF_BASE + PROCIFCONFIGWRITEREGOFFSET) = (PA_CONFIG_AEID | procAEID);
+
+    /* Write the address being accessed */
+    *(volatile unsigned int *)(PC20X_SLAVE_PROCIF_BASE + PROCIFCONFIGWRITEREGOFFSET) = (PA_CONFIG_ADDR | procConfigAddress);
+
+    /* Write request for a read access */
+    *(volatile unsigned int *)(PC20X_SLAVE_PROCIF_BASE + PROCIFCONFIGWRITEREGOFFSET) = PA_CONFIG_READ;
+
+    /* Perform reads */
+
+    while( timeout != 0 && failed != 1 && valid != 1)
+    {
+        /* Read the procif */
+        procReadData =  *(volatile unsigned int *)(PC20X_SLAVE_PROCIF_BASE + PROCIFCONFIGREADREGOFFSET);
+
+        /* if valid bit set then set flag */
+        if(procReadData & PA_CONFIG_VALID)
+        {
+            valid = 1;
+        }
+
+        /* if fail bit set then set flag */
+        if(procReadData & PA_CONFIG_FAIL)
+        {
+            failed = 1;
+        }
+
+        /* increment timeout count */
+        timeout--;
+    }
+
+    if(timeout == 0)
+    {
+        procReadData = procReadData | PA_CONFIG_TIMEOUTOCCURED;
+    }
+
+    return procReadData;
+}
+
+static unsigned short FPGARead(unsigned int fpga, unsigned char reg)
+{
+#define SPI_SH_DELAY 1
+#define TXRX_LEN 2
+#define CS1     (1 << 4)
+#define CS0     (1 << 3)
+#define CLK     (1 << 2)
+#define MISO    (1 << 1)
+#define MOSI    (1 << 0)
+    unsigned int odr, idr, ddr;
+    unsigned char bits;
+    unsigned short txrx_buf[TXRX_LEN];
+    int i;
+    unsigned int chip_select = 0;
+
+    if (fpga == DID_RC_FPGA)
+    {
+        /* Trying to access the RC FPGA */
+        chip_select = CS1;
+    }
+    else
+    {
+        /* trying to access the AD FPGA */
+        chip_select = CS0;
+    }
+
+    odr = *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortAOutputDataRegOffset) & 0xe0;
+    ddr = *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortADataDirectionRegOffset) & 0xe0;
+
+    /* Setup GPIO directions and initial state */
+
+    /* CS1, CS0, MOSI and MISO low. Set CLK high */
+    odr |= CLK;
+    *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortAOutputDataRegOffset) = odr;
+
+    /* CS1, CS0, CLK and MOSI outputs, MISO input */
+    ddr |= (CS1 | CS0 | CLK | MOSI);
+    *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortADataDirectionRegOffset) = ddr;
+
+    /* Set chip select */
+    odr |= chip_select;
+    *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortAOutputDataRegOffset) = odr;
+
+    /* Setup the txrx buffer */
+    txrx_buf[0] = (reg << 8) | (1 << 7);  /* The address to access and read command bit */
+    txrx_buf[1] = 0;            /* The data read will appear here */
+
+    /* transfer each word */
+    for (i = 0; i < TXRX_LEN; i++)
+    {
+        bits = 16;
+        /* if (cpol == 0) this is SPI_MODE_0; else this is SPI_MODE_2 */
+
+        /* clock starts at inactive polarity */
+        for (txrx_buf[i] <<= (16 - bits); bits; bits--)
+        {
+            /* setup MSB (to slave) on trailing edge */
+            if (txrx_buf[i] & (1 << 15))
+            {
+                odr |= MOSI;
+            }
+            else
+            {
+                odr &= ~MOSI;
+            }
+            *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortAOutputDataRegOffset) = odr;
+
+            udelay(SPI_SH_DELAY);	/* T(setup) */
+
+            /* Set CLK low */
+            odr &= ~CLK;
+            *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortAOutputDataRegOffset) = odr;
+
+            udelay(SPI_SH_DELAY);
+
+            /* sample MSB (from slave) on leading edge */
+            txrx_buf[i] <<= 1;
+            idr = *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortAInputDataRegOffset);
+            if (idr & MISO)
+            {
+                txrx_buf[i] |= 0x01;
+            }
+
+            /* Set CLK high */
+            odr |= CLK;
+            *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortAOutputDataRegOffset) = odr;
+        }
+    }
+
+    /* Reset chip select and provide one clock cycle to reset the transfer */
+    udelay(SPI_SH_DELAY);
+    odr &= ~(chip_select);
+    *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortAOutputDataRegOffset) = odr;
+
+    odr &= ~CLK;
+    *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortAOutputDataRegOffset) = odr;
+
+    udelay(SPI_SH_DELAY);
+    odr |= CLK;
+    *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortAOutputDataRegOffset) = odr;
+
+    /* The result is left in the second word */
+    return txrx_buf[1];
+}
+
+static void display_board_type (unsigned short vers_reg,
+                                unsigned short id_reg)
+{
+    unsigned short board_type;
+
+    if (((vers_reg & FPGA_VERS_CODE_REV_MASK) >> FPGA_VERS_CODE_REV_SHIFT) > 1)
+    {
+        board_type = (id_reg & V2_FPGA_DID_BOARD_TYPE_MASK) >> V2_FPGA_DID_BOARD_TYPE_SHIFT;
+    }
+    else
+    {
+        board_type = (id_reg & V1_FPGA_DID_BOARD_TYPE_MASK) >> V1_FPGA_DID_BOARD_TYPE_SHIFT;
+    }
+
+    puts("Board: ");
+    switch (board_type)
+    {
+        case BOARD_TYPE_PC7205:
+        {
+            puts("PC7205\n");
+            break;
+        }
+        case BOARD_TYPE_HDP203:
+        {
+            puts("HDP203\n");
+            break;
+        }
+        default:
+        {
+            printf("Unknown (%u)\n", board_type);
+        }
+    }
+}
+
+static void display_fpga_info (unsigned short vers_reg,
+                               unsigned short id_reg)
+{
+    puts("FPGA:  ");
+    switch ((id_reg & FPGA_DID_DEVICE_ID_MASK) >> FPGA_DID_DEVICE_ID_SHIFT)
+    {
+        case DID_RC_FPGA:
+        {
+            puts("RC_FPGA");
+            break;
+        }
+        case DID_AD_FPGA:
+        {
+            puts("AD_FPGA");
+            break;
+        }
+        default:
+        {
+            printf("Unknown type (%u)", (id_reg & FPGA_DID_DEVICE_ID_MASK) >> FPGA_DID_DEVICE_ID_SHIFT);
+        }
+    }
+    printf(", v%u r%u\n",
+            (vers_reg & FPGA_VERS_CODE_REV_MASK) >> FPGA_VERS_CODE_REV_SHIFT,
+            (vers_reg & FPGA_VERS_CODE_REL_MASK) >> FPGA_VERS_CODE_REL_SHIFT);
+}
diff --git a/board/picochip/cpe20x/lowlevel_init.S b/board/picochip/cpe20x/lowlevel_init.S
new file mode 100644
index 0000000..6a76b3a
--- /dev/null
+++ b/board/picochip/cpe20x/lowlevel_init.S
@@ -0,0 +1,340 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file lowlevel_init.S
+* \brief Various low level setup functions.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#include <config.h>
+#include <asm/arch/pc20x.h>
+#include <asm/arch/memif.h>
+#include <asm/arch/ebi.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/rap.h>
+#include <asm/arch/procif.h>
+
+/*****************************************************************************
+ *
+ * lowlevel_init
+ *
+ * Description: Perform some low level PC20x initialisation
+ *
+ *****************************************************************************/
+
+ .global lowlevel_init
+
+ lowlevel_init:
+
+        /* Preserve link register across call */
+        mov r11,lr
+
+#ifdef CONFIG_PC20X_SIMULATION
+        bl      register_initialisation
+#endif
+
+        /* Extinguish LEDS controlled by the ARM gpio */
+        bl      extinguishArmLeds
+
+        /* Setup the ebi memory interface (Flash Memory) */
+        bl      ebi_init
+
+        /* Setup the memory interface (DDR2 Memory) */
+        bl      memif_init
+
+        /* Restore link register */
+        mov     lr, r11
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * ebi_init
+ *
+ * Description: Initialise the External Bus Interface
+ *
+ *****************************************************************************/
+
+ebi_init:
+
+        mov	pc, lr		/* Return to my caller */
+
+/*****************************************************************************
+ *
+ * memif_init
+ *
+ * Description: Initialise the Memory Controller
+ *
+ * Note:
+ * Before using SDRAM, we must wait 200us for it to initialise, accesses
+ * will be held off until the initialisation process is complete.
+ *
+ *****************************************************************************/
+
+memif_init:
+
+/*****************************************************************************
+ Reset the MEMIF before continuing
+*****************************************************************************/
+        ldr     r0, =PC20X_PROCIF_BASE
+        ldr     r1, =ProcifIntGpioRegOffset
+        ldr     r2, =ProcifGpioMemifSofResetMask
+        orr     r0, r0, r1
+
+        ldr     r1, [r0]
+        orr     r1, r1, r2
+        str     r1, [r0]
+
+waitForMemIfResetToClear:
+        ldr     r1, [r0]
+        ands    r1, r1, r2
+        bne     waitForMemIfResetToClear
+
+/*****************************************************************************
+ Setup MEMIF base address
+*****************************************************************************/
+
+        ldr     r2, =PC20X_MEM_IF_BASE
+
+/*****************************************************************************
+ DLL Configuration
+*****************************************************************************/
+
+/* DLL #0 */
+        ldr     r3, =DLL0SlaveAdjustValue
+        ldr     r4, =DLL0SlaveAdjustRegOffset
+        orr     r4, r4, r2
+        strh    r3, [r4]
+
+/* DLL #1 */
+        ldr     r3, =DLL1SlaveAdjustValue
+        ldr     r4, =DLL1SlaveAdjustRegOffset
+        orr     r4, r4, r2
+        strh    r3, [r4]
+
+/* DLL #2 */
+        ldr     r3, =DLL2SlaveAdjustValue
+        ldr     r4, =DLL2SlaveAdjustRegOffset
+        orr     r4, r4, r2
+        strh    r3, [r4]
+
+/* DLL #3 */
+        ldr     r3, =DLL3SlaveAdjustValue
+        ldr     r4, =DLL3SlaveAdjustRegOffset
+        orr     r4, r4, r2
+        strh    r3, [r4]
+
+/* Initiate a DLL update */
+        ldr     r3, =DLLConfigUpdate
+        ldr     r4, =DLLConfigUpdateRegOffset
+        orr     r4, r4, r2
+        strh    r3, [r4]
+
+/* Wait until the DLL update has completed */
+
+waitForDLLUpdate:
+        ldrh    r3, [r4]
+        tst     r3, #DLLConfigUpdateInProgress
+        bne     waitForDLLUpdate
+
+/*****************************************************************************
+ SDRAM Arbitration
+*****************************************************************************/
+
+#ifndef CONFIG_PC20X_2_DDR_RAM_BANKS
+/* We want a 4 DDR Bank setup then */
+
+        mov     r3, #0x0000
+        strh    r3, [r2, #MemifSdramArbGroup0SlotAConfigRegOffset]
+        strh    r3, [r2, #MemifSdramArbGroup0SlotBConfigRegOffset]
+
+        mov     r3, #0x0400
+        orr     r3, r3, #0x0004
+        strh    r3, [r2, #MemifSdramArbGroup1SlotAConfigRegOffset]
+        strh    r3, [r2, #MemifSdramArbGroup1SlotBConfigRegOffset]
+
+        mov     r3, #0x0003
+        strh    r3, [r2, #MemifSdramArbValidGroupsConfigRegOffset]
+
+#else   /* We want a 2 DDR Bank setup then */
+
+        /* Group 0, Banks 0 & 1 -> ARM, Rd, Deterministic */
+        mov     r3, #0x0000
+        strh    r3, [r2, #MemifSdramArbGroup0SlotAConfigRegOffset]
+
+        /* Group 0, Banks 2 & 3 -> pA, Rd, Deterministic */
+        mov     r3, #0x0100
+        orr     r3, r3, #0x0001
+        strh    r3, [r2, #MemifSdramArbGroup0SlotBConfigRegOffset]
+
+        /* Group 1, Banks 0 & 1 -> ARM, Wr, Deterministic */
+        mov     r3, #0x0400
+        orr     r3, r3, #0x0004
+        strh    r3, [r2, #MemifSdramArbGroup1SlotAConfigRegOffset]
+
+        /* Group 1, Banks 2 & 3 -> pA, Wr Deterministic */
+        mov     r3, #0x0500
+        orr     r3, r3, #0x0005
+        strh    r3, [r2, #MemifSdramArbGroup1SlotBConfigRegOffset]
+
+        /* Valid Groups, 2 */
+        mov     r3, #0x0003
+        strh    r3, [r2, #MemifSdramArbValidGroupsConfigRegOffset]
+
+#endif
+
+/*****************************************************************************
+ SDRAM Setup
+*****************************************************************************/
+
+/* Set the SDRAM size and width */
+        mov     r3, #SdramSize13r10c
+        orr     r3, r3, #SdramWidth32
+        orr     r3, r3, #SdramRWGap4
+        orr     r3, r3, #SdramWRGap7
+        orr     r3, r3, #SdramOdt75Ohm
+        orr     r3, r3, #SdramCaptureDelay1Mclk
+        strh    r3, [r2,#MemifSdramSetupRegOffset]
+
+/* Set the refresh rate */
+        ldr     r3, =SdramRefreshCount
+        strh    r3, [r2, #MemifSdramRefreshRateRegOffset]
+
+/* Set the device mode register */
+        mov     r3, #0x0400
+        orr     r3, r3, #0x0042
+        strh    r3, [r2, #MemifSdramMrsRegOffset]
+
+/* Set the extended mode register */
+        ldr     r3, =SdramEmrsSetup
+        strh    r3, [r2, #MemifSdramErsRegOffset]
+
+/*****************************************************************************
+ Configuration complete, start the mem-if
+*****************************************************************************/
+        mov     r3, #SdramSetupComplete
+        strh    r3, [r2, #MemifSdramSetupCompleteReg]
+        mov     r3, #SramSetupComplete
+        strh    r3, [r2, #MemifSramSetupCompleteReg]
+
+        mov	pc, lr		/* Return to my caller */
+
+/*****************************************************************************
+ *
+ * ddr2_dummy_access
+ *
+ * Description: Perform a 'dummy' write to and read back from the DDR2 SDRAM
+ *
+ *****************************************************************************/
+.global ddr2_dummy_access
+
+ ddr2_dummy_access:
+        ldr     r0, =PHYS_SDRAM_1
+        mov     r1, #0x00000000
+        str     r1, [r0]    /* perform a 'dummy' write */
+
+        ldr     r2, [r0]    /* perform a 'dummy' read */
+        cmp     r1, r2      /* ignore the result */
+
+        mov	pc, lr      /* Return to my caller */
+
+/*****************************************************************************
+ *
+ * register_initialisation
+ *
+ * Description: Initialise some CPU registers
+ *
+ * Note:
+ * Used to prevent X propagation if running this code in a simulation
+ *
+ *****************************************************************************/
+
+register_initialisation:
+
+        mov     r0, #0x00000000
+        mov     r1, #0x00000000
+        mov     r2, #0x00000000
+        mov     r3, #0x00000000
+        mov     r4, #0x00000000
+        mov     r5, #0x00000000
+        mov     r6, #0x00000000
+        mov     r7, #0x00000000
+        mov     r8, #0x00000000
+        mov     r9, #0x00000000
+        mov     r10,#0x00000000
+
+        /* Don't noodle with r11 (fp)
+                             r12 (ip)
+                             r13 (sp)
+                             r14 (lr)
+                             r15 (pc)
+           as this would cause big probs ! */
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * assertBootError
+ *
+ * Illuminate LED15 on the picoChip CPE20x hardware platform
+ *
+ *****************************************************************************/
+ .global assertBootError
+
+ assertBootError:
+
+         /* Get base address of the gpio block */
+        ldr r0,=PC20X_GPIO_BASE
+
+        /* Set up ARM gpio bit #0 as an o/p */
+        ldr r1,[r0, #GpioPortADataDirectionRegOffset]
+        orr r1,r1,#Gpio(0)
+        str r1,[r0, #GpioPortADataDirectionRegOffset]
+
+        /* Illuminate LED15 on the CPE20x Platform */
+        mov r1, #Gpio(0)
+        str r1,[r0, #GpioPortAOutputDataRegOffset]
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * extinguishArmLeds
+ *
+ * Extinguish both ARM controlled LEDS on the CPE20x Platform
+ *
+ *****************************************************************************/
+
+.global extinguishArmLeds
+
+extinguishArmLeds:
+
+        /* Get base address of the gpio block */
+        ldr r0,=PC20X_GPIO_BASE
+
+        /* Setup ARM gpio bits #0 & #1 as an outputs */
+        ldr r1,[r0, #GpioPortADataDirectionRegOffset]
+        orr r1,r1,#Gpio(0)
+        orr r1,r1,#Gpio(1)
+        str r1,[r0, #GpioPortADataDirectionRegOffset]
+
+        /* Extinguish LEDS 14 & 15 on the CPE20x Platform */
+        mov r1,#0x00000000
+        str r1,[r0, #GpioPortAOutputDataRegOffset]
+
+        /* Return to my caller */
+        mov     pc, lr
+
+       .end
diff --git a/board/picochip/cpe20x/u-boot.lds b/board/picochip/cpe20x/u-boot.lds
new file mode 100644
index 0000000..02c90dc
--- /dev/null
+++ b/board/picochip/cpe20x/u-boot.lds
@@ -0,0 +1,45 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file u-boot.lds
+* \brief Used during the build process.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+	. = ALIGN(4);
+	.text	:
+	{
+		cpu/arm926ejs/start.o (.text)
+		*(.text)
+	}
+	.rodata : { *(.rodata) }
+	. = ALIGN(4);
+	.data : { *(.data) }
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff --git a/board/picochip/hdp203/Makefile b/board/picochip/hdp203/Makefile
new file mode 100644
index 0000000..2d0e891
--- /dev/null
+++ b/board/picochip/hdp203/Makefile
@@ -0,0 +1,48 @@
+# BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+#
+# (C) Copyright 2001
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= $(BOARD).o law.o tlb.o
+SOBJS	:=
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS)
+
+clean:
+	rm -f $(OBJS) $(SOBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff --git a/board/picochip/hdp203/config.mk b/board/picochip/hdp203/config.mk
new file mode 100644
index 0000000..c9f3a7b
--- /dev/null
+++ b/board/picochip/hdp203/config.mk
@@ -0,0 +1,59 @@
+#
+# $picoChipHeaderSubst$
+#
+
+#
+# (C) Copyright 2004
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# Configured for picoChip HDP target (www.picochip.com)
+#     by david.warman@zetetica.co.uk
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# picoChip HDP203 board
+#
+
+# If we want a RAM boot....
+#ifeq ($(ramsym),1)
+#TEXT_BASE = 0x07FD0000
+#CFG_RAMBOOT = 1
+#else
+# Reserve 512K for boot at top of flash; first 256K is environment
+TEXT_BASE = 0xFFFC0000
+#endif
+
+PLATFORM_CPPFLAGS += -DCONFIG_MPC85xx=1
+PLATFORM_CPPFLAGS += -DCONFIG_MPC8560=1
+PLATFORM_CPPFLAGS += -DCONFIG_E500=1
+
+ifeq ($(debug),1)
+PLATFORM_CPPFLAGS += -DDEBUG
+endif
+
+ifdef BSP_DIR
+include $(BSP_DIR)/config
+PLATFORM_CPPFLAGS += -DPICOCHIP_PLATFORM_VERSION=\"$(RELEASE_VERSION)\"
+endif
+
+#ifeq ($(dbcr),1)
+#PLATFORM_CPPFLAGS += -DCFG_INIT_DBCR=0x8cff0000
+#endif
diff --git a/board/picochip/hdp203/hdp203.c b/board/picochip/hdp203/hdp203.c
new file mode 100644
index 0000000..1b2c208
--- /dev/null
+++ b/board/picochip/hdp203/hdp203.c
@@ -0,0 +1,722 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Board support for the picoChip HDP203 platform (http://www.picochip.com/)
+ *
+ * Copyright 2005 Zetetica Ltd.  <david.warman@zetetica.co.uk>
+ *     originally based on MPC8560ADS support.
+ *
+ * Copyright 2004 Freescale Semiconductor.
+ * (C) Copyright 2003,Motorola Inc.  Xianghua Xiao, (X.Xiao@motorola.com)
+ * (C) Copyright 2002 Scott McNutt <smcnutt@artesyncp.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Revision April 13, 2007 - stuartr
+ * 	Arrays of constants for UPM updated : Dummy write address 
+ * 	changed from 0xC000_0000 to 0xD000_0000, three wait states added
+ * 	to pico_single_read{ } upm_data table 
+ *
+ */
+
+
+#include <common.h>
+#include <pci.h>
+#include <asm/processor.h>
+#include <asm/immap_85xx.h>
+#include <asm/mmu.h>
+#include <ioports.h>
+#include <spd.h>
+#include <miiphy.h>
+
+#if defined(CONFIG_DDR_ECC)
+extern void ddr_enable_ecc(unsigned int dram_size);
+#endif
+
+extern long int spd_sdram(void);
+
+void local_bus_init(void);
+long int fixed_sdram(void);
+void pico_init(void);
+
+/*
+ * I/O Port configuration table
+ *
+ * if conf is 1, then that port pin will be configured at boot time
+ * according to the five values podr/pdir/ppar/psor/pdat for that entry
+ */
+
+/* Names in the rightmost column match the netlist names on the schematic */
+
+const iop_conf_t iop_conf_tab[4][32] = {
+    /* For the moment, leave PORTA tristate (default) in the bootstrap */
+    /* Port A configuration */
+    {   /*            conf ppar psor pdir podr pdat */
+	/* PA31 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_TXEN */
+	/* PA30 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_TXCLAV */
+	/* PA29 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_TXSOC */
+	/* PA28 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_RXEN */
+	/* PA27 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_RXSOC */
+	/* PA26 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_RXCLAV */
+	/* PA25 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_TXD0 */
+	/* PA24 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_TXD1 */
+	/* PA23 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_TXD2 */
+	/* PA22 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_TXD3 */
+	/* PA21 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_TXD4 */
+	/* PA20 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_TXD5 */
+	/* PA19 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_TXD6 */
+	/* PA18 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_TXD7 */
+	/* PA17 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_RXD7 */
+	/* PA16 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_RXD6 */
+	/* PA15 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_RXD5 */
+	/* PA14 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_RXD4 */
+	/* PA13 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_RXD3 */
+	/* PA12 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_RXD2 */
+	/* PA11 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_RXD1 */
+	/* PA10 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_RXD0 */
+	/* PA9  */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PA8  */ {   0,   0,   0,   0,   0,   0   }, /* CPM_SP7 */
+	/* PA7  */ {   0,   0,   0,   0,   0,   0   }, /* CPM_SP6 */
+	/* PA6  */ {   0,   0,   0,   0,   0,   0   }, /* CPM_SP5 */
+	/* PA5  */ {   0,   0,   0,   0,   0,   0   }, /* ATM_RXPAR */
+	/* PA4  */ {   0,   0,   0,   0,   0,   0   }, /* CPM_SP4 */
+	/* PA3  */ {   0,   0,   0,   0,   0,   0   }, /* CPM_SP3 */
+	/* PA2  */ {   0,   0,   0,   0,   0,   0   }, /* CPM_SP2 */
+	/* PA1  */ {   0,   0,   0,   0,   0,   0   }, /* CPM_SP1 */
+	/* PA0  */ {   0,   0,   0,   0,   0,   0   }  /* CPM_SP0 */
+    },
+
+    /* Port B configuration */
+    {   /*            conf ppar psor pdir podr pdat */
+	/* PB31 */ {   0,   0,   0,   0,   0,   0   }, /* CPM_GPIO15 */
+	/* PB30 */ {   0,   0,   0,   0,   0,   0   }, /* CPM_GPIO14 */
+	/* PB29 */ {   0,   0,   0,   0,   0,   0   }, /* CPM_GPIO13 */
+	/* PB28 */ {   0,   0,   0,   0,   0,   0   }, /* CPM_GPIO12 */
+	/* PB27 */ {   0,   0,   0,   0,   0,   0   }, /* CPM_GPIO11 */
+	/* PB26 */ {   0,   0,   0,   0,   0,   0   }, /* CPM_GPIO10 */
+	/* PB25 */ {   0,   0,   0,   0,   0,   0   }, /* CPM_GPIO9 */
+	/* PB24 */ {   0,   0,   0,   0,   0,   0   }, /* CPM_GPIO8 */
+	/* PB23 */ {   0,   0,   0,   0,   0,   0   }, /* CPM_GPIO7 */
+	/* PB22 */ {   0,   0,   0,   0,   0,   0   }, /* CPM_GPIO6 */
+	/* PB21 */ {   0,   0,   0,   0,   0,   0   }, /* CPM_GPIO5 */
+	/* PB20 */ {   0,   0,   0,   0,   0,   0   }, /* CPM_GPIO4 */
+	/* PB19 */ {   0,   0,   0,   0,   0,   0   }, /* CPM_GPIO3 */
+	/* PB18 */ {   0,   0,   0,   0,   0,   0   }, /* CPM_GPIO2 */
+	/* PB17 */ {   0,   0,   0,   0,   0,   0   }, /* CPM_GPIO1 */
+	/* PB16 */ {   0,   0,   0,   0,   0,   0   }, /* CPM_GPIO0 */
+	/* PB15 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PB14 */ {   1,   1,   0,   0,   0,   0   }, /* RS232_RX0 (SCC3) */
+	/* PB13 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PB12 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PB11 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PB10 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PB9  */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PB8  */ {   1,   1,   1,   1,   0,   0   }, /* RS232_TX0 (SCC3) */
+	/* PB7  */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PB6  */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PB5  */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PB4  */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PB3  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB2  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB1  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PB0  */ {   0,   0,   0,   0,   0,   0   }  /* pin doesn't exist */
+    },
+
+    /* Port C */
+    {   /*            conf ppar psor pdir podr pdat */
+	/* PC31 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PC30 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PC29 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PC28 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PC27 */ {   1,   1,   0,   0,   0,   0   }, /* CPM_CLK5 */
+	/* PC26 */ {   1,   1,   0,   0,   0,   0   }, /* CPM_CLK6 */
+	/* PC25 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PC24 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PC23 */ {   1,   1,   0,   0,   0,   0   }, /* CPM_CLK9 */
+	/* PC22 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_TXPAR */
+	/* PC21 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PC20 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PC19 */ {   1,   1,   1,   0,   0,   0   }, /* CPM_SPI_CLK */
+	/* PC18 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PC17 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PC16 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PC15 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_TXA0 */
+	/* PC14 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_RXA0 */
+	/* PC13 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_TXA1 */
+	/* PC12 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_RXA1 */
+	/* PC11 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PC10 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PC9  */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PC8  */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PC7  */ {   0,   0,   0,   0,   0,   0   }, /* ATM_TXA2 */
+	/* PC6  */ {   0,   0,   0,   0,   0,   0   }, /* ATM_RXA2 */
+	/* PC5  */ {   0,   0,   0,   0,   0,   0   }, /* CPM_SPI_nCS5 */
+	/* PC4  */ {   0,   0,   0,   0,   0,   0   }, /* CPM_SPI_nCS4 */
+	/* PC3  */ {   0,   0,   0,   0,   0,   0   }, /* CPM_SPI_nCS3 */
+	/* PC2  */ {   0,   0,   0,   0,   0,   0   }, /* CPM_SPI_nCS2 */
+	/* PC1  */ {   0,   0,   0,   0,   0,   0   }, /* CPM_SPI_nCS1 */
+	/* PC0  */ {   0,   0,   0,   0,   0,   0   }, /* CPM_SPI_nCS0 */
+    },
+
+    /* Port D */
+    {   /*            conf ppar psor pdir podr pdat */
+	/* PD31 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PD30 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PD29 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_RXA3 */
+	/* PD28 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PD27 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PD26 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PD25 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PD24 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PD23 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PD22 */ {   1,   1,   0,   0,   0,   0   }, /* RS232_RX1 (SCC4) */
+	/* PD21 */ {   1,   1,   0,   1,   0,   0   }, /* RS232_TX1 (SCC4) */
+	/* PD20 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PD19 */ {   0,   0,   0,   0,   0,   0   }, /* ATM_TXA4 */
+	/* PD18 */ {   0,   0,   0,   0,   0,   0   }, /* ATX_RXA4 */
+	/* PD17 */ {   1,   1,   1,   0,   0,   0   }, /* CPM_SPI_MOSI */
+	/* PD16 */ {   1,   1,   1,   0,   0,   0   }, /* CPM_SPI_MISO */
+	/* PD15 */ {   1,   1,   1,   0,   1,   0   }, /* CPM_I2C_DA */
+	/* PD14 */ {   1,   1,   1,   0,   1,   0   }, /* CPM_I2C_CLK */
+	/* PD13 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PD12 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PD11 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PD10 */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PD9  */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PD8  */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PD7  */ {   0,   0,   0,   0,   0,   0   }, /* ATM_TXA3 */
+	/* PD6  */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PD5  */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PD4  */ {   0,   0,   0,   0,   0,   0   }, /* - (NC) */
+	/* PD3  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD2  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD1  */ {   0,   0,   0,   0,   0,   0   }, /* pin doesn't exist */
+	/* PD0  */ {   0,   0,   0,   0,   0,   0   }  /* pin doesn't exist */
+    }
+};
+
+typedef struct upm_data
+{
+	uint mode;
+	uint dummy;
+	uint entries;
+	uint data[];
+} upm_data_t;
+
+/* UPM configuration for access to picoChip DMAs */
+
+const upm_data_t pico_single_read =
+{ 	0x10000000, 	/* offset 0x00 */
+	0xD0000000,
+	6,
+	{ 0x0FFFFC00, 
+	  0x0FFCFC00,
+	  0x0FFCFC00,  /* 1st wait state */
+	  0x0FFCFC00,  /* 2nd wait state */
+	  0x0FFCFC00,  /* 3rd wait state */
+	  0x0FFCFC05
+	}
+};
+
+const upm_data_t pico_burst_read =    /* 3 wait states need to be added in here if bursting is to be used. To be done */
+{ 	0x10000008, 	/* offset 0x08 */
+	0xD0000000,
+	10,
+	{ 0x0FFEFC00,
+	  0x0FFCFC04,
+	  0x0FFCFC04,
+	  0x0FFCFC0C,
+	  0x0FFCFC0C,
+	  0x0FFCFC0C,
+	  0x0FFCFC0C,
+	  0x0FFCFC0C,
+	  0x0FFCFC0C,
+	  0x0FFCFC0D
+	}
+};
+
+const upm_data_t pico_single_write =
+{ 	0x10000018, 	/* offset 0x18 */
+	0xD0000000,
+	3,
+	{ 0x0FFFFC00,
+	  0x0FFFFC00,
+	  0x00FFFC05
+	}
+};
+
+const upm_data_t pico_burst_write =
+{ 	0x10000020, 	/* offset 0x20 */
+	0xD0000000,
+	9,
+	{ 0x0FFFFC00,
+	  0x00FFFC04,
+	  0x0FFCFC0C,
+	  0x0FFCFC0C,
+	  0x0FFCFC0C,
+	  0x0FFCFC0C,
+	  0x0FFCFC0C,
+	  0x0FFCFC0C,
+	  0x0FFCFC0D
+	}
+};
+
+int board_early_init_f (void)
+{
+	return 0;
+}
+
+void reset_phy (void)
+{
+	/* PHY reset is connected to hardware reset on this target */
+}
+
+
+int checkboard (void)
+{
+	puts("Board: picoChip HDP203\n");
+
+#ifdef CONFIG_PCI
+	printf("PCI1:  32 bit, %d MHz (compiled)\n",
+	       CONFIG_SYS_CLK_FREQ / 1000000);
+#else
+	printf("PCI1:  disabled\n");
+#endif
+
+	/*
+	 * Initialize local bus.
+	 */
+	local_bus_init();
+
+	/* Check picoChip status 
+	 */
+	pico_init();
+
+	return 0;
+}
+
+
+phys_size_t
+initdram(int board_type)
+{
+	long dram_size = 0;
+	extern long spd_sdram (void);
+
+	puts("Initializing...\n");
+
+#if defined(CONFIG_DDR_DLL)
+	{
+	    volatile ccsr_gur_t *gur= (void *)(CFG_MPC85xx_GUTS_ADDR);
+	    uint temp_ddrdll = 0;
+
+	    /*
+	     * Work around to stabilize DDR DLL
+	     */
+	    temp_ddrdll = gur->ddrdllcr;
+	    gur->ddrdllcr = ((temp_ddrdll & 0xff) << 16) | 0x80000000;
+	    asm("sync;isync;msync");
+	}
+#endif
+
+#if defined(CONFIG_SPD_EEPROM)
+        {
+           dram_size = spd_sdram ();
+        }
+#else
+	{
+           dram_size = fixed_sdram ();
+        } 
+#endif
+
+#if defined(CONFIG_DDR_ECC)
+	/*
+	 * Initialize and enable DDR ECC.
+	 */
+	ddr_enable_ecc(dram_size);
+#endif
+
+	puts("DDR:   ");
+	return dram_size;
+}
+
+void program_upm_a(const upm_data_t const* upm)
+{
+	volatile ccsr_lbc_t *lbc = (void *)(CFG_MPC85xx_LBC_ADDR);
+
+	uint i;
+
+	/* Set base of UPM region */
+	lbc->mamr = upm->mode;
+	for(i = 0; i < upm->entries; i++) {
+
+		/* Data to write to UPM */
+		lbc->mdr = upm->data[i];
+
+		/* Dummy write to region commits data */
+		*(volatile uint*)(upm->dummy) = 0x0;
+
+		/* Force sync between writes */
+		asm("sync;isync;msync");
+	}
+
+	/* Configure for normal operation */
+
+
+	/* Old : lbc->mamr = upm->mode & ~0x30000000; */
+
+	lbc->mamr = 0x08000000; 	/* Setting mamr to 0x8000000 does the biz in Lauterbach scripts */ 
+
+}
+
+/*
+ * Initialize Local Bus
+ */
+void
+local_bus_init(void)
+{
+	volatile ccsr_gur_t *gur = (void *)(CFG_MPC85xx_GUTS_ADDR);
+	volatile ccsr_lbc_t *lbc = (void *)(CFG_MPC85xx_LBC_ADDR);
+
+	uint clkdiv;
+	uint lbc_hz;
+	sys_info_t sysinfo;
+
+	/*
+	 * Errata LBC11.
+	 * Fix Local Bus clock glitch when DLL is enabled.
+	 *
+	 * If localbus freq is < 66Mhz, DLL bypass mode must be used.
+	 * If localbus freq is > 133Mhz, DLL can be safely enabled.
+	 * Between 66 and 133, the DLL is enabled with an override workaround.
+	 */
+
+	get_sys_info(&sysinfo);
+	clkdiv = lbc->lcrr & 0x0f;
+	lbc_hz = sysinfo.freqSystemBus / 1000000 / clkdiv;
+
+	if (lbc_hz < 66) {
+		lbc->lcrr = CFG_LBC_LCRR | 0x80000000;	/* DLL Bypass */
+
+	} else if (lbc_hz >= 133) {
+		lbc->lcrr = CFG_LBC_LCRR & (~0x80000000); /* DLL Enabled */
+
+	} else {
+		/*
+		 * On REV1 boards, need to change CLKDIV before enable DLL.
+		 * Default CLKDIV is 8, change it to 4 temporarily.
+		 */
+		uint pvr = get_pvr();
+		uint temp_lbcdll = 0;
+
+		if (pvr == PVR_85xx_REV1) {
+			/* FIXME: Justify the high bit here. */
+			lbc->lcrr = 0x10000004;
+		}
+
+		lbc->lcrr = CFG_LBC_LCRR & (~0x80000000);/* DLL Enabled */
+		udelay(200);
+
+		/*
+		 * Sample LBC DLL ctrl reg, upshift it to set the
+		 * override bits.
+		 */
+		temp_lbcdll = gur->lbcdllcr;
+		gur->lbcdllcr = (((temp_lbcdll & 0xff) << 16) | 0x80000000);
+		asm("sync;isync;msync");
+	}
+
+	lbc->lbcr = CFG_LBC_LBCR;
+	asm("msync");
+
+	lbc->lsrt = CFG_LBC_LSRT;
+	lbc->mrtpr = CFG_LBC_MRTPR;
+	asm("sync");
+
+	/* Most of the local bus control registers are set by the CPU
+	 * section, but for some reason OR2 is not programmed for
+	 * an MPC85xx - probably something to do with the ADS.
+	 * We do it here to minimise patches.
+	 */
+
+	lbc->br2 = CFG_BR2_PRELIM;
+	lbc->or2 = CFG_OR2_PRELIM;
+
+	/* Now set up the UPM for picoChip */
+
+	program_upm_a(&pico_single_read);
+	program_upm_a(&pico_burst_read);
+	program_upm_a(&pico_single_write);
+	program_upm_a(&pico_burst_write);
+
+}
+
+
+#if defined(CFG_DRAM_TEST)
+int testdram (void)
+{
+	uint *pstart = (uint *) CFG_MEMTEST_START;
+	uint *pend = (uint *) CFG_MEMTEST_END;
+	uint *p;
+
+	printf("SDRAM test phase 1:\n");
+	for (p = pstart; p < pend; p++)
+		*p = 0xaaaaaaaa;
+
+	for (p = pstart; p < pend; p++) {
+		if (*p != 0xaaaaaaaa) {
+			printf ("SDRAM test fails at: %08x\n", (uint) p);
+			return 1;
+		}
+	}
+
+	printf("SDRAM test phase 2:\n");
+	for (p = pstart; p < pend; p++)
+		*p = 0x55555555;
+
+	for (p = pstart; p < pend; p++) {
+		if (*p != 0x55555555) {
+			printf ("SDRAM test fails at: %08x\n", (uint) p);
+			return 1;
+		}
+	}
+
+	printf("SDRAM test passed.\n");
+	return 0;
+}
+#endif
+
+
+#if !defined(CONFIG_SPD_EEPROM)
+/*************************************************************************
+ *  fixed sdram init -- doesn't use serial presence detect.
+ ************************************************************************/
+long int fixed_sdram (void)
+{
+	volatile ccsr_ddr_t *ddr= (void *)(CFG_MPC85xx_DDR_ADDR);
+	volatile ccsr_local_ecm_t *ecm = (void *)(CFG_MPC85xx_ECM_ADDR);
+
+    #ifndef CFG_RAMBOOT
+	ddr->cs0_bnds = CFG_DDR_CS0_BNDS;
+	ddr->cs0_config = CFG_DDR_CS0_CONFIG;
+	ddr->timing_cfg_1 = CFG_DDR_TIMING_1;
+	ddr->timing_cfg_2 = CFG_DDR_TIMING_2;
+	ddr->sdram_mode = CFG_DDR_MODE;
+	ddr->sdram_interval = CFG_DDR_INTERVAL;
+    #if defined (CONFIG_DDR_ECC)
+	ddr->err_disable = 0x0000000D;
+	ddr->err_sbe = 0x00ff0000;
+    #endif
+	asm("sync;isync;msync");
+	udelay(500);
+    #if defined (CONFIG_DDR_ECC)
+	/* Enable ECC checking */
+	ddr->sdram_cfg = (CFG_DDR_CONTROL | 0x20000000);
+    #else
+	/* Set the "start" bits last */
+	ddr->sdram_cfg = CFG_DDR_CONTROL & ~0xC0000000;
+	asm("sync; isync; msync");
+	ddr->sdram_cfg = CFG_DDR_CONTROL;
+    #endif
+	asm("sync; isync; msync");
+	udelay(500);
+  #endif /* CFG_RAMBOOT */
+
+	/* The SPD mode automatically enables the LAWBAR register
+	 * associated with the DDR bank in LAWBAR1 according to the
+	 * detected type.  We must do this explicitly here.
+	 */
+	ecm->lawar1 |= LAWAR_EN;
+
+	return CFG_SDRAM_SIZE * 1024 * 1024;
+}
+#endif	/* !defined(CONFIG_SPD_EEPROM) */
+
+#if defined(CONFIG_PCI)
+/*
+ * Initialize PCI Devices, report devices found.
+ */
+
+#ifndef CONFIG_PCI_PNP
+static struct pci_config_table pci_picohdp_config_table[] = {
+    { PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
+      PCI_IDSEL_NUMBER, PCI_ANY_ID,
+      pci_cfgfunc_config_device, { PCI_ENET0_IOADDR,
+				   PCI_ENET0_MEMADDR,
+				   PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER
+      } },
+    { }
+};
+#endif
+
+
+static struct pci_controller hose = {
+#ifndef CONFIG_PCI_PNP
+	config_table: pci_picohdp_config_table,
+#endif
+};
+
+#endif	/* CONFIG_PCI */
+
+
+void
+pci_init_board(void)
+{
+#ifdef CONFIG_PCI
+	extern void pci_mpc85xx_init(struct pci_controller *hose);
+
+	pci_mpc85xx_init(&hose);
+#endif /* CONFIG_PCI */
+}
+
+uint pico_read_ident(int id)
+{
+	uchar* picobase = (uchar*)(CFG_BR2_PRELIM & 0xFFFF0000);
+	volatile uint* picoget;
+	volatile uint* picoset;
+	uint data, timeout;
+
+	switch(id)
+	{
+		case 0:
+			picoget = (volatile uint*)(picobase + 0x0078);
+			picoset = (volatile uint*)(picobase + 0x007C);
+			break;
+
+		case 1: 
+			picoget = (volatile uint*)(picobase + 0x4078);
+			picoset = (volatile uint*)(picobase + 0x407C);
+			break;
+                
+                case 2:                
+			picoget = (volatile uint*)(picobase + 0x8078);
+			picoset = (volatile uint*)(picobase + 0x807C);
+			break;
+                
+                case 3: 
+			picoget = (volatile uint*)(picobase + 0xC078);
+			picoset = (volatile uint*)(picobase + 0xC07C);
+			break;
+                                        
+		default:
+			printf("Pico: No such device\n");
+			return 0;
+	}
+
+	/* Make sure there is no old read data in the pipeline */
+	data = *picoget;	
+ 	__asm__ __volatile__ ("eieio");
+	data = *picoget;	
+ 	__asm__ __volatile__ ("eieio");
+
+	*picoset = 0x00080048;
+ 	__asm__ __volatile__ ("eieio");
+	*picoset = 0x00040030;
+ 	__asm__ __volatile__ ("eieio");
+	*picoset = 0x00020000;
+ 	__asm__ __volatile__ ("eieio");
+
+
+	data = *picoget;	
+	__asm__ __volatile__ ("eieio");
+	timeout = 10;
+	while ((timeout > 0) && (data & 0x00010000) == 0x00000000) {
+		timeout--;
+		udelay(1);
+		data = *picoget;	
+		__asm__ __volatile__ ("eieio");
+	}
+	
+
+	return data;
+}
+
+/* This resets both picoArray devices via the CPLD */
+void pico_reset(void)
+{
+	uchar* cpld_reset = (uchar*)(CFG_BR1_PRELIM & 0xFFFF0000) + 0x06;
+                             
+        *(volatile unsigned short*)cpld_reset = 0x001F;	/* assert picoArray reset signals */
+                
+        udelay (1000);  /* wait a bit... */
+        
+        *(volatile unsigned short*)cpld_reset = 0xF01F; /* negate picoArray reset signals */
+}
+
+
+/* This function reports the cpld version */
+void pico_report_cpld_version(void)
+{
+	uchar* cpld_version = (uchar*)(CFG_BR1_PRELIM & 0xFFFF0000) + 0x00;
+
+        unsigned short cpldVersion;
+        uchar cpldVersionTens, cpldVersionUnits;
+                       
+        /* Read the cpld version */
+        cpldVersion = *(volatile unsigned short*)cpld_version;
+
+        cpldVersionTens = (cpldVersion & 0x00F0) >> 4;
+        cpldVersionUnits = (cpldVersion & 0x000F);
+        
+        printf("CPLD:  Version %01X.%01X\n", cpldVersionTens, cpldVersionUnits);
+}
+
+void pico_init(void)
+{
+	uint deva, devb, devc, devd;
+
+        /* Report the CPLD version during u-boot bootup */
+        pico_report_cpld_version();	
+        
+        /* Ensure the picoArrays are reset */
+        pico_reset();
+
+	/* Wait after reset */
+	udelay(1000);
+
+	/* Read the device idents */
+	deva = pico_read_ident(0);
+	devb = pico_read_ident(1);
+        devc = pico_read_ident(2);
+        devd = pico_read_ident(3);
+
+	printf("picoChip: PC203 ");
+
+	if (deva & 0x00010000) {
+		printf("Device A Id %04X ", deva & 0x0000FFFF);
+	}
+
+	if (devb & 0x00010000) {
+		printf("Device B Id %04X ", devb & 0x0000FFFF);
+	}
+
+        if (devc & 0x00010000) {
+		printf("Device C Id %04X ", devb & 0x0000FFFF);
+	}
+        
+        if (devd & 0x00010000) {
+		printf("Device D Id %04X ", devb & 0x0000FFFF);
+	}
+         
+	if ( !(deva & 0x00010000) && !(devb & 0x00010000)  && !(devc & 0x00010000)  && !(devd & 0x00010000) )
+	{
+		printf("No devices found!");
+	}
+
+	printf("\n");
+}
diff --git a/board/picochip/hdp203/law.c b/board/picochip/hdp203/law.c
new file mode 100644
index 0000000..bfb9e26
--- /dev/null
+++ b/board/picochip/hdp203/law.c
@@ -0,0 +1,77 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright 2008 Freescale Semiconductor, Inc.
+ *
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/fsl_law.h>
+#include <asm/mmu.h>
+
+/*
+ * LAW(Local Access Window) configuration:
+ *
+ * BAR0    - DDR @ 0x00000000, 256M
+ * BAR1    - PCI @ 0x40000000, 1G
+ * BAR2    - Local Bus (Daughtercard) @ 0xB0000000, 256M
+ * BAR3    - Local Bus (Pico + CPLD + Flash) @ 0xC0000000, 1G
+ *
+ * Notes:
+ *    CCSRBAR and L2-as-SRAM don't need a configured Local Access Window.
+ *    If flash is 8M at default position (last 8M), no LAW needed.
+ */
+
+/* IMPORTANT: LAWBAR0 is reserved (for things we don't do on this target), 
+ * and the loader knows this.  The first loaded register is LAWBAR1.
+ */
+
+/* DDR mapping.
+ *
+ * We must not enable the DDR LAW until the DDR controller has been 
+ * initialised (otherwise the debugger falls over...)
+ * The enable is set in spd_sdram or fixed_sdram depending on config
+ */
+
+struct law_entry law_table[] = {
+#ifndef CONFIG_SPD_EEPROM
+	/* DDR mapping.
+         *
+         * We must not enable the DDR LAW until the DDR controller has been 
+         * initialised (otherwise the debugger falls over...)
+         * The enable is set in spd_sdram or fixed_sdram depending on config
+         */
+        SET_LAW_ENTRY(1, CFG_DDR_SDRAM_BASE, LAW_SIZE_256M, LAW_TRGT_IF_DDR),
+#endif
+	/* PCI mapping - for Crypto chip */
+        SET_LAW_ENTRY(2, CFG_PCI1_MEM_BASE, LAW_SIZE_256M, LAW_TRGT_IF_PCI),
+	SET_LAW_ENTRY(3, CFG_PCI1_IO_BASE, LAW_SIZE_256M, LAW_TRGT_IF_PCI),
+
+	/* Local bus mapping for ATM daughtercard */
+        SET_LAW_ENTRY(4, CFG_DCARD_MEM_BASE, LAW_SIZE_256M, LAW_TRGT_IF_LBC),
+	
+        /* Main IO mapping, including flash */
+        SET_LAW_ENTRY(5, CFG_PFIFO_MEM_BASE, LAWAR_SIZE_1G, LAW_TRGT_IF_LBC),
+};
+
+int num_law_entries = ARRAY_SIZE(law_table);
diff --git a/board/picochip/hdp203/tlb.c b/board/picochip/hdp203/tlb.c
new file mode 100644
index 0000000..24a60e3
--- /dev/null
+++ b/board/picochip/hdp203/tlb.c
@@ -0,0 +1,133 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright 2008 Freescale Semiconductor, Inc.
+ *
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+
+struct fsl_e_tlb_entry tlb_table[] = {
+	/*
+	 * TLB0		16K	Cacheable, non-guarded
+	 * 			Based at CFG_INIT_RAM_ADDR
+	 *
+	 * Use four 4K TLB0 entries.  These entries must be cacheable
+	 * as they provide the bootstrap memory before the memory
+	 * controler and real memory have been configured.
+	 */
+	SET_TLB_ENTRY(0, CFG_INIT_RAM_ADDR, CFG_INIT_RAM_ADDR,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CFG_INIT_RAM_ADDR + 4 * 1024 , CFG_INIT_RAM_ADDR + 4 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CFG_INIT_RAM_ADDR + 8 * 1024 , CFG_INIT_RAM_ADDR + 8 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CFG_INIT_RAM_ADDR + 12 * 1024 , CFG_INIT_RAM_ADDR + 12 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+
+	/*
+	 * TLB1,0:	256M	Non-cacheable, guarded
+	 * 0xF0000000	256M	FLASH (We only have 32M..128M, but map more)
+	 * Out of reset this entry is only 4K.
+	 */
+	SET_TLB_ENTRY(1, (CFG_FLASH_BASE & 0xF0000000), (CFG_FLASH_BASE & 0xF0000000),
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 0, BOOKE_PAGESZ_256M, 1),
+
+	/*
+	 * TLB1,1:	256M	Non-cacheable, guarded
+	 * 0xE0000000	256M	CPLD
+	 */
+	SET_TLB_ENTRY(1, CFG_CPLD_MEM_BASE, CFG_CPLD_MEM_BASE,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 1, BOOKE_PAGESZ_256M, 1),
+
+	/*
+	 * TLB1,2:	256M	Non-cacheable, guarded
+	 * 0xD0000000	256M	PicoChip Registers
+	 */
+	SET_TLB_ENTRY(1, CFG_PREG_MEM_BASE, CFG_PREG_MEM_BASE,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 2, BOOKE_PAGESZ_256M, 1),
+
+	/*
+	 * TLB1,3:	256M	Non-cacheable, guarded
+	 * 0xC0000000	256M	PicoChip FIFOs
+	 */
+	SET_TLB_ENTRY(1, CFG_PFIFO_MEM_BASE, CFG_PFIFO_MEM_BASE,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 3, BOOKE_PAGESZ_256M, 1),
+
+	/*
+	 * TLB1,4:	256M	Non-cacheable, guarded
+	 * 0xB0000000	256M	Daughtercard (ATM)
+	 */
+	SET_TLB_ENTRY(1, CFG_DCARD_MEM_BASE, CFG_DCARD_MEM_BASE,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 4, BOOKE_PAGESZ_256M, 1),
+
+	/*
+	 * TLB1,5:	64M	Non-cacheable, guarded
+	 * 0x8000_0000  1M      CCSRBAR
+	 */
+	SET_TLB_ENTRY(1, CFG_CCSRBAR, CFG_CCSRBAR,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 5, BOOKE_PAGESZ_64M, 1),
+
+        /*
+         * TLB1,6:      256M    Non-cacheable, guarded
+         * 0x40000000   256M    PCI (Crypto processor)
+         */
+	SET_TLB_ENTRY(1, CFG_PCI1_MEM_BASE, CFG_PCI1_MEM_BASE,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 6, BOOKE_PAGESZ_256M, 1),
+        
+        /*
+         * TLB1,7:      256M    Non-cacheable, guarded
+         * 0x40000000   256M    PCI (Crypto processor) - IO area
+         */
+	SET_TLB_ENTRY(1, CFG_PCI1_IO_BASE, CFG_PCI1_IO_BASE,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 6, BOOKE_PAGESZ_256M, 1),                      
+
+#if !defined(CONFIG_SPD_EEPROM)
+	/*
+	 * TLB1,8:	256M	DDR
+	 * 0x00000000	256M	DDR System memory
+	 * Without SPD EEPROM configured DDR, this must be setup manually.
+	 * Make sure the TLB count at the top of this table is correct.
+	 * Likely it needs to be increased by two for these entries.
+	 */
+
+	SET_TLB_ENTRY(1, CFG_DDR_SDRAM_BASE, CFG_DDR_SDRAM_BASE,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 8, BOOKE_PAGESZ_256M, 1),
+#endif
+};
+
+int num_tlb_entries = ARRAY_SIZE(tlb_table);
diff --git a/board/picochip/hdp203/u-boot.lds b/board/picochip/hdp203/u-boot.lds
new file mode 100644
index 0000000..2e4e813
--- /dev/null
+++ b/board/picochip/hdp203/u-boot.lds
@@ -0,0 +1,156 @@
+/*
+ * $picoChipHeaderSubst$
+ *
+ * (C) Copyright 2002,2003,Motorola,Inc.
+ * Xianghua Xiao, X.Xiao@motorola.com.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(powerpc)
+SEARCH_DIR(/lib); SEARCH_DIR(/usr/lib); SEARCH_DIR(/usr/local/lib); SEARCH_DIR(/usr/local/powerpc-any-elf/lib);
+/* Do we need any of these for elf?
+   __DYNAMIC = 0;    */
+SECTIONS
+{
+  .resetvec 0xFFFFFFFC :
+  {
+    *(.resetvec)
+  } = 0xffff
+
+  .bootpg 0xFFFFF000 :
+  {
+    cpu/mpc85xx/start.o	(.bootpg)
+  } = 0xffff
+
+  /* Read-only sections, merged into text segment: */
+  . = + SIZEOF_HEADERS;
+  .interp : { *(.interp) }
+  .hash          : { *(.hash)		}
+  .dynsym        : { *(.dynsym)		}
+  .dynstr        : { *(.dynstr)		}
+  .rel.text      : { *(.rel.text)		}
+  .rela.text     : { *(.rela.text) 	}
+  .rel.data      : { *(.rel.data)		}
+  .rela.data     : { *(.rela.data) 	}
+  .rel.rodata    : { *(.rel.rodata) 	}
+  .rela.rodata   : { *(.rela.rodata) 	}
+  .rel.got       : { *(.rel.got)		}
+  .rela.got      : { *(.rela.got)		}
+  .rel.ctors     : { *(.rel.ctors)	}
+  .rela.ctors    : { *(.rela.ctors)	}
+  .rel.dtors     : { *(.rel.dtors)	}
+  .rela.dtors    : { *(.rela.dtors)	}
+  .rel.bss       : { *(.rel.bss)		}
+  .rela.bss      : { *(.rela.bss)		}
+  .rel.plt       : { *(.rel.plt)		}
+  .rela.plt      : { *(.rela.plt)		}
+  .init          : { *(.init)	}
+  .plt : { *(.plt) }
+  .text      :
+  {
+    cpu/mpc85xx/start.o	(.text)
+    cpu/mpc85xx/traps.o (.text)
+    cpu/mpc85xx/interrupts.o (.text)
+    cpu/mpc85xx/cpu_init.o (.text)
+    cpu/mpc85xx/cpu.o (.text)
+    cpu/mpc85xx/speed.o (.text)
+    cpu/mpc85xx/pci.o (.text)
+    common/dlmalloc.o (.text)
+    lib_generic/crc32.o (.text)
+    lib_ppc/extable.o (.text)
+    lib_generic/zlib.o (.text)
+    *(.text)
+    *(.fixup)
+    *(.got1)
+   }
+    _etext = .;
+    PROVIDE (etext = .);
+    .rodata    :
+   {
+    *(.rodata)
+    *(.rodata1)
+    *(.rodata.str1.4)
+    *(.eh_frame)
+
+    /* Force section to end on a word boundary, otherwise we can
+     * get S-Record files we can't program (the Flash is not byte
+     * programmable). 
+     */
+    . = ALIGN(4);
+  }
+  .fini      : { *(.fini)    } =0
+  .ctors     : { *(.ctors)   }
+  .dtors     : { *(.dtors)   }
+
+  /* Read-write section, merged into data segment: */
+  . = (. + 0x00FF) & 0xFFFFFF00;
+  _erotext = .;
+  PROVIDE (erotext = .);
+  .reloc   :
+  {
+    *(.got)
+    _GOT2_TABLE_ = .;
+    *(.got2)
+    _FIXUP_TABLE_ = .;
+    *(.fixup)
+  }
+  __got2_entries = (_FIXUP_TABLE_ - _GOT2_TABLE_) >> 2;
+  __fixup_entries = (. - _FIXUP_TABLE_) >> 2;
+
+  .data    :
+  {
+    *(.data)
+    *(.data1)
+    *(.sdata)
+    *(.sdata2)
+    *(.dynamic)
+    CONSTRUCTORS
+  }
+  _edata  =  .;
+  PROVIDE (edata = .);
+
+  . = .;
+  __u_boot_cmd_start = .;
+  .u_boot_cmd : { *(.u_boot_cmd) }
+  __u_boot_cmd_end = .;
+
+  . = .;
+  __start___ex_table = .;
+  __ex_table : { *(__ex_table) }
+  __stop___ex_table = .;
+
+  . = ALIGN(256);
+  __init_begin = .;
+  .text.init : { *(.text.init) }
+  .data.init : { *(.data.init) }
+  . = ALIGN(256);
+  __init_end = .;
+
+  __bss_start = .;
+  .bss       :
+  {
+   *(.sbss) *(.scommon)
+   *(.dynbss)
+   *(.bss)
+   *(COMMON)
+  }
+  _end = . ;
+  PROVIDE (end = .);
+}
diff --git a/board/picochip/pc7302/Makefile b/board/picochip/pc7302/Makefile
new file mode 100644
index 0000000..730ef3f
--- /dev/null
+++ b/board/picochip/pc7302/Makefile
@@ -0,0 +1,41 @@
+#/*****************************************************************************
+# * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+# *****************************************************************************/
+
+#/*!
+#* \file Makefile
+#* \brief Used during the build process.
+#*
+#* Copyright (c) 2006-2009 picoChip Designs Ltd
+#*
+#* This program is free software; you can redistribute it and/or modify
+#* it under the terms of the GNU General Public License version 2 as
+#* published by the Free Software Foundation.
+#*
+#* All enquiries to support@picochip.com
+#*/
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= pc7302.o mt29f2g08aadwp.o
+SOBJS	:= lowlevel_init.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $^
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff --git a/board/picochip/pc7302/config.mk b/board/picochip/pc7302/config.mk
new file mode 100644
index 0000000..62886b7
--- /dev/null
+++ b/board/picochip/pc7302/config.mk
@@ -0,0 +1,47 @@
+#/*****************************************************************************
+# * $picoChipHeaderSubst$
+# *****************************************************************************/
+
+#/*!
+#* \file config.mk
+#* \brief Used during the build process.
+#*
+#* Copyright (c) 2006-2009 picoChip Designs Ltd
+#*
+#* This program is free software; you can redistribute it and/or modify
+#* it under the terms of the GNU General Public License version 2 as
+#* published by the Free Software Foundation.
+#*
+#* All enquiries to support@picochip.com
+#*/
+
+# The PC7203 U-Boot image should be re-located to address...
+TEXT_BASE = 0x06000000
+
+ifdef BSP_DIR
+include $(BSP_DIR)/config
+PLATFORM_CPPFLAGS += -DPICOCHIP_PLATFORM_VERSION=\"$(RELEASE_VERSION)\"
+endif
+
+ifeq ($(PC7302_RUN_FROM_RAM), Y)
+PLATFORM_CPPFLAGS += -DCONFIG_RUN_FROM_RAM
+endif
+
+#/* Include support / commands for NAND Flash
+# *
+# * Note: Please read the comments in file
+# *       board/picochip/pc7302/mt29f2g08aadwp.c about gpio pins used
+# *       and PC302 booting modes before defining CONFIG_CMD_NAND
+# */
+ifeq ($(PC7302_NAND_SUPPORT), Y)
+PLATFORM_CPPFLAGS += -DCONFIG_CMD_NAND
+endif
+
+ifeq ($(PC7302_UBIFS), Y)
+PLATFORM_CPPFLAGS += -DPICO_USE_UBIFS
+endif
+
+ifeq ($(PC7302_THUMB), Y)
+PLATFORM_CPPFLAGS += -DBUILD_FOR_THUMB
+
+endif
diff --git a/board/picochip/pc7302/lowlevel_init.S b/board/picochip/pc7302/lowlevel_init.S
new file mode 100644
index 0000000..1078a01
--- /dev/null
+++ b/board/picochip/pc7302/lowlevel_init.S
@@ -0,0 +1,383 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file lowlevel_init.S
+* \brief Various low level setup functions.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/* Includes ---------------------------------------------------------------- */
+#include <config.h>
+#include <asm/arch/pc302.h>
+#include <asm/arch/mem_arm.h>
+#include <asm/arch/mem_shd.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/pa.h>
+#include <asm/arch/axi2cfg.h>
+
+/* Macros ------------------------------------------------------------------ */
+/* This gives us a peripheral bus base address of 0x80000000
+   and a memory region size of 4Mbytes */
+#define PERIPHERAL_BUS_SETUP        0x8000000D
+
+#define ASSERT_BOOT_ERROR_PIN       0
+#define NEGATE_BOOT_ERROR_PIN       1
+#define BOOT_ERROR_PIN_IS_OUTPUT    1
+
+/* Prototypes--------------------------------------------------------------- */
+
+/* Macros ------------------------------------------------------------------ */
+
+/*****************************************************************************
+ *
+ * configWriteLoadFile
+ *
+ *****************************************************************************/
+.macro  configWriteLoadFile Reg0, Reg1, Reg2, Reg3, Reg4, lfbase, lfwords
+
+        LDR     \Reg0,=\lfbase
+
+        /* We are running in Flash at this point therefore we
+           must 'noodle' with the linker created address
+           for the 'lfbase' address */
+        LDR     \Reg4,=TEXT_BASE
+        EOR     \Reg0, \Reg0, \Reg4
+
+        LDR     \Reg1,=PC302_AXI2CFG_BASE
+        LDR     \Reg2,=\lfwords
+0:
+        LDR     \Reg3, [\Reg0],#0x4
+        STR     \Reg3, [\Reg1,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
+        SUBS    \Reg2, \Reg2, #1
+        BNE     0b
+.endm
+
+/*****************************************************************************
+ *
+ * configRead
+ *
+ *****************************************************************************/
+.macro  configRead Reg0, Reg1, Reg2, aeid, addr
+
+        LDR     \Reg0,=PC302_AXI2CFG_BASE
+
+        /* aeid */
+        LDR     \Reg1,=\aeid
+        ORR     \Reg1,\Reg1,#PA_CONFIG_AEID
+        STR     \Reg1, [\Reg0,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
+
+        /* addr */
+        LDR     \Reg1,=\addr
+        ORR     \Reg1,\Reg1,#PA_CONFIG_ADDR
+        STR     \Reg1, [\Reg0,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
+
+        /* data */
+        MOV     \Reg1,#PA_CONFIG_READ
+        STR     \Reg1, [\Reg0,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
+        MOV     \Reg2,#0x20
+
+        /* read */
+0:
+        LDR     \Reg1, [\Reg0,#AXI2CFG_CONFIG_READ_REG_OFFSET]
+        TST     \Reg1, #(PA_CONFIG_VALID | PA_CONFIG_FAIL)
+        BNE     1f
+        SUBS    \Reg2,\Reg2,#1
+        BNE     0b
+        MOV     \Reg1, #PA_CONFIG_TIMEOUT
+1:
+        MOV     \Reg0, \Reg1
+
+.endm
+
+/* Functions --------------------------------------------------------------- */
+
+/*****************************************************************************
+ *
+ * lowlevel_init
+ *
+ * Description: Perform some low level PC302 initialisation
+ *
+ *****************************************************************************/
+ .global lowlevel_init
+
+ lowlevel_init:
+
+        /* Preserve link register across call */
+        mov     r11,lr
+
+        /* Setup the Periheral Port Memory Remap Register */
+        LDR     r0, =PERIPHERAL_BUS_SETUP
+        MCR     p15, 0, r0, c15, c2, 4
+
+#ifdef CONFIG_PC302_SIMULATION
+        bl      register_initialisation
+#endif
+
+        /* Initialise the boot error pin */
+        bl      initialiseBootErrorPin
+
+        /* Setup the ARM memory interface */
+        bl      memif_arm_init
+
+        /* Set up the Shared memory interface */
+        bl      memif_shared_init
+
+        /* Restore link register */
+        mov     lr, r11
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * memif_arm_init
+ *
+ * Description: Initialise the ARM Memory Controller
+ *
+ *****************************************************************************/
+memif_arm_init:
+
+        LDR     r3, =PC302_MEMIF_BASE
+
+        /* ;; =MEMIF_ARM_DRAM_INIT_PARAM_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_DRAM_INIT_PARAM_OFFSET]
+        BIC     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_MSK << MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_IDX)
+        ORR     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_VAL << MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_IDX)
+        BIC     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_MSK << MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_IDX)
+        ORR     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_VAL << MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_IDX)
+        BIC     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_MSK << MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_IDX)
+        ORR     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_VAL << MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_IDX)
+        STR     r4, [r3, #MEMIF_ARM_DRAM_INIT_PARAM_OFFSET]
+
+        /* ;; =MEMIF_ARM_ADDR_MAP_0_OFFSET */
+        LDR     r4, =MEMIF_ARM_ADDR_MAP_0_VAL_1Gbx16
+        STR     r4, [r3, #MEMIF_ARM_ADDR_MAP_0_OFFSET]
+
+        /* ;; =MEMIF_ARM_ADDR_MAP_1_OFFSET */
+        LDR     r4, =MEMIF_ARM_ADDR_MAP_1_VAL_1Gbx16
+        STR     r4, [r3, #MEMIF_ARM_ADDR_MAP_1_OFFSET]
+
+        /* ;; =MEMIF_ARM_ADDR_MAP_2_OFFSET */
+        LDR     r4, =MEMIF_ARM_ADDR_MAP_2_VAL_1Gbx16
+        STR     r4, [r3, #MEMIF_ARM_ADDR_MAP_2_OFFSET]
+
+        /* ;; =MEMIF_ARM_DRAM_PARAM_2_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_DRAM_PARAM_2_OFFSET]
+        AND     r4, r4, #0xFFFFFFF0
+        ORR     r4, r4, #0x00000004 ; wl = cl - 2
+        STR     r4, [r3, #MEMIF_ARM_DRAM_PARAM_2_OFFSET]
+
+        /* ;; =MEMIF_ARM_DRAM_BL_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_DRAM_BL_OFFSET]
+        BIC     r4, r4, #0x00000001 //; bl = 4
+        STR     r4, [r3, #MEMIF_ARM_DRAM_BL_OFFSET]
+
+        /* ;;  =MEMIF_ARM_DRAM_EMR_MR_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_DRAM_EMR_MR_OFFSET]
+        AND     r4, r4, #0xFFFFFF88
+        ORR     r4, r4, #0x00000002 //; bl = 4
+        ORR     r4, r4, #0x00000060 //; cl = 6
+        ORR     r4, r4, #0x04000000 //; dqs# = 0
+        STR     r4, [r3, #MEMIF_ARM_DRAM_EMR_MR_OFFSET]
+
+        /* ;;  =MEMIF_ARM_PHY_CMD_RDC_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_PHY_CMD_RDC_OFFSET]
+        AND     r4, r4, #0xFFFFFF00
+        ORR     r4, r4, #0x00000050 //;  phy wl
+        ORR     r4, r4, #0x00000006 //;  phy rl
+        AND     r4, r4, #0xFFFFFCFF
+        ORR     r4, r4, #0x00000300 //;  rdc_we_to_re_delay = 3 clks
+        AND     r4, r4, #0xFFFEFFFF
+        ORR     r4, r4, #0x00010000 //;  use_fixed_re = 1
+        STR     r4, [r3, #MEMIF_ARM_PHY_CMD_RDC_OFFSET]
+
+        /* ;; =MEMIF_ARM_PHY_SLV_DLL_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_PHY_SLV_DLL_OFFSET]
+        AND     r4, r4, #0x0
+        ORR     r4, r4, #0x30000000 //;  dll rd_slave1 ratio
+        ORR     r4, r4, #0x00300000 //;  dll rd_slave0 ratio
+        ORR     r4, r4, #0x00000040 //;  dll wr_slave ratio
+        STR     r4, [r3, #MEMIF_ARM_PHY_SLV_DLL_OFFSET]
+
+        /* ;; =MEMIF_ARM_DRAM_ODT_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_DRAM_ODT_OFFSET]
+        BIC     r4, r4, #0x00000001 //; disable dram odt during reads
+        STR     r4, [r3,#MEMIF_ARM_DRAM_ODT_OFFSET]
+
+        /* ;; =MEMIF_ARM_ODT_CTRL_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_ODT_CTRL_OFFSET]
+        AND     r4, r4, #0xFFFFFF00
+        AND     r4, r4, #0xFFFF00FF
+        ORR     r4, r4, #0x0010 //; wr_odt_delay, cl-5
+        ORR     r4, r4, #0x3000 //; wr_odt_hold, 4 cycles required
+        STR     r4, [r3, #MEMIF_ARM_ODT_CTRL_OFFSET]
+
+        /* ;; =MEMIF_ARM_PHY_LOCAL_ODT_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_PHY_LOCAL_ODT_OFFSET]
+        AND     r4, r4, #0xFFFFFFC0
+        ORR     r4, r4, #0x0001 //; rd_local_odt = 75 ohm
+                                //; wr_local_odt = off
+                                //; idle_local_odt = off
+        STR     r4, [r3, #MEMIF_ARM_PHY_LOCAL_ODT_OFFSET]
+
+        /* ;; =MEMIF_ARM_PHY_LOCAL_DRV_STRENGTH_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_PHY_LOCAL_DRV_STRENGTH_OFFSET]
+        ORR     r4, r4, #0x0010 //; fifo_we_in odt = 75 ohm
+        ORR     r4, r4, #0x000F //; All control signals half drive strength
+        STR     r4, [r3, #MEMIF_ARM_GP2_OFFSET]
+
+        /* ;; =MEMIF_ARM_INDIRECT_RW_CMD_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_INDIRECT_RW_CMD_OFFSET]
+        ORR     r4, r4, #0x1  //; de-assert soft reset
+        STR     r4, [r3, #MEMIF_ARM_INDIRECT_RW_CMD_OFFSET]
+
+/* Check to see if the mem-if ARM is ready yet? */
+memif_arm_init_poll:
+        LDR     r4, [r3, #MEMIF_ARM_CTRL_MODE_OFFSET]
+        AND     r4, r4, #0x3
+        CMP     r4, #0x1
+        BNE     memif_arm_init_poll
+
+        mov	pc, lr		/* Return to my caller */
+
+/*****************************************************************************
+ *
+ * memif_shared_init
+ *
+ * Description: Initialise the Shared Memory Controller
+ *
+ *****************************************************************************/
+
+/* Data to set-up the memif-Shared Shared, this is effectively a load file */
+
+memif_shared_init_data:
+        .word   LF_PA_AEID_MEMIF, LF_CBFM_SLEEPREG_ADDR, PA_WRITE_ZERO_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_ARB_G0_S0_S1, ADDR_SDRAM_ARB_G0_S0_S1_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_ARB_G0_S2_S3, ADDR_SDRAM_ARB_G0_S2_S3_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_ARB_G1_S0_S1, ADDR_SDRAM_ARB_G1_S0_S1_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_ARB_G1_S2_S3, ADDR_SDRAM_ARB_G1_S2_S3_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_VALID_GROUPS, ADDR_SDRAM_VALID_GROUPS_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_SETUP, ADDR_SDRAM_SETUP_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_REFRESH, ADDR_SDRAM_REFRESH_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_ODT_SETUP, ADDR_SDRAM_ODT_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_AXI_CONFIG, ADDR_SDRAM_AXI_CONFIG_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_MRS, ADDR_SDRAM_MRS_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_EMRS, ADDR_SDRAM_EMRS_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_PHY_CONFIG, ADDR_PHY_CONFIG_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_PHY_LOCAL_ODT_CONFIG, ADDR_PHY_LOCAL_ODT_CONFIG_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_PHY_RD_SLAVE, ADDR_PHY_RD_SLAVE_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_PHY_WR_SLAVE, ADDR_PHY_WR_SLAVE_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_PHY_IO_CELL_CONFIG, ADDR_PHY_IO_CELL_CONFIG_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_CFG_DONE, ADDR_SDRAM_CFG_DONE_DATA
+
+memif_shared_init:
+
+        /* Write the intialisation data into the picoArray */
+        configWriteLoadFile r0, r1, r2, r3, r4, memif_shared_init_data, 54
+
+/* Check to see if the mem-if Shared is ready yet? */
+memif_shared_init_poll:
+
+        configRead r0, r1, r2, PA_AEID_MEMIF, ADDR_SDRAM_STATUS
+
+        /* Has it timed out? */
+        TST     r0, #PA_CONFIG_TIMEOUT
+        BNE     memif_shared_init_poll
+
+        /* Has it configured? */
+        TST     r0, #0x01
+        BEQ     memif_shared_init_poll
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * register_initialisation
+ *
+ * Description: Initialise some CPU registers
+ *
+ * Note:
+ * Used to prevent X propagation if running this code in a simulation
+ *
+ *****************************************************************************/
+register_initialisation:
+
+        mov     r0, #0x00000000
+        mov     r1, #0x00000000
+        mov     r2, #0x00000000
+        mov     r3, #0x00000000
+        mov     r4, #0x00000000
+        mov     r5, #0x00000000
+        mov     r6, #0x00000000
+        mov     r7, #0x00000000
+        mov     r8, #0x00000000
+        mov     r9, #0x00000000
+        mov     r10,#0x00000000
+
+        /* Don't noodle with r11 (fp)
+                             r12 (ip)
+                             r13 (sp)
+                             r14 (lr)
+                             r15 (pc)
+           as this would cause big probs ! */
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * initialiseBootErrorPin
+ *
+ * Initialise the GPIO that is used as the Boot Error pin
+ *
+ *****************************************************************************/
+ initialiseBootErrorPin:
+
+        /* Get base address of the arm gpio block */
+        ldr     r0,=PC302_GPIO_BASE
+
+        /* Negate the Boot error pin (in the data register) */
+        ldr     r1,[r0, #GPIO_SW_PORT_C_DR_REG_OFFSET]
+        orr     r1,r1,#NEGATE_BOOT_ERROR_PIN
+        str     r1,[r0, #GPIO_SW_PORT_C_DR_REG_OFFSET]
+
+        /* Set up Boot Error pin to be an output */
+        ldr     r1,[r0, #GPIO_SW_PORT_C_DDR_REG_OFFSET]
+        orr     r1,r1,#BOOT_ERROR_PIN_IS_OUTPUT
+        str     r1,[r0, #GPIO_SW_PORT_C_DDR_REG_OFFSET]
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * assertBootError
+ *
+ * Assert the Boot Error pin. On the SVB302 this is used to illuminate an LED
+ *
+ *****************************************************************************/
+ .global assertBootError
+
+ assertBootError:
+
+        /* Get base address of the arm gpio block */
+        ldr     r0,=PC302_GPIO_BASE
+
+        /* Assert the Boot Error pin */
+        mov     r1, #ASSERT_BOOT_ERROR_PIN
+        str     r1,[r0, #GPIO_SW_PORT_C_DR_REG_OFFSET]
+
+        /* Return to my caller */
+        mov	pc, lr
+
+       .end
diff --git a/board/picochip/pc7302/mt29f2g08aadwp.c b/board/picochip/pc7302/mt29f2g08aadwp.c
new file mode 100644
index 0000000..8e1b675
--- /dev/null
+++ b/board/picochip/pc7302/mt29f2g08aadwp.c
@@ -0,0 +1,213 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file .mt29f2g08aadwp.c
+* \brief Support for the NAND Flash device fitted on PC7302 platform.
+*
+* Copyright (c) 2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+ 
+/*
+ * (C) Copyright 2009 SAGEM Communications
+ * (C) Copyright 2006 DENX Software Engineering
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+
+#ifdef CONFIG_CMD_NAND
+
+#include <asm/arch/pc302.h>
+#include <asm/arch/gpio.h>
+#include <nand.h>
+
+/* Macros ------------------------------------------------------------------ */
+
+/* Define which gpio bits are used to control the NAND Flash
+ *
+ * Note: These pin definitions mean that we can only use NAND
+ *       Flash if we are running U-Boot from RAM and have NOT booted
+ *       the device from parallel NOR Flash.
+ *
+ * Note: These GPIO bits are all ARM GPIO bits.
+ */
+#define CLE   GPIO_BIT_4
+#define ALE   GPIO_BIT_3
+#define NCE   GPIO_BIT_2
+#define READY GPIO_BIT_1
+
+/*!
+ * \brief Hardware specific access to control-lines
+ * \param mtd, pointer to the mtd_info structure
+ * \param dat, data to write to the device
+ * \param ctrl, control data to set up the transaction
+ *
+ */
+static void mt29f2g08aadwp_cmd_ctrl(struct mtd_info *mtd,
+				    int dat,
+				    unsigned int ctrl)
+{
+    struct nand_chip *this = mtd->priv;
+
+    unsigned int odr;
+
+    /* Read the data register for port A,
+       Note: This will return the state of the pins programmed
+             to be outputs.
+    */
+    odr = *(volatile unsigned int *)(PC302_GPIO_BASE +
+				     GPIO_SW_PORT_A_DR_REG_OFFSET) & 0xFF;
+
+    if (ctrl & NAND_CTRL_CHANGE)
+    {
+        if (ctrl & NAND_NCE)
+        {
+            /* Assert the chip select */
+            odr &= ~NCE;
+            *(volatile unsigned int *)(PC302_GPIO_BASE +
+				       GPIO_SW_PORT_A_DR_REG_OFFSET) = odr;
+
+	    if (ctrl & NAND_CLE)
+            {
+	        /* Assert CLE */
+                odr |= CLE;
+		*(volatile unsigned int *)(PC302_GPIO_BASE +
+					   GPIO_SW_PORT_A_DR_REG_OFFSET) = odr;
+            }
+    	    else
+	    {
+                /* Negate CLE */
+                odr &= ~CLE;
+		*(volatile unsigned int *)(PC302_GPIO_BASE +
+					   GPIO_SW_PORT_A_DR_REG_OFFSET) = odr;
+            }
+
+	    if (ctrl & NAND_ALE)
+	    {
+                /* Assert ALE */
+                odr |= ALE;
+		*(volatile unsigned int *)(PC302_GPIO_BASE +
+					   GPIO_SW_PORT_A_DR_REG_OFFSET) = odr;
+            }
+	    else
+            {
+		/* Negate ALE */
+                odr &= ~ALE;
+		*(volatile unsigned int *)(PC302_GPIO_BASE +
+					   GPIO_SW_PORT_A_DR_REG_OFFSET) = odr;
+            }
+        }
+        else
+        {
+	    /* Negate the chip select */
+            odr |= NCE;
+	    *(volatile unsigned int *)(PC302_GPIO_BASE +
+		     		       GPIO_SW_PORT_A_DR_REG_OFFSET) = odr;
+
+        }
+    }
+
+    /* If we have data to write, write it */
+    if (dat != NAND_CMD_NONE)
+    {
+	*(volatile unsigned char *)(this->IO_ADDR_W) = (unsigned char)dat;
+    }
+
+}
+
+/*!
+ * \brief Return the state of the NAND busy output
+ * \param mtd, pointer to the mtd_info structure
+ * \return 0 - nand busy
+ *         1 - nand ready
+ *
+ */
+static int mt29f2g08aadwp_dev_ready(struct mtd_info *mtd)
+{
+    unsigned int idr;
+
+    idr = *(volatile unsigned int *)(PC302_GPIO_BASE +
+			             GPIO_EXT_PORT_A_REG_OFFSET) & 0xFF;
+
+    return ((idr & READY) == READY)? 1: 0;
+}
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+int board_nand_init(struct nand_chip *nand)
+{
+    unsigned int ddr, dr;
+
+    /* Setup the gpio data direction register */
+    ddr = *(volatile unsigned int *)(PC302_GPIO_BASE +
+			             GPIO_SW_PORT_A_DDR_REG_OFFSET) & 0xFF;
+
+    /* The outputs */
+    ddr |= (CLE | ALE | NCE);
+
+    /* The inputs */
+    ddr &= ~READY;
+
+    *(volatile unsigned int *)(PC302_GPIO_BASE +
+	    		       GPIO_SW_PORT_A_DDR_REG_OFFSET) = ddr;
+
+    /* Setup a 'safe' initial value on the nand control pins */
+    dr = NCE;
+    dr &= ~(CLE | ALE);
+    *(volatile unsigned int *)(PC302_GPIO_BASE +
+		               GPIO_SW_PORT_A_DR_REG_OFFSET) = dr;
+
+    /* Populate some members of the nand structure */
+    nand->cmd_ctrl = mt29f2g08aadwp_cmd_ctrl;
+    nand->ecc.mode = NAND_ECC_SOFT;
+    nand->dev_ready = mt29f2g08aadwp_dev_ready;
+    nand->IO_ADDR_R = (void __iomem *)CONFIG_SYS_NAND_BASE;
+    nand->IO_ADDR_W = (void __iomem *)CONFIG_SYS_NAND_BASE;
+
+    return 0;
+}
+#endif /* CONFIG_CMD_NAND */
diff --git a/board/picochip/pc7302/pc7302.c b/board/picochip/pc7302/pc7302.c
new file mode 100644
index 0000000..a75d2b3
--- /dev/null
+++ b/board/picochip/pc7302/pc7302.c
@@ -0,0 +1,183 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file pc7302.c
+* \brief Various useful functions for use on a PC7302 Platform.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+#include <asm/arch/timer.h>
+#include <asm/arch/utilities.h>
+
+/* Macros ------------------------------------------------------------------ */
+/*!
+ * Flag used to control whether or not the Die ID is displayed at boot time
+ */
+//#define DISPLAY_DIE_ID          (1)
+
+/* Constants --------------------------------------------------------------- */
+DECLARE_GLOBAL_DATA_PTR;
+
+
+/* Prototypes--------------------------------------------------------------- */
+/*!
+ *
+ * Start timer #0 in free running mode
+ *
+ */
+static void pc302_timer_0_start(void);
+
+/* Functions --------------------------------------------------------------- */
+
+/*****************************************************************************
+ *
+ * show_boot_progress()
+ *
+ * Purpose: Indicate booting progress
+ *
+ * Note: see U-Boot README for a list of 'progress' values.
+ *
+ *****************************************************************************/
+#if defined(CONFIG_SHOW_BOOT_PROGRESS)
+void show_boot_progress(int progress)
+{
+	printf("Boot reached stage %d\n", progress);
+}
+#endif
+
+/*****************************************************************************
+ *
+ * board_init()
+ *
+ * Purpose: Hardware platform initialisation functions
+ *
+ * Returns: 0 - Success
+ *
+ *****************************************************************************/
+int board_init (void)
+{
+    /* adress of boot parameters */
+    gd->bd->bi_boot_params = 0x00000100;
+    gd->bd->bi_arch_number = MACH_TYPE_PC7302;
+    gd->flags = 0;
+
+    /* Enable the Instruction Cache */
+    icache_enable ();
+
+    /* Start a timer */
+    pc302_timer_0_start();
+
+    return 0;
+}
+
+/*****************************************************************************
+ *
+ * checkboard()
+ *
+ * Purpose: Display some useful hardware platform information.
+ *
+ * Returns: 0 - Success
+ *
+ *****************************************************************************/
+int checkboard (void)
+{
+    unsigned int device_type, revision;
+    unsigned int die_id[4];
+
+    puts("Build: picoChip "PICOCHIP_PLATFORM" \n");
+
+    /* What device are we running on ? */
+    puts("Device: ");
+
+    device_type = pc302_read_device_id();       /* Read the device Id */
+    revision = pc302_read_device_revision();    /* Read the revision code */
+    pc302_read_die_id_number(&die_id[0]);       /* Read the die id */
+
+    switch (device_type)
+    {
+        case PC302_DEVICE_ID:
+        {
+            printf("PC302 Rev %04d\n", revision);
+            break;
+        }
+        case PC312_DEVICE_ID:
+        {
+            printf("PC312 Rev %04d\n", revision);
+            break;
+        }
+        default:
+        {
+            printf("Unknown !\n");
+        }
+    }
+
+#if defined (DISPLAY_DIE_ID)
+    /* Ouput the die_id */
+    printf("Die Id: ");
+    printf("0x%08x\n", die_id[0]);
+    printf("        0x%08x\n", die_id[1]);
+    printf("        0x%08x\n", die_id[2]);
+    printf("        0x%08x\n", die_id[3]);
+#endif
+
+    return 0;
+}
+
+/*****************************************************************************
+ *
+ * misc_init_r()
+ *
+ * Purpose: Miscellaneous platform dependent initialisations
+ *
+ * Returns: 0 - Success
+ *
+ *****************************************************************************/
+int misc_init_r (void)
+{
+    /* Not used right now, function template left here as a place holder */
+    return 0;
+}
+
+/*****************************************************************************
+ *
+ * dram_init()
+ *
+ * Purpose: Initialize the DDR SDRAM info in the board data structure
+ *
+ * Returns: 0 - Success
+ *
+ *****************************************************************************/
+int dram_init (void)
+{
+
+    gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+    gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+    return 0;
+}
+
+static void pc302_timer_0_start(void)
+{
+    /* Make sure timer #0 is disabled */
+    pc302_write_to_register((CFG_TIMERBASE + TIMERNCONTROLREGOFFSET(0)), 0);
+
+    /* Initialise the timer #0 to all 1's.  We do this  because we want to run
+       the timer in free running mode. */
+    pc302_write_to_register((CFG_TIMERBASE + TIMERNLOADCOUNTREGOFFSET(0)),
+                            0xFFFFFFFF);
+
+    /* Start timer #0 in free running mode */
+    pc302_write_to_register((CFG_TIMERBASE + TIMERNCONTROLREGOFFSET(0)),
+                            (TIMERINTERRUPTMASK | TIMERENABLE));
+}
diff --git a/board/picochip/pc7302/u-boot.lds b/board/picochip/pc7302/u-boot.lds
new file mode 100644
index 0000000..02c90dc
--- /dev/null
+++ b/board/picochip/pc7302/u-boot.lds
@@ -0,0 +1,45 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file u-boot.lds
+* \brief Used during the build process.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+	. = ALIGN(4);
+	.text	:
+	{
+		cpu/arm926ejs/start.o (.text)
+		*(.text)
+	}
+	.rodata : { *(.rodata) }
+	. = ALIGN(4);
+	.data : { *(.data) }
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff --git a/board/picochip/pc7802/Makefile b/board/picochip/pc7802/Makefile
new file mode 100644
index 0000000..c0e6925
--- /dev/null
+++ b/board/picochip/pc7802/Makefile
@@ -0,0 +1,37 @@
+#/*!
+#* \file Makefile
+#* \brief Used during the build process.
+#*
+#* Copyright (c) 2006-2009 picoChip Designs Ltd
+#*
+#* This program is free software; you can redistribute it and/or modify
+#* it under the terms of the GNU General Public License version 2 as
+#* published by the Free Software Foundation.
+#*
+#* All enquiries to support@picochip.com
+#*/
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= pc7802.o
+SOBJS	:= lowlevel_init.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $^
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff --git a/board/picochip/pc7802/config.mk b/board/picochip/pc7802/config.mk
new file mode 100644
index 0000000..a8cec10
--- /dev/null
+++ b/board/picochip/pc7802/config.mk
@@ -0,0 +1,27 @@
+#/*****************************************************************************
+# * $picoChipHeaderSubst$
+# *****************************************************************************/
+
+#/*!
+#* \file config.mk
+#* \brief Used during the build process.
+#*
+#* Copyright (c) 2006-2009 picoChip Designs Ltd
+#*
+#* This program is free software; you can redistribute it and/or modify
+#* it under the terms of the GNU General Public License version 2 as
+#* published by the Free Software Foundation.
+#*
+#* All enquiries to support@picochip.com
+#*/
+
+TEXT_BASE = 0x05000000
+
+ifdef BSP_DIR
+include $(BSP_DIR)/config
+PLATFORM_CPPFLAGS += -DPICOCHIP_PLATFORM_VERSION=\"$(RELEASE_VERSION)\"
+endif
+
+ifeq ($(PC7802_RUN_FROM_RAM), Y)
+PLATFORM_CPPFLAGS += -DCONFIG_RUN_FROM_RAM
+endif
diff --git a/board/picochip/pc7802/lowlevel_init.S b/board/picochip/pc7802/lowlevel_init.S
new file mode 100644
index 0000000..d0d772b
--- /dev/null
+++ b/board/picochip/pc7802/lowlevel_init.S
@@ -0,0 +1,321 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file lowlevel_init.S
+* \brief Various low level setup functions.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#include <config.h>
+#include <asm/arch/pc20x.h>
+#include <asm/arch/memif.h>
+#include <asm/arch/ebi.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/rap.h>
+#include <asm/arch/procif.h>
+
+/*****************************************************************************
+ *
+ * lowlevel_init
+ *
+ * Description: Perform some low level PC20x initialisation
+ *
+ *****************************************************************************/
+
+ .global lowlevel_init
+
+ lowlevel_init:
+
+        /* Preserve link register across call */
+        mov r11,lr
+
+#ifdef CONFIG_PC20X_SIMULATION
+        bl      register_initialisation
+#endif
+
+        /* Extinguish LEDS controlled by the ARM gpio */
+        bl      extinguishArmLeds
+
+        /* Setup the ebi memory interface (Flash Memory) */
+        bl      ebi_init
+
+        /* Setup the memory interface (DDR2 Memory) */
+        bl      memif_init
+
+        /* Restore link register */
+        mov     lr, r11
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * ebi_init
+ *
+ * Description: Initialise the External Bus Interface
+ *
+ *****************************************************************************/
+
+ebi_init:
+
+        mov	pc, lr		/* Return to my caller */
+
+/*****************************************************************************
+ *
+ * memif_init
+ *
+ * Description: Initialise the Memory Controller
+ *
+ * Note:
+ * Before using SDRAM, we must wait 200us for it to initialise, accesses
+ * will be held off until the initialisation process is complete.
+ *
+ *****************************************************************************/
+
+memif_init:
+
+/*****************************************************************************
+ Reset the MEMIF before continuing
+*****************************************************************************/
+        ldr     r0, =PC20X_PROCIF_BASE
+        ldr     r1, =ProcifIntGpioRegOffset
+        ldr     r2, =ProcifGpioMemifSofResetMask
+        orr     r0, r0, r1
+
+        ldr     r1, [r0]
+        orr     r1, r1, r2
+        str     r1, [r0]
+
+waitForMemIfResetToClear:
+        ldr     r1, [r0]
+        ands    r1, r1, r2
+        bne     waitForMemIfResetToClear
+
+/*****************************************************************************
+ Setup MEMIF base address
+*****************************************************************************/
+
+        ldr     r2, =PC20X_MEM_IF_BASE
+
+/*****************************************************************************
+ DLL Configuration
+*****************************************************************************/
+
+/* DLL #0 */
+        ldr     r3, =DLL0SlaveAdjustValue
+        ldr     r4, =DLL0SlaveAdjustRegOffset
+        orr     r4, r4, r2
+        strh    r3, [r4]
+
+/* DLL #1 */
+        ldr     r3, =DLL1SlaveAdjustValue
+        ldr     r4, =DLL1SlaveAdjustRegOffset
+        orr     r4, r4, r2
+        strh    r3, [r4]
+
+/* DLL #2 */
+        ldr     r3, =DLL2SlaveAdjustValue
+        ldr     r4, =DLL2SlaveAdjustRegOffset
+        orr     r4, r4, r2
+        strh    r3, [r4]
+
+/* DLL #3 */
+        ldr     r3, =DLL3SlaveAdjustValue
+        ldr     r4, =DLL3SlaveAdjustRegOffset
+        orr     r4, r4, r2
+        strh    r3, [r4]
+
+/* Initiate a DLL update */
+        ldr     r3, =DLLConfigUpdate
+        ldr     r4, =DLLConfigUpdateRegOffset
+        orr     r4, r4, r2
+        strh    r3, [r4]
+
+/* Wait until the DLL update has completed */
+
+waitForDLLUpdate:
+        ldrh    r3, [r4]
+        tst     r3, #DLLConfigUpdateInProgress
+        bne     waitForDLLUpdate
+
+/*****************************************************************************
+ SDRAM Arbitration
+*****************************************************************************/
+
+#ifndef CONFIG_PC20X_2_DDR_RAM_BANKS
+/* We want a 4 DDR Bank setup then */
+
+        mov     r3, #0x0000
+        strh    r3, [r2, #MemifSdramArbGroup0SlotAConfigRegOffset]
+        strh    r3, [r2, #MemifSdramArbGroup0SlotBConfigRegOffset]
+
+        mov     r3, #0x0400
+        orr     r3, r3, #0x0004
+        strh    r3, [r2, #MemifSdramArbGroup1SlotAConfigRegOffset]
+        strh    r3, [r2, #MemifSdramArbGroup1SlotBConfigRegOffset]
+
+        mov     r3, #0x0003
+        strh    r3, [r2, #MemifSdramArbValidGroupsConfigRegOffset]
+
+#else   /* We want a 2 DDR Bank setup then */
+
+        /* Group 0, Banks 0 & 1 -> ARM, Rd, Deterministic */
+        mov     r3, #0x0000
+        strh    r3, [r2, #MemifSdramArbGroup0SlotAConfigRegOffset]
+
+        /* Group 0, Banks 2 & 3 -> pA, Rd, Deterministic */
+        mov     r3, #0x0100
+        orr     r3, r3, #0x0001
+        strh    r3, [r2, #MemifSdramArbGroup0SlotBConfigRegOffset]
+
+        /* Group 1, Banks 0 & 1 -> ARM, Wr, Deterministic */
+        mov     r3, #0x0400
+        orr     r3, r3, #0x0004
+        strh    r3, [r2, #MemifSdramArbGroup1SlotAConfigRegOffset]
+
+        /* Group 1, Banks 2 & 3 -> pA, Wr Deterministic */
+        mov     r3, #0x0500
+        orr     r3, r3, #0x0005
+        strh    r3, [r2, #MemifSdramArbGroup1SlotBConfigRegOffset]
+
+        /* Valid Groups, 2 */
+        mov     r3, #0x0003
+        strh    r3, [r2, #MemifSdramArbValidGroupsConfigRegOffset]
+
+#endif
+
+/*****************************************************************************
+ SDRAM Setup
+*****************************************************************************/
+
+/* Set the SDRAM size and width */
+        mov     r3, #SdramSize13r10c
+        orr     r3, r3, #SdramWidth32
+        orr     r3, r3, #SdramRWGap4
+        orr     r3, r3, #SdramWRGap7
+        orr     r3, r3, #SdramOdt75Ohm
+        orr     r3, r3, #SdramCaptureDelay1Mclk
+        strh    r3, [r2,#MemifSdramSetupRegOffset]
+
+/* Set the refresh rate */
+        ldr     r3, =SdramRefreshCount
+        strh    r3, [r2, #MemifSdramRefreshRateRegOffset]
+
+/* Set the device mode register */
+        mov     r3, #0x0400
+        orr     r3, r3, #0x0042
+        strh    r3, [r2, #MemifSdramMrsRegOffset]
+
+/* Set the extended mode register */
+        ldr     r3, =SdramEmrsSetup
+        strh    r3, [r2, #MemifSdramErsRegOffset]
+
+/*****************************************************************************
+ Configuration complete, start the mem-if
+*****************************************************************************/
+        mov     r3, #SdramSetupComplete
+        strh    r3, [r2, #MemifSdramSetupCompleteReg]
+        mov     r3, #SramSetupComplete
+        strh    r3, [r2, #MemifSramSetupCompleteReg]
+
+        mov	pc, lr		/* Return to my caller */
+
+/*****************************************************************************
+ *
+ * ddr2_dummy_access
+ *
+ * Description: Perform a 'dummy' write to and read back from the DDR2 SDRAM
+ *
+ *****************************************************************************/
+.global ddr2_dummy_access
+
+ ddr2_dummy_access:
+        ldr     r0, =PHYS_SDRAM_1
+        mov     r1, #0x00000000
+        str     r1, [r0]    /* perform a 'dummy' write */
+
+        ldr     r2, [r0]    /* perform a 'dummy' read */
+        cmp     r1, r2      /* ignore the result */
+
+        mov	pc, lr      /* Return to my caller */
+
+/*****************************************************************************
+ *
+ * register_initialisation
+ *
+ * Description: Initialise some CPU registers
+ *
+ * Note:
+ * Used to prevent X propagation if running this code in a simulation
+ *
+ *****************************************************************************/
+
+register_initialisation:
+
+        mov     r0, #0x00000000
+        mov     r1, #0x00000000
+        mov     r2, #0x00000000
+        mov     r3, #0x00000000
+        mov     r4, #0x00000000
+        mov     r5, #0x00000000
+        mov     r6, #0x00000000
+        mov     r7, #0x00000000
+        mov     r8, #0x00000000
+        mov     r9, #0x00000000
+        mov     r10,#0x00000000
+
+        /* Don't noodle with r11 (fp)
+                             r12 (ip)
+                             r13 (sp)
+                             r14 (lr)
+                             r15 (pc)
+           as this would cause big probs ! */
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * assertBootError
+ *
+ * Illuminate LED15 on the picoChip CPE20x hardware platform
+ *
+ *****************************************************************************/
+ .global assertBootError
+
+ assertBootError:
+
+        /* On the PC7802 Platform we do not have a Boot Error LED */
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * extinguishArmLeds
+ *
+ * Extinguish both ARM controlled LEDS on the CPE20x Platform
+ *
+ *****************************************************************************/
+
+.global extinguishArmLeds
+
+extinguishArmLeds:
+
+        /* On the PC7802 Platform we do not have any directly 
+         * ARM controlled LEDs.
+         */
+
+        /* Return to my caller */
+        mov     pc, lr
+
+       .end
diff --git a/board/picochip/pc7802/pc7802.c b/board/picochip/pc7802/pc7802.c
new file mode 100644
index 0000000..553c93b
--- /dev/null
+++ b/board/picochip/pc7802/pc7802.c
@@ -0,0 +1,865 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file pc7802.c
+* \brief Various useful functions for use on a PC7802 Platform.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+#include <asm/arch/pc20x.h>
+#include <asm/arch/timer.h>
+#include <asm/arch/gpio.h>
+
+/* Constants --------------------------------------------------------------- */
+DECLARE_GLOBAL_DATA_PTR;
+
+/*!
+ * \brief SDGPIO identifiers for PC202 devices.
+ *
+ * This enum defines a list of (SD)GPIO sources that are available for
+ * use in PC202 devices.
+ */
+enum picoifGpioPinNum_PC202
+{
+    PC202_GPIO_PIN_INVAL = -1,  /*< Invalid pin configuration. */
+    PC202_GPIO_PIN_SDGPIO_0,    /* SDGPIO pin identifiers. */
+    PC202_GPIO_PIN_SDGPIO_1,
+    PC202_GPIO_PIN_SDGPIO_2,
+    PC202_GPIO_PIN_SDGPIO_3,
+    PC202_GPIO_PIN_SDGPIO_4,
+    PC202_GPIO_PIN_SDGPIO_5,
+    PC202_GPIO_PIN_SDGPIO_6,
+    PC202_GPIO_PIN_SDGPIO_7,
+    PC202_GPIO_PIN_SDGPIO_8,
+    PC202_GPIO_PIN_SDGPIO_9,
+    PC202_GPIO_PIN_SDGPIO_10,
+    PC202_GPIO_PIN_SDGPIO_11,
+    PC202_GPIO_PIN_SDGPIO_12,
+    PC202_GPIO_PIN_SDGPIO_13,
+    PC202_GPIO_PIN_SDGPIO_14,
+    PC202_GPIO_PIN_SDGPIO_15,
+    PC202_GPIO_PIN_SDGPIO_16,
+    PC202_GPIO_PIN_SDGPIO_17,
+    PC202_GPIO_PIN_SDGPIO_18,
+    PC202_GPIO_PIN_SDGPIO_19,
+    PC202_GPIO_PIN_SDGPIO_20,
+    PC202_GPIO_PIN_SDGPIO_21,
+    PC202_GPIO_PIN_SDGPIO_22,
+    PC202_GPIO_PIN_SDGPIO_23,
+    PC202_GPIO_PIN_SDGPIO_24,
+    PC202_GPIO_PIN_SDGPIO_25,
+    PC202_GPIO_PIN_SDGPIO_26,
+    PC202_GPIO_PIN_SDGPIO_27,
+    PC202_GPIO_PIN_SDGPIO_28,
+    PC202_GPIO_PIN_SDGPIO_29,
+    PC202_GPIO_PIN_SDGPIO_30,
+    PC202_GPIO_PIN_SDGPIO_31,
+    PICO_NUM_GPIOS,
+};
+
+/* Macros ------------------------------------------------------------------ */
+/* Configuration port write bit positions. */
+#define CAEID_BIT_MASK      ( 1 << 19 )     /*!< Bit 19 - AE ID signal. */
+#define CADDR_BIT_MASK      ( 1 << 18 )     /*!< Bit 18 - AE ADDR signal. */
+#define CREAD_BIT_MASK      ( 1 << 17 )     /*!< Bit 17 - READ data signal. */
+#define CWRITE_BIT_MASK     ( 1 << 16 )     /*!< Bit 16 - WRITE data signal. */
+
+#define RB_FAIL_MASK        ( 1 << 17 )     /*!< Bit 17 - readback failed. */
+#define RB_VALID_MASK       ( 1 << 16 )     /*!< Bit 16 - readback valid. */
+
+#define RETRIES             ( 10 )          /*!< The number of retries for a \
+                                             *   procif config read. */
+
+#define PROCIF_CONFIG_READ_REG_OFFSET       ( 0x78 )
+#define PROCIF_CONFIG_WRITE_REG_OFFSET      ( 0x7C )
+
+/** PC202 AHB2Pico CAEID. */
+#define PC202_AHB2PICO_CAEID                ( 0x0008 )
+
+/** The address of the sleep register in the AHB2Pico. */
+#define PC202_AHB2PICO_SLEEP_REG            ( 0xA060 )
+
+/** The AHB2PICO wake up command */
+#define PC202_AHB2PICO_WAKE_UP              ( 0 )
+
+/** The base address of SD-GPIO config registers in the AHB2Pico. */
+#define PC202_GPIO_SD_PIN_CONFIG_BASE       ( 0x9800 )
+
+/** The address of the LSB SD-GPIOs input value register in the AHB2Pico. */
+#define PC202_GPIO_SD_INPUT_VAL_REG_LOW     ( 0x9880 )
+
+/** The address of the MSB SD_GPIO input value register in the AHB2Pico. */
+#define PC202_GPIO_SD_INPUT_VAL_REG_HIGH    ( 0x9881 )
+
+/** The address of the LSB SD-GPIOs control value register in the AHB2Pico. */
+#define PC202_GPIO_SD_CONTROL_VAL_REG_LOW   ( 0x9882 )
+
+/** The address of the MSB SD_GPIO control value register in the AHB2Pico. */
+#define PC202_GPIO_SD_CONTROL_VAL_REG_HIGH  ( 0x9883 )
+
+/** The address of the LSB SD-GPIOs output value register in the AHB2Pico. */
+#define PC202_GPIO_SD_OUTPUT_VAL_REG_LOW    ( 0x9884 )
+
+/** The address of the MSB SD_GPIO output value register in the AHB2Pico. */
+#define PC202_GPIO_SD_OUTPUT_VAL_REG_HIGH   ( 0x9885 )
+
+/** The spacing between SD-GPIO config registers. */
+#define PC202_GPIO_SD_PIN_CONFIG_SPACING    ( 4 )
+
+/**
+ * Macro to get the address of a config register for a SD-GPIO pin.
+ *
+ * \param _n The SD-GPIO pin number.
+ * \return Returns the base address of the register.
+ */
+#define PC202_GPIO_SD_PIN_CONFIG( _n ) \
+    PC202_GPIO_SD_PIN_CONFIG_BASE + ( (_n) * PC202_GPIO_SD_PIN_CONFIG_SPACING )
+
+/** Control source bit. */
+#define PC202_GPIO_SD_CONFIG_CS_MASK ~( 1 << 15 )
+
+/** Define the number of SD-GPIOs allocated to lower register*/
+#define PC202_NUM_LSBS ( 16 + PC202_GPIO_PIN_SDGPIO_0 )
+
+/** PC202 PROCIF CAEID */
+#define PA_AEID_PROCINT2                ( 0x0048 )
+
+/** The address of the device id register in the PROCIF */
+#define PA_PROCINT2_DEVICEID            ( 0x0030 )
+
+/* picoArray device Ids */
+#define PC202_DEVICE_ID                 ( 0x0010 )
+#define PC205_DEVICE_ID                 ( 0x0012 )
+
+/* FPGA Configuration Done signal */
+#define FPGA_CONFIG_DONE                (PC202_GPIO_PIN_SDGPIO_27)
+
+/* Timeout (Sec) to wait for the fpga to configure */
+#define FGPA_CONFIG_DONE_TIMEOUT    (5)
+
+/* FPGA Board Id register */
+#define FPGA_DID_REG                (0)
+
+/* FPGA Code version register */
+#define FPGA_VERSION_REG            (1)
+
+#define FPGA_MAJOR_VERSION_MASK     (0xFF00)
+#define FPGA_MAJOR_VERSION_SHIFT    (8)
+
+#define FPGA_MINOR_VERSION_MASK     (0x00FF)
+#define FPGA_MINOR_VERSION_SHIFT    (0)
+
+/* Prototypes--------------------------------------------------------------- */
+/*!
+ *
+ * Write a 32 bit number to some address
+ *
+ * \param val, 32 bit value to write
+ * \param addr, address to write to
+ *
+ */
+static void picoif_out32(u32 val,
+                         void * addr);
+
+/*!
+ *
+ * Read a 32 bit value from some address
+ *
+ * \param addr, address to read from
+ * \return the 32 bit value read
+ *
+ */
+static u32 picoif_in32(void * addr);
+
+/*!
+ *
+ * Perform a picoArray config bus read
+ *
+ * \param aeid, aeid to use
+ * \param ae_addr, ae address to use
+ * \param buf, buffer to store the read data
+ * \param count, the number of reads to perform
+ * \return, the number of words read of negative on error
+ *
+ */
+static int
+procif_config_read(u16 aeid,
+                   u16 ae_addr,
+                   u16 *buf,
+                   u16 count);
+
+/*!
+ *
+ * Perform a picoArray config bus write
+ *
+ * \param aeid, aeid to use
+ * \param ae_addr, ae address to use
+ * \param buf, buffer contaning the data to write
+ * \param count, the number of writes to perform
+ * \return, the number of words written
+ *
+ */
+static int
+procif_config_write(u16 aeid,
+                    u16 ae_addr,
+                    u16 *buf,
+                    u16 count);
+
+/*!
+ *
+ * Start timer #0 in free running mode
+ *
+ */
+static void pc20x_timer_0_start(void);
+
+
+/*!
+ *
+ *  Obtaine the state of the fpga config done signal.
+ *
+ * \return 1 for config done,
+ *         0 config not complete,
+ *         negative on error
+ */
+
+static int
+fpga_config_done (void);
+
+/*!
+ *
+ *  Read FPGA registers via bit bashed SPI
+ *
+ * \param reg The FPGA register number to read
+ * \return Data read from FPGA
+ */
+static unsigned short fpga_read(unsigned char reg);
+
+/*!
+ *
+ *  Display the board type
+ *
+ * \param id_reg The id register contents read from the FPGA.
+ */
+static void display_board_type (unsigned short id_reg);
+
+/*!
+ *
+ *  Display some FPGA version information
+ *
+ * \param vers_reg The version register contents read from the FPGA.
+ */
+static void display_fpga_info (unsigned short vers_reg);
+
+static int initialise_sdgpio (void);
+
+/*!
+ * Setup the direction for an sg gpio pin
+ *
+ * \param pin_num The pin to set the direction of
+ * \param input Set to 1 for an input, 0 for an output
+ * \return Returns 0 on seccess non zero on error
+ */
+static int
+pc202gpio_sd_set_direction(int pin_num,
+                           int input);
+
+/*!
+ * Get the value of an input SDGPIO pin.
+ *
+ * \param pin The pin to get the value of.
+ * \return Returns the value read on success, negative on failure.
+ */
+static int
+pc202gpio_sd_get_value(int pin_num);
+
+/* Functions --------------------------------------------------------------- */
+
+/*****************************************************************************
+ *
+ * show_boot_progress()
+ *
+ * Purpose: Indicate booting progress
+ *
+ * Note: see U-Boot README for a list of 'progress' values.
+ *
+ *****************************************************************************/
+#if defined(CONFIG_SHOW_BOOT_PROGRESS)
+void show_boot_progress(int progress)
+{
+	printf("Boot reached stage %d\n", progress);
+}
+#endif
+
+/*****************************************************************************
+ *
+ * board_init()
+ *
+ * Purpose: Hardware platform initialisation functions
+ *
+ * Returns: 0 - Success
+ *
+ *****************************************************************************/
+int board_init (void)
+{
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x00000100;
+        gd->bd->bi_arch_number = MACH_TYPE_PC7802;
+	gd->flags = 0;
+
+	icache_enable ();
+
+        pc20x_timer_0_start();
+
+	return 0;
+}
+
+/*****************************************************************************
+ *
+ * checkboard()
+ *
+ * Purpose: Display some useful hardware platform information.
+ *
+ * Returns: 0 - Success
+ *
+ *****************************************************************************/
+int checkboard (void)
+{
+    u16 device_type;
+
+    int ret;
+
+    unsigned long timebase;
+
+    printf("Build: picoChip "PICOCHIP_PLATFORM" \n");
+
+    /* What picoChip device are we running on ? */
+    printf("Device: ");
+
+    ret = procif_config_read (PA_AEID_PROCINT2,
+                             PA_PROCINT2_DEVICEID,
+                             &device_type,
+                             1);
+    if (ret < 0)
+    {
+        /* Oops we didn't have a successful read */
+        printf("Failed to read the device id !\n");
+    }
+    else
+    {
+        /* We have a successful read... */
+        switch (device_type)
+        {
+            case PC202_DEVICE_ID:
+            {
+                printf("PC202\n");
+                break;
+            }
+            case PC205_DEVICE_ID:
+            {
+                printf("PC205\n");
+                break;
+            }
+            default:
+            {
+                printf("Unknown !\n");
+            }
+        }
+    }
+
+    /* Obtain some information from the FPGA */
+
+    /* Before we can read from the fpge we need to make sure it
+       has been configured */
+    ret = initialise_sdgpio();
+    if (ret == 0)
+    {
+        /* Now we wait for the fpga to configure */
+        timebase = get_timer(0);
+        do
+        {
+            ret = fpga_config_done ();
+
+            if (ret < 0)
+            {
+                break;
+            }
+
+            if (ret)
+            {
+                break;
+            }
+        }
+        while (get_timer(timebase) < FGPA_CONFIG_DONE_TIMEOUT);
+
+        if (ret < 0)
+        {
+            printf("Can't read from the SDGPIO !\n");
+        }
+        else if (ret)
+        {
+            /* The fpga has configured */
+            unsigned short fpga_id_reg = fpga_read(FPGA_DID_REG);
+            unsigned short fpga_ver_reg = fpga_read(FPGA_VERSION_REG);
+
+            /* Print out the board info */
+            if (fpga_id_reg != 0xffff)
+            {
+                /* We have an FPGA present */
+                display_board_type (fpga_id_reg);
+            }
+            else
+            {
+                printf("Failed to read the FPGA !\n");
+            }
+
+            /* Print out the FPGA info */
+            if (fpga_ver_reg != 0xffff)
+            {
+                /* We have an FPGA present */
+                display_fpga_info (fpga_ver_reg);
+            }
+        }
+        else
+        {
+            printf("FPGA not configured !\n");
+        }
+    }
+    else
+    {
+        printf("SDGPIO not configured !\n");
+    }
+
+    return 0;
+}
+
+/*****************************************************************************
+ *
+ * misc_init_r()
+ *
+ * Purpose: Miscellaneous platform dependent initialisations
+ *
+ * Returns: 0 - Success
+ *
+ *****************************************************************************/
+int misc_init_r (void)
+{
+    /* Not used right now, function template left here as a place holder */
+    return 0;
+}
+
+/*****************************************************************************
+ *
+ * dram_init()
+ *
+ * Purpose: Initialize the DDR SDRAM info in the board data structure
+ *
+ * Returns: 0 - Success
+ *
+ *****************************************************************************/
+int dram_init (void)
+{
+
+#ifndef CONFIG_PC20X_2_DDR_RAM_BANKS
+/* We want a 4 DDR Bank setup then */
+
+    gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+    gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+    gd->bd->bi_dram[1].start = PHYS_SDRAM_2;
+    gd->bd->bi_dram[1].size = PHYS_SDRAM_2_SIZE;
+    gd->bd->bi_dram[2].start = PHYS_SDRAM_3;
+    gd->bd->bi_dram[2].size = PHYS_SDRAM_3_SIZE;
+    gd->bd->bi_dram[3].start = PHYS_SDRAM_4;
+    gd->bd->bi_dram[3].size = PHYS_SDRAM_4_SIZE;
+
+#else   /* We want a 2 DDR Bank setup then */
+
+    gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+    gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+    gd->bd->bi_dram[1].start = PHYS_SDRAM_2;
+    gd->bd->bi_dram[1].size = PHYS_SDRAM_2_SIZE;
+
+#endif
+
+    return 0;
+}
+
+static void picoif_out32(u32 val,
+                         void * addr)
+{
+    *(unsigned int *)(addr) = val;
+}
+
+static u32 picoif_in32(void * addr)
+{
+    return *(unsigned int *)(addr);
+}
+
+static int
+procif_config_read(u16 aeid,
+                   u16 ae_addr,
+                   u16 *buf,
+                   u16 count)
+{
+    u32 val;
+    void *write_p = (void *)
+                    (PC20X_SLAVE_PROCIF_BASE + PROCIF_CONFIG_WRITE_REG_OFFSET);
+    void *read_p = (void *)
+                   (PC20X_SLAVE_PROCIF_BASE + PROCIF_CONFIG_READ_REG_OFFSET);
+    u16 to_read = count;
+    u16 rc;
+    unsigned i;
+    unsigned retries;
+
+    val = aeid | CAEID_BIT_MASK;
+    picoif_out32( val, write_p );
+
+    while ( to_read )
+    {
+        /* Output the address to read from. */
+        val = ( ae_addr + ( count - to_read ) ) | CADDR_BIT_MASK;
+        picoif_out32( val, write_p );
+
+        /* Dispatch the read requests. */
+        rc = ( to_read > 64 ) ? 64 : to_read;
+        val = CREAD_BIT_MASK;
+        for ( i = 0; i < rc; ++i )
+        {
+            picoif_out32( val, write_p );
+        }
+
+        /* Now read the values. */
+        for ( i = 0; i < rc; ++i )
+        {
+            retries = RETRIES;
+            while ( retries )
+            {
+                val = picoif_in32( read_p );
+                if ( val & ( RB_VALID_MASK | RB_FAIL_MASK ) )
+                    break;
+                --retries;
+            }
+
+            if ( !retries || ( val & RB_FAIL_MASK ) )
+            {
+                printf ( "config read %04x@%04x failed\n", aeid,
+                        ( ae_addr + ( count - to_read ) + i ) );
+                if ( !retries )
+                    printf ( "timed out\n" );
+
+                break;
+            }
+            else
+                buf[ ( count - to_read ) + i ] = val & 0xFFFF;
+        }
+
+        if ( val & RB_FAIL_MASK )
+            break;
+
+        to_read -= rc;
+    }
+
+    return !( val & RB_FAIL_MASK ) ? count : -1;
+}
+
+static int
+procif_config_write(u16 aeid,
+                    u16 ae_addr,
+                    u16 *buf,
+                    u16 count)
+{
+    u32 val;
+    void *write_p = (void *)
+                    (PC20X_SLAVE_PROCIF_BASE + PROCIF_CONFIG_WRITE_REG_OFFSET);
+    unsigned i;
+
+    val = aeid | CAEID_BIT_MASK;
+    picoif_out32( val, write_p );
+
+    /* Output the address to read from. */
+    val = ae_addr | CADDR_BIT_MASK;
+    picoif_out32( val, write_p );
+
+    /* Now read the values. */
+    for ( i = 0; i < count; ++i )
+    {
+        val = buf[ i ] | CWRITE_BIT_MASK;
+        picoif_out32( val, write_p );
+    }
+
+    return i;
+}
+
+static void pc20x_timer_0_start(void)
+{
+    /* Make sure timer #0 is disabled */
+    *(volatile unsigned int *)(CFG_TIMERBASE + TimerNControlRegOffset(0)) = 0;
+
+    /* Initialise the timer #0 to all 1's.  We do this  because we want to run
+       the timer in free running mode. */
+    *(volatile unsigned int *)(CFG_TIMERBASE + TimerNLoadCountRegOffset(0)) =
+                               0xFFFFFFFF;
+
+    /* Start timer #0 in free running mode */
+    *(volatile unsigned int *)(CFG_TIMERBASE + TimerNControlRegOffset(0)) =
+                              (TimerInterruptMask | TimerEnable);
+}
+
+static int
+fpga_config_done (void)
+{
+    return ( pc202gpio_sd_get_value( FPGA_CONFIG_DONE ) );
+}
+
+static unsigned short fpga_read(unsigned char reg)
+{
+#define SPI_SH_DELAY 1
+#define TXRX_LEN 2
+#define CS0     (1 << 3)
+#define CLK     (1 << 2)
+#define MISO    (1 << 1)
+#define MOSI    (1 << 0)
+    unsigned int odr, idr, ddr;
+    unsigned char bits;
+    unsigned short txrx_buf[TXRX_LEN];
+    int i;
+    unsigned int chip_select = CS0;
+
+    odr = *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortAOutputDataRegOffset) & 0xf0;
+    ddr = *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortADataDirectionRegOffset) & 0xf0;
+
+    /* Setup GPIO directions and initial state */
+
+    /* CS0, MOSI and MISO low. Set CLK high */
+    odr |= CLK;
+    *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortAOutputDataRegOffset) = odr;
+
+    /* CS0, CLK and MOSI outputs, MISO input */
+    ddr |= (CS0 | CLK | MOSI);
+    *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortADataDirectionRegOffset) = ddr;
+
+    /* Set chip select */
+    odr |= chip_select;
+    *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortAOutputDataRegOffset) = odr;
+
+    /* Setup the txrx buffer */
+    txrx_buf[0] = (reg << 8) | (1 << 7);  /* The address to access and read command bit */
+    txrx_buf[1] = 0;            /* The data read will appear here */
+
+    /* transfer each word */
+    for (i = 0; i < TXRX_LEN; i++)
+    {
+        bits = 16;
+        /* if (cpol == 0) this is SPI_MODE_0; else this is SPI_MODE_2 */
+
+        /* clock starts at inactive polarity */
+        for (txrx_buf[i] <<= (16 - bits); bits; bits--)
+        {
+            /* setup MSB (to slave) on trailing edge */
+            if (txrx_buf[i] & (1 << 15))
+            {
+                odr |= MOSI;
+            }
+            else
+            {
+                odr &= ~MOSI;
+            }
+            *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortAOutputDataRegOffset) = odr;
+
+            udelay(SPI_SH_DELAY);	/* T(setup) */
+
+            /* Set CLK low */
+            odr &= ~CLK;
+            *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortAOutputDataRegOffset) = odr;
+
+            udelay(SPI_SH_DELAY);
+
+            /* sample MSB (from slave) on leading edge */
+            txrx_buf[i] <<= 1;
+            idr = *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortAInputDataRegOffset);
+            if (idr & MISO)
+            {
+                txrx_buf[i] |= 0x01;
+            }
+
+            /* Set CLK high */
+            odr |= CLK;
+            *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortAOutputDataRegOffset) = odr;
+        }
+    }
+
+    /* Reset chip select and provide one clock cycle to reset the transfer */
+    udelay(SPI_SH_DELAY);
+    odr &= ~(chip_select);
+    *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortAOutputDataRegOffset) = odr;
+
+    odr &= ~CLK;
+    *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortAOutputDataRegOffset) = odr;
+
+    udelay(SPI_SH_DELAY);
+    odr |= CLK;
+    *(volatile unsigned int *)(PC20X_GPIO_BASE + GpioPortAOutputDataRegOffset) = odr;
+
+    /* The result is left in the second word */
+    return txrx_buf[1];
+}
+
+static void display_board_type (unsigned short id_reg)
+{
+    puts("Board: ");
+    printf("%04x\n", id_reg);
+}
+
+static void display_fpga_info (unsigned short vers_reg)
+{
+    puts("FPGA:  ");
+    printf("v%x.%x\n",
+           (vers_reg & FPGA_MAJOR_VERSION_MASK) >> FPGA_MAJOR_VERSION_SHIFT,
+           (vers_reg & FPGA_MINOR_VERSION_MASK) >> FPGA_MINOR_VERSION_SHIFT);
+}
+
+static int initialise_sdgpio (void)
+{
+    int ret;
+
+    u16 data = PC202_AHB2PICO_WAKE_UP;
+
+    /* We are initialising the sdgpio, therefore before we do anything
+     * else we need to wake up the AHB2PICO block. */
+    ret = procif_config_write( PC202_AHB2PICO_CAEID,
+                               PC202_AHB2PICO_SLEEP_REG, &data, 1 );
+    if ( 1 != ret )
+    {
+        printf("failed to wake up the AHB2PICO block.\n");
+        return -1;
+    }
+
+    /* Setup FPGA_CONFIG_DONE as an input */
+    ret = pc202gpio_sd_set_direction( FPGA_CONFIG_DONE, 1 );
+    if ( 0 != ret )
+    {
+        printf("failed to set the direction for sd gpio pin %d.\n",
+               FPGA_CONFIG_DONE );
+        return -1;
+    }
+    return 0;
+}
+
+static int
+pc202gpio_sd_set_direction(int pin_num,
+                           int input)
+{
+    int ret=0;
+    u16 data=0;
+    u16 reg=0;
+
+    ret = procif_config_read( PC202_AHB2PICO_CAEID,
+                              PC202_GPIO_SD_PIN_CONFIG
+                              ( pin_num - PC202_GPIO_PIN_SDGPIO_0 ),
+                              &data, 1 );
+    if ( 1 != ret )
+    {
+        printf( "failed to read config register for SDGPIO \
+                pin %u\n", pin_num );
+        return -1;
+    }
+
+    data &= PC202_GPIO_SD_CONFIG_CS_MASK;
+    ret = procif_config_write( PC202_AHB2PICO_CAEID,
+                               PC202_GPIO_SD_PIN_CONFIG
+                               ( pin_num - PC202_GPIO_PIN_SDGPIO_0 ),
+                               &data, 1 );
+    if ( 1 != ret )
+    {
+        printf( "failed to write config register for SDGPIO \
+                pin %u\n", pin_num );
+        return -1;
+    }
+
+    /* Configure the pin to drive or not drive the output as appropriate. */
+    if ( pin_num < PC202_NUM_LSBS)
+        reg = PC202_GPIO_SD_CONTROL_VAL_REG_LOW;
+    else
+        reg = PC202_GPIO_SD_CONTROL_VAL_REG_HIGH;
+
+    ret = procif_config_read( PC202_AHB2PICO_CAEID, reg, &data, 1 );
+    if ( 1 != ret )
+    {
+        printf( "failed to read SDGPIO control value register\n" );
+        return -1;
+    }
+
+    if ( input )
+        data &= ~( 1 << ( pin_num - PC202_NUM_LSBS ) );
+    else
+        data |= ( 1 << ( pin_num - PC202_NUM_LSBS ) );
+
+    ret = procif_config_write( PC202_AHB2PICO_CAEID, reg, &data, 1 );
+    if ( 1 != ret )
+    {
+        printf( "failed to write the control value register "
+                "for SDGPIO pin %u\n", pin_num );
+        return -1;
+    }
+
+    /* The output value upper register needs to be written in order for the configuration
+    change to take effect. This includes any reads of these registers. */
+
+    ret = procif_config_read( PC202_AHB2PICO_CAEID,
+                              PC202_GPIO_SD_OUTPUT_VAL_REG_HIGH,
+                              &data, 1);
+    if ( 1 != ret )
+    {
+        printf( "failed to read the high value register "
+                "for SDGPIO pin %u\n", pin_num );
+        return -1;
+    }
+
+    ret = procif_config_write( PC202_AHB2PICO_CAEID,
+                               PC202_GPIO_SD_OUTPUT_VAL_REG_HIGH,
+                               &data, 1);
+    if ( 1 != ret )
+    {
+        printf( "failed to write the high value register "
+                "for SDGPIO pin %u\n", pin_num );
+        return -1;
+    }
+
+    return 0;
+}
+
+static int
+pc202gpio_sd_get_value(int pin_num)
+{
+    int ret=0;
+
+    /* Digital mode */
+    u16 data[2]={0,0};
+
+    ret = procif_config_read( PC202_AHB2PICO_CAEID,
+                              PC202_GPIO_SD_INPUT_VAL_REG_LOW, data, 2 );
+    if ( 2 != ret )
+    {
+        printf( "failed to read SDGPIO input value regs\n" );
+        return -1;
+    }
+
+    if ( pin_num < PC202_NUM_LSBS )
+    {
+        return !!( data[0] & ( 1 << ( pin_num - PC202_NUM_LSBS ) ) );
+    }
+    else
+    {
+        return !!( data[1] & ( 1 << ( pin_num - PC202_NUM_LSBS ) ) );
+    }
+}
diff --git a/board/picochip/pc7802/u-boot.lds b/board/picochip/pc7802/u-boot.lds
new file mode 100644
index 0000000..02c90dc
--- /dev/null
+++ b/board/picochip/pc7802/u-boot.lds
@@ -0,0 +1,45 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file u-boot.lds
+* \brief Used during the build process.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+	. = ALIGN(4);
+	.text	:
+	{
+		cpu/arm926ejs/start.o (.text)
+		*(.text)
+	}
+	.rodata : { *(.rodata) }
+	. = ALIGN(4);
+	.data : { *(.data) }
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff --git a/board/picochip/svb302/Makefile b/board/picochip/svb302/Makefile
new file mode 100644
index 0000000..ca0434c
--- /dev/null
+++ b/board/picochip/svb302/Makefile
@@ -0,0 +1,41 @@
+#/*****************************************************************************
+# * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+# *****************************************************************************/
+
+#/*!
+#* \file Makefile
+#* \brief Used during the build process.
+#*
+#* Copyright (c) 2006-2009 picoChip Designs Ltd
+#*
+#* This program is free software; you can redistribute it and/or modify
+#* it under the terms of the GNU General Public License version 2 as
+#* published by the Free Software Foundation.
+#*
+#* All enquiries to support@picochip.com
+#*/
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= svb302.o
+SOBJS	:= lowlevel_init.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $^
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff --git a/board/picochip/svb302/config.mk b/board/picochip/svb302/config.mk
new file mode 100644
index 0000000..1fd0811
--- /dev/null
+++ b/board/picochip/svb302/config.mk
@@ -0,0 +1,28 @@
+#/*****************************************************************************
+# * $picoChipHeaderSubst$
+# *****************************************************************************/
+
+#/*!
+#* \file config.mk
+#* \brief Used during the build process.
+#*
+#* Copyright (c) 2006-2008 picoChip Designs Ltd
+#*
+#* This program is free software; you can redistribute it and/or modify
+#* it under the terms of the GNU General Public License version 2 as
+#* published by the Free Software Foundation.
+#*
+#* All enquiries to support@picochip.com
+#*/
+
+# The SVB302 U-Boot image should be re-located to address...
+TEXT_BASE = 0x00020000
+
+ifdef BSP_DIR
+include $(BSP_DIR)/config
+PLATFORM_CPPFLAGS += -DPICOCHIP_PLATFORM_VERSION=\"$(RELEASE_VERSION)\"
+endif
+
+ifeq ($(SVB302_RUN_FROM_RAM), Y)
+PLATFORM_CPPFLAGS += -DCONFIG_RUN_FROM_RAM
+endif
diff --git a/board/picochip/svb302/lowlevel_init.S b/board/picochip/svb302/lowlevel_init.S
new file mode 100644
index 0000000..a239c71
--- /dev/null
+++ b/board/picochip/svb302/lowlevel_init.S
@@ -0,0 +1,353 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file lowlevel_init.S
+* \brief Various low level setup functions.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/* Includes ---------------------------------------------------------------- */
+#include <config.h>
+#include <asm/arch/pc302.h>
+#include <asm/arch/mem_arm.h>
+#include <asm/arch/mem_shd.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/pa.h>
+#include <asm/arch/axi2cfg.h>
+
+/* Macros ------------------------------------------------------------------ */
+/* This gives us a peripheral bus base address of 0x80000000
+   and a memory region size of 4Mbytes */
+#define PERIPHERAL_BUS_SETUP        0x8000000D
+
+#define ASSERT_BOOT_ERROR_PIN       0
+#define NEGATE_BOOT_ERROR_PIN       1
+#define BOOT_ERROR_PIN_IS_OUTPUT    1
+
+/* Prototypes--------------------------------------------------------------- */
+
+/* Macros ------------------------------------------------------------------ */
+
+/*****************************************************************************
+ *
+ * configWriteLoadFile
+ *
+ *****************************************************************************/
+.macro  configWriteLoadFile Reg0, Reg1, Reg2, Reg3, lfbase, lfwords
+
+        LDR      \Reg0,=\lfbase
+        LDR      \Reg1,=PC302_AXI2CFG_BASE
+        LDR      \Reg2,=\lfwords
+0:
+        LDR      \Reg3, [\Reg0],#0x4
+        STR      \Reg3, [\Reg1,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
+        SUBS     \Reg2, \Reg2, #1
+        BNE      0b
+.endm
+
+/*****************************************************************************
+ *
+ * configRead
+ *
+ *****************************************************************************/
+.macro  configRead Reg0, Reg1, Reg2, aeid, addr
+
+        LDR         \Reg0,=PC302_AXI2CFG_BASE
+
+        /* aeid */
+        LDR         \Reg1,=\aeid
+        ORR         \Reg1,\Reg1,#PA_CONFIG_AEID
+        STR         \Reg1, [\Reg0,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
+
+        /* addr */
+        LDR         \Reg1,=\addr
+        ORR         \Reg1,\Reg1,#PA_CONFIG_ADDR
+        STR         \Reg1, [\Reg0,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
+
+        /* data */
+        MOV         \Reg1,#PA_CONFIG_READ
+        STR         \Reg1, [\Reg0,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
+        MOV         \Reg2,#0x20
+
+        /* read */
+0:
+        LDR         \Reg1, [\Reg0,#AXI2CFG_CONFIG_READ_REG_OFFSET]
+        TST         \Reg1, #(PA_CONFIG_VALID | PA_CONFIG_FAIL)
+        BNE         1f
+        SUBS        \Reg2,\Reg2,#1
+        BNE         0b
+        MOV         \Reg1, #PA_CONFIG_TIMEOUT
+1:
+        MOV         \Reg0, \Reg1
+
+.endm
+
+/* Functions --------------------------------------------------------------- */
+
+/*****************************************************************************
+ *
+ * lowlevel_init
+ *
+ * Description: Perform some low level PC302 initialisation
+ *
+ *****************************************************************************/
+ .global lowlevel_init
+
+ lowlevel_init:
+
+        /* Preserve link register across call */
+        mov r11,lr
+
+        /* Setup the Periheral Port Memory Remap Register */
+        LDR r0, =PERIPHERAL_BUS_SETUP
+        MCR p15, 0, r0, c15, c2, 4
+
+#ifdef CONFIG_PC302_SIMULATION
+        bl      register_initialisation
+#endif
+
+        /* Initialise the boot error pin */
+        bl      initialiseBootErrorPin
+
+        /* Setup the ARM memory interface */
+        bl      memif_arm_init
+
+        /* Set up the Shared memory interface */
+        bl      memif_shared_init
+
+        /* Restore link register */
+        mov     lr, r11
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * memif_arm_init
+ *
+ * Description: Initialise the ARM Memory Controller
+ *
+ *****************************************************************************/
+memif_arm_init:
+
+        LDR     r3, =PC302_MEMIF_BASE
+
+        /* ;; =MEMIF_ARM_ADDR_MAP_0_VAL_1Gbx8    (0x0F) */
+        LDR     r4, =MEMIF_ARM_ADDR_MAP_0_VAL_1Gbx8
+        STR     r4, [r3, #MEMIF_ARM_ADDR_MAP_0_OFFSET]
+
+        /* ;; =MEMIF_ARM_ADDR_MAP_1_VAL_1Gbx8    (0x10) */
+        LDR     r4, =MEMIF_ARM_ADDR_MAP_1_VAL_1Gbx8
+        STR     r4, [r3, #MEMIF_ARM_ADDR_MAP_1_OFFSET]
+
+        /* ;; =MEMIF_ARM_ADDR_MAP_2_VAL_1Gbx8    (0x11) */
+        LDR     r4, =MEMIF_ARM_ADDR_MAP_2_VAL_1Gbx8
+        STR     r4, [r3, #MEMIF_ARM_ADDR_MAP_2_OFFSET]
+
+        /* ;; =MEMIF_ARM_DRAM_PARAM_2_OFFSET (0x07) */
+        LDR     r4, [r3, #MEMIF_ARM_DRAM_PARAM_2_OFFSET]
+        AND     r4, r4, #0xFFFFFFF0
+        ORR     r4, r4, #0x00000004 ; wl = cl - 2
+        STR     r4, [r3, #MEMIF_ARM_DRAM_PARAM_2_OFFSET]
+
+        /* ;; =MEMIF_ARM_DRAM_BL_OFFSET (0x0D) */
+        LDR     r4, [r3, #MEMIF_ARM_DRAM_BL_OFFSET]
+        //;ORR     r4, r4, #0x00000001 ; bl = 8
+        BIC     r4, r4, #0x00000001 //; bl = 4
+        STR     r4, [r3, #MEMIF_ARM_DRAM_BL_OFFSET]
+
+        /* ;;  =MEMIF_ARM_DRAM_EMR_MR_OFFSET (0x0C) */
+        LDR     r4, [r3, #MEMIF_ARM_DRAM_EMR_MR_OFFSET]
+        AND     r4, r4, #0xFFFFFF88
+        //;ORR     r4, r4, #0x00000003 ; bl = 8
+        ORR     r4, r4, #0x00000002 //; bl = 4
+        ORR     r4, r4, #0x00000060 //; cl = 6
+        ORR     r4, r4, #0x04000000 //; dqs# = 0
+        STR     r4, [r3, #MEMIF_ARM_DRAM_EMR_MR_OFFSET]
+
+        /* ;;  =MEMIF_ARM_PHY_CMD_RDC_OFFSET (0x14) */
+        LDR     r4, [r3, #MEMIF_ARM_PHY_CMD_RDC_OFFSET]
+        AND     r4, r4, #0xFFFFFF00
+        ORR     r4, r4, #0x00000050 //;  phy wl
+        ORR     r4, r4, #0x00000006 //;  phy rl
+        STR     r4, [r3, #MEMIF_ARM_PHY_CMD_RDC_OFFSET]
+
+        /* ;; =MEMIF_ARM_ODT_CTRL_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_ODT_CTRL_OFFSET]
+        AND     r4, r4, #0xFFFFFF00
+        AND     r4, r4, #0xFFFF00FF
+        ORR     r4, r4, #0x0002 //; rd_odt_delay, cl-4
+        ORR     r4, r4, #0x0010 //; wr_odt_delay, cl-5
+        ORR     r4, r4, #0x0100 //; rd_odt_hold, 2 cycles for bl=4
+        ORR     r4, r4, #0x1000 //; wr_odt_hold, 2 cycles for bl=4
+        STR     r4, [r3, #MEMIF_ARM_ODT_CTRL_OFFSET]
+
+        /* ;; =MEMIF_ARM_PHY_LOCAL_ODT_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_PHY_LOCAL_ODT_OFFSET]
+        AND     r4, r4, #0xFFFFFFC0
+        ORR     r4, r4, #0x0001 //; rd_local_odt = 75 ohm
+                                //; wr_local_odt = off
+                                //; idle_local_odt = off
+        STR     r4, [r3, #MEMIF_ARM_PHY_LOCAL_ODT_OFFSET]
+
+        /* ;; =MEMIF_ARM_GP2_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_GP2_OFFSET]
+        ORR     r4, r4, #0x0010 //; fifo_we_in odt = 75 ohm
+                                //;;  full drive strength
+        STR     r4, [r3, #MEMIF_ARM_GP2_OFFSET]
+
+        /* ;; =MEMIF_ARM_INDIRECT_RW_CMD_OFFSET (0x00) */
+        LDR     r4, [r3, #MEMIF_ARM_INDIRECT_RW_CMD_OFFSET]
+        ORR     r4, r4, #0x1  //; de-assert soft reset
+        STR     r4, [r3, #MEMIF_ARM_INDIRECT_RW_CMD_OFFSET]
+
+/* Check to see if the mem-if ARM is ready yet? */
+memif_arm_init_poll:
+        LDR     r4, [r3, #MEMIF_ARM_CTRL_MODE_OFFSET]
+        AND     r4, r4, #0x3
+        CMP     r4, #0x1
+        BNE     memif_arm_init_poll
+
+        mov	pc, lr		/* Return to my caller */
+
+/*****************************************************************************
+ *
+ * memif_shared_init
+ *
+ * Description: Initialise the Shared Memory Controller
+ *
+ *****************************************************************************/
+
+/* Data to set-up the memif-Shared Shared, this is effectively a load file */
+
+memif_shared_init_data:
+        .word   LF_PA_AEID_MEMIF, LF_CBFM_SLEEPREG_ADDR, PA_WRITE_ZERO_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_ARB_G0_S0_S1, ADDR_SDRAM_ARB_G0_S0_S1_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_ARB_G0_S2_S3, ADDR_SDRAM_ARB_G0_S2_S3_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_ARB_G1_S0_S1, ADDR_SDRAM_ARB_G1_S0_S1_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_ARB_G1_S2_S3, ADDR_SDRAM_ARB_G1_S2_S3_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_VALID_GROUPS, ADDR_SDRAM_VALID_GROUPS_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_SETUP, ADDR_SDRAM_SETUP_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_REFRESH, ADDR_SDRAM_REFRESH_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_ODT_SETUP, ADDR_SDRAM_ODT_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_AXI_CONFIG, ADDR_SDRAM_AXI_CONFIG_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_MRS, ADDR_SDRAM_MRS_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_EMRS, ADDR_SDRAM_EMRS_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_PHY_CONFIG, ADDR_PHY_CONFIG_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_PHY_LOCAL_ODT_CONFIG, ADDR_PHY_LOCAL_ODT_CONFIG_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_PHY_RD_SLAVE, ADDR_PHY_RD_SLAVE_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_PHY_WR_SLAVE, ADDR_PHY_WR_SLAVE_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_PHY_IO_CELL_CONFIG, ADDR_PHY_IO_CELL_CONFIG_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_CFG_DONE, ADDR_SDRAM_CFG_DONE_DATA
+
+memif_shared_init:
+
+        /* Write the intialisation data into the picoArray */
+        configWriteLoadFile r0, r1, r2, r3, memif_shared_init_data, 54
+
+/* Check to see if the mem-if Shared is ready yet? */
+memif_shared_init_poll:
+
+        configRead r0, r1, r2, PA_AEID_MEMIF, ADDR_SDRAM_STATUS
+
+        /* Has it timed out? */
+        TST     r0, #PA_CONFIG_TIMEOUT
+        BNE     memif_shared_init_poll
+
+        /* Has it configured? */
+        TST     r0, #0x01
+        BEQ     memif_shared_init_poll
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * register_initialisation
+ *
+ * Description: Initialise some CPU registers
+ *
+ * Note:
+ * Used to prevent X propagation if running this code in a simulation
+ *
+ *****************************************************************************/
+register_initialisation:
+
+        mov     r0, #0x00000000
+        mov     r1, #0x00000000
+        mov     r2, #0x00000000
+        mov     r3, #0x00000000
+        mov     r4, #0x00000000
+        mov     r5, #0x00000000
+        mov     r6, #0x00000000
+        mov     r7, #0x00000000
+        mov     r8, #0x00000000
+        mov     r9, #0x00000000
+        mov     r10,#0x00000000
+
+        /* Don't noodle with r11 (fp)
+                             r12 (ip)
+                             r13 (sp)
+                             r14 (lr)
+                             r15 (pc)
+           as this would cause big probs ! */
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * initialiseBootErrorPin
+ *
+ * Initialise the GPIO that is used as the Boot Error pin
+ *
+ *****************************************************************************/
+ initialiseBootErrorPin:
+
+        /* Get base address of the arm gpio block */
+        ldr r0,=PC302_GPIO_BASE
+
+        /* Negate the Boot error pin (in the data register) */
+        ldr r1,[r0, #GPIO_SW_PORT_C_DR_REG_OFFSET]
+        orr r1,r1,#NEGATE_BOOT_ERROR_PIN
+        str r1,[r0, #GPIO_SW_PORT_C_DR_REG_OFFSET]
+
+        /* Set up Boot Error pin to be an output */
+        ldr r1,[r0, #GPIO_SW_PORT_C_DDR_REG_OFFSET]
+        orr r1,r1,#BOOT_ERROR_PIN_IS_OUTPUT
+        str r1,[r0, #GPIO_SW_PORT_C_DDR_REG_OFFSET]
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * assertBootError
+ *
+ * Assert the Boot Error pin. On the SVB302 this is used to illuminate an LED
+ *
+ *****************************************************************************/
+ .global assertBootError
+
+ assertBootError:
+
+        /* Get base address of the arm gpio block */
+        ldr r0,=PC302_GPIO_BASE
+
+        /* Assert the Boot Error pin */
+        mov r1, #ASSERT_BOOT_ERROR_PIN
+        str r1,[r0, #GPIO_SW_PORT_C_DR_REG_OFFSET]
+
+        /* Return to my caller */
+        mov	pc, lr
+
+       .end
diff --git a/board/picochip/svb302/svb302.c b/board/picochip/svb302/svb302.c
new file mode 100644
index 0000000..f246390
--- /dev/null
+++ b/board/picochip/svb302/svb302.c
@@ -0,0 +1,218 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file svb302.c
+* \brief Various useful functions for use on an SVB302 Platform.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+#include <asm/arch/pc302.h>
+#include <asm/arch/timer.h>
+#include <asm/arch/axi2cfg.h>
+
+/* Macros ------------------------------------------------------------------ */
+#define SIXTEEN_BIT_MASK    0xFFFF
+
+/* Constants --------------------------------------------------------------- */
+DECLARE_GLOBAL_DATA_PTR;
+
+enum pc302DeviceType { PC302_FAT_DEVICE = 3,
+                       PC302_NORMAL_DEVICE
+                     };
+
+/* Prototypes--------------------------------------------------------------- */
+/*!
+ *
+ * Start timer #0 in free running mode
+ *
+ */
+static void pc302Timer0Start(void);
+
+/*!
+ *
+ * Read the device identification code from the axi2cfg block
+ *
+ * \return The value read
+ */
+static unsigned int readDeviceId (void);
+
+/*!
+ *
+ * Read the device revision code from the axi2cfg block
+ *
+ * \return The value read
+ */
+static unsigned int readDeviceRevision (void);
+
+/*!
+ *
+ * Read an integer value from a register.
+ *
+ * \param The adrress to read from
+ * \return The value read
+ */
+static __inline unsigned int readFromRegister (const unsigned int address);
+
+/* Functions --------------------------------------------------------------- */
+
+/*****************************************************************************
+ *
+ * show_boot_progress()
+ *
+ * Purpose: Indicate booting progress
+ *
+ * Note: see U-Boot README for a list of 'progress' values.
+ *
+ *****************************************************************************/
+#if defined(CONFIG_SHOW_BOOT_PROGRESS)
+void show_boot_progress(int progress)
+{
+	printf("Boot reached stage %d\n", progress);
+}
+#endif
+
+/*****************************************************************************
+ *
+ * board_init()
+ *
+ * Purpose: Hardware platform initialisation functions
+ *
+ * Returns: 0 - Success
+ *
+ *****************************************************************************/
+int board_init (void)
+{
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x00000100;
+        gd->bd->bi_arch_number = MACH_TYPE_PC7302;
+	gd->flags = 0;
+
+	/* Enable the Instruction Cache */
+        icache_enable ();
+
+        /* Start a timer */
+        pc302Timer0Start();
+
+	return 0;
+}
+
+/*****************************************************************************
+ *
+ * checkboard()
+ *
+ * Purpose: Display some useful hardware platform information.
+ *
+ * Returns: 0 - Success
+ *
+ *****************************************************************************/
+int checkboard (void)
+{
+    unsigned int deviceType, revision;
+
+    puts("Build: picoChip "PICOCHIP_PLATFORM" \n");
+
+    /* What device are we running on ? */
+    puts("Device: ");
+
+    deviceType = readDeviceId();        /* Read the device Id */
+    revision = readDeviceRevision();    /* Read the revision code */
+
+    switch (deviceType)
+    {
+        case PC302_FAT_DEVICE:
+        {
+            printf("PC302 (Fat) Rev %04d\n", revision);
+            break;
+        }
+        case PC302_NORMAL_DEVICE:
+        {
+            printf("PC302 Rev %04d\n", revision);
+            break;
+        }
+        default:
+        {
+            printf("Unknown !\n");
+        }
+    }
+
+    return 0;
+}
+
+/*****************************************************************************
+ *
+ * misc_init_r()
+ *
+ * Purpose: Miscellaneous platform dependent initialisations
+ *
+ * Returns: 0 - Success
+ *
+ *****************************************************************************/
+int misc_init_r (void)
+{
+    /* Not used right now, function template left here as a place holder */
+    return 0;
+}
+
+/*****************************************************************************
+ *
+ * dram_init()
+ *
+ * Purpose: Initialize the DDR SDRAM info in the board data structure
+ *
+ * Returns: 0 - Success
+ *
+ *****************************************************************************/
+int dram_init (void)
+{
+
+    gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+    gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+    return 0;
+}
+
+static void pc302Timer0Start(void)
+{
+    *(volatile unsigned int *)(CFG_TIMERBASE + TIMERNCONTROLREGOFFSET(0)) =
+                              (TIMERINTERRUPTMASK | TIMERENABLE);
+}
+
+static unsigned int readDeviceId (void)
+{
+    unsigned int deviceId;
+
+    deviceId = readFromRegister (PC302_AXI2CFG_BASE +
+                                 AXI2CFG_DEVICE_ID_REG_OFFSET);
+    deviceId &= SIXTEEN_BIT_MASK;
+
+    return deviceId;
+}
+
+static unsigned int readDeviceRevision (void)
+{
+    unsigned int revisionCode;
+
+    revisionCode = readFromRegister (PC302_AXI2CFG_BASE +
+                                     AXI2CFG_REVISION_ID_REG_OFFSET);
+    revisionCode &= SIXTEEN_BIT_MASK;
+
+    return revisionCode;
+}
+
+static __inline unsigned int readFromRegister (const unsigned int address)
+{
+    /* Read an integer value from a register */
+
+    return(*(volatile unsigned int *)address);
+}
diff --git a/board/picochip/svb302/u-boot.lds b/board/picochip/svb302/u-boot.lds
new file mode 100644
index 0000000..02c90dc
--- /dev/null
+++ b/board/picochip/svb302/u-boot.lds
@@ -0,0 +1,45 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file u-boot.lds
+* \brief Used during the build process.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+	. = ALIGN(4);
+	.text	:
+	{
+		cpu/arm926ejs/start.o (.text)
+		*(.text)
+	}
+	.rodata : { *(.rodata) }
+	. = ALIGN(4);
+	.data : { *(.data) }
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff --git a/common/cmd_nand.c b/common/cmd_nand.c
index 9e38bf7..3d3d7fa 100644
--- a/common/cmd_nand.c
+++ b/common/cmd_nand.c
@@ -11,13 +11,14 @@
 #include <common.h>
 
 
-#ifndef CFG_NAND_LEGACY
+#ifndef CONFIG_NAND_LEGACY
 /*
  *
  * New NAND support
  *
  */
 #include <common.h>
+#include <linux/mtd/mtd.h>
 
 #if defined(CONFIG_CMD_NAND)
 
@@ -28,54 +29,69 @@
 #include <jffs2/jffs2.h>
 #include <nand.h>
 
-#if defined(CONFIG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
+#if defined(CONFIG_CMD_MTDPARTS)
 
 /* parition handling routines */
 int mtdparts_init(void);
 int id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num);
 int find_dev_and_part(const char *id, struct mtd_device **dev,
-		u8 *part_num, struct part_info **part);
+		      u8 *part_num, struct part_info **part);
 #endif
 
-static int nand_dump_oob(nand_info_t *nand, ulong off)
+static void cmd_usage(cmd_tbl_t *cmdtp)
 {
-	return 0;
+	printf("Usage:\n%s - %s\n\n", cmdtp->name, cmdtp->usage);
 }
 
-static int nand_dump(nand_info_t *nand, ulong off)
+static int nand_dump(nand_info_t *nand, ulong off, int only_oob)
 {
 	int i;
-	u_char *buf, *p;
+	u_char *datbuf, *oobbuf, *p;
 
-	buf = malloc(nand->oobblock + nand->oobsize);
-	if (!buf) {
+	datbuf = malloc(nand->writesize + nand->oobsize);
+	oobbuf = malloc(nand->oobsize);
+	if (!datbuf || !oobbuf) {
 		puts("No memory for page buffer\n");
 		return 1;
 	}
-	off &= ~(nand->oobblock - 1);
-	i = nand_read_raw(nand, buf, off, nand->oobblock, nand->oobsize);
+	off &= ~(nand->writesize - 1);
+	loff_t addr = (loff_t) off;
+	struct mtd_oob_ops ops;
+	memset(&ops, 0, sizeof(ops));
+	ops.datbuf = datbuf;
+	ops.oobbuf = oobbuf; /* must exist, but oob data will be appended to ops.datbuf */
+	ops.len = nand->writesize;
+	ops.ooblen = nand->oobsize;
+	ops.mode = MTD_OOB_RAW;
+	i = nand->read_oob(nand, addr, &ops);
 	if (i < 0) {
 		printf("Error (%d) reading page %08lx\n", i, off);
-		free(buf);
+		free(datbuf);
+		free(oobbuf);
 		return 1;
 	}
 	printf("Page %08lx dump:\n", off);
-	i = nand->oobblock >> 4; p = buf;
+	i = nand->writesize >> 4;
+	p = datbuf;
+
 	while (i--) {
-		printf( "\t%02x %02x %02x %02x %02x %02x %02x %02x"
-			"  %02x %02x %02x %02x %02x %02x %02x %02x\n",
-			p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
-			p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+		if (!only_oob)
+			printf("\t%02x %02x %02x %02x %02x %02x %02x %02x"
+			       "  %02x %02x %02x %02x %02x %02x %02x %02x\n",
+			       p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
+			       p[8], p[9], p[10], p[11], p[12], p[13], p[14],
+			       p[15]);
 		p += 16;
 	}
 	puts("OOB:\n");
 	i = nand->oobsize >> 3;
 	while (i--) {
-		printf( "\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
-			p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
+		printf("\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
+		       p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
 		p += 8;
 	}
-	free(buf);
+	free(datbuf);
+	free(oobbuf);
 
 	return 0;
 }
@@ -94,7 +110,7 @@ static int
 arg_off_size(int argc, char *argv[], nand_info_t *nand, ulong *off, size_t *size)
 {
 	int idx = nand_curr_device;
-#if defined(CONFIG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
+#if defined(CONFIG_CMD_MTDPARTS)
 	struct mtd_device *dev;
 	struct part_info *part;
 	u8 pnum;
@@ -142,26 +158,78 @@ arg_off_size(int argc, char *argv[], nand_info_t *nand, ulong *off, size_t *size
 		*size = nand->size - *off;
 	}
 
-#if  defined(CONFIG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
+#if defined(CONFIG_CMD_MTDPARTS)
 out:
 #endif
 	printf("device %d ", idx);
 	if (*size == nand->size)
 		puts("whole chip\n");
 	else
-		printf("offset 0x%lx, size 0x%x\n", *off, *size);
+		printf("offset 0x%lx, size 0x%zx\n", *off, *size);
 	return 0;
 }
 
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+static void print_status(ulong start, ulong end, ulong erasesize, int status)
+{
+	printf("%08lx - %08lx: %08lx blocks %s%s%s\n",
+		start,
+		end - 1,
+		(end - start) / erasesize,
+		((status & NAND_LOCK_STATUS_TIGHT) ?  "TIGHT " : ""),
+		((status & NAND_LOCK_STATUS_LOCK) ?  "LOCK " : ""),
+		((status & NAND_LOCK_STATUS_UNLOCK) ?  "UNLOCK " : ""));
+}
+
+static void do_nand_status(nand_info_t *nand)
+{
+	ulong block_start = 0;
+	ulong off;
+	int last_status = -1;
+
+	struct nand_chip *nand_chip = nand->priv;
+	/* check the WP bit */
+	nand_chip->cmdfunc(nand, NAND_CMD_STATUS, -1, -1);
+	printf("device is %swrite protected\n",
+		(nand_chip->read_byte(nand) & 0x80 ?
+		"NOT " : ""));
+
+	for (off = 0; off < nand->size; off += nand->erasesize) {
+		int s = nand_get_lock_status(nand, off);
+
+		/* print message only if status has changed */
+		if (s != last_status && off != 0) {
+			print_status(block_start, off, nand->erasesize,
+					last_status);
+			block_start = off;
+		}
+		last_status = s;
+	}
+	/* Print the last block info */
+	print_status(block_start, off, nand->erasesize, last_status);
+}
+#endif
+
+static void nand_print_info(int idx)
+{
+	nand_info_t *nand = &nand_info[idx];
+	struct nand_chip *chip = nand->priv;
+	printf("Device %d: ", idx);
+	if (chip->numchips > 1)
+		printf("%dx ", chip->numchips);
+	printf("%s, sector size %u KiB\n",
+	       nand->name, nand->erasesize >> 10);
+}
+
 int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 {
-	int i, dev, ret;
+	int i, dev, ret = 0;
 	ulong addr, off;
 	size_t size;
 	char *cmd, *s;
 	nand_info_t *nand;
-#ifdef CFG_NAND_QUIET
-	int quiet = CFG_NAND_QUIET;
+#ifdef CONFIG_SYS_NAND_QUIET
+	int quiet = CONFIG_SYS_NAND_QUIET;
 #else
 	int quiet = 0;
 #endif
@@ -179,11 +247,9 @@ int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 	if (strcmp(cmd, "info") == 0) {
 
 		putc('\n');
-		for (i = 0; i < CFG_MAX_NAND_DEVICE; i++) {
+		for (i = 0; i < CONFIG_SYS_MAX_NAND_DEVICE; i++) {
 			if (nand_info[i].name)
-				printf("Device %d: %s, sector size %u KiB\n",
-					i, nand_info[i].name,
-					nand_info[i].erasesize >> 10);
+				nand_print_info(i);
 		}
 		return 0;
 	}
@@ -191,16 +257,16 @@ int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 	if (strcmp(cmd, "device") == 0) {
 
 		if (argc < 3) {
+			putc('\n');
 			if ((nand_curr_device < 0) ||
-			    (nand_curr_device >= CFG_MAX_NAND_DEVICE))
-				puts("\nno devices available\n");
+			    (nand_curr_device >= CONFIG_SYS_MAX_NAND_DEVICE))
+				puts("no devices available\n");
 			else
-				printf("\nDevice %d: %s\n", nand_curr_device,
-					nand_info[nand_curr_device].name);
+				nand_print_info(nand_curr_device);
 			return 0;
 		}
 		dev = (int)simple_strtoul(argv[2], NULL, 10);
-		if (dev < 0 || dev >= CFG_MAX_NAND_DEVICE || !nand_info[dev].name) {
+		if (dev < 0 || dev >= CONFIG_SYS_MAX_NAND_DEVICE || !nand_info[dev].name) {
 			puts("No such device\n");
 			return 1;
 		}
@@ -208,7 +274,7 @@ int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 		puts("... is now current device\n");
 		nand_curr_device = dev;
 
-#ifdef CFG_NAND_SELECT_DEVICE
+#ifdef CONFIG_SYS_NAND_SELECT_DEVICE
 		/*
 		 * Select the chip in the board/cpu specific driver
 		 */
@@ -227,7 +293,7 @@ int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 		goto usage;
 
 	/* the following commands operate on the current device */
-	if (nand_curr_device < 0 || nand_curr_device >= CFG_MAX_NAND_DEVICE ||
+	if (nand_curr_device < 0 || nand_curr_device >= CONFIG_SYS_MAX_NAND_DEVICE ||
 	    !nand_info[nand_curr_device].name) {
 		puts("\nno devices available\n");
 		return 1;
@@ -299,15 +365,14 @@ int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 		off = (int)simple_strtoul(argv[2], NULL, 16);
 
 		if (s != NULL && strcmp(s, ".oob") == 0)
-			ret = nand_dump_oob(nand, off);
+			ret = nand_dump(nand, off, 1);
 		else
-			ret = nand_dump(nand, off);
+			ret = nand_dump(nand, off, 0);
 
 		return ret == 0 ? 1 : 0;
 
 	}
 
-	/* read write */
 	if (strncmp(cmd, "read", 4) == 0 || strncmp(cmd, "write", 5) == 0) {
 		int read;
 
@@ -322,46 +387,32 @@ int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 			return 1;
 
 		s = strchr(cmd, '.');
-		if (s != NULL &&
-		    (!strcmp(s, ".jffs2") || !strcmp(s, ".e") || !strcmp(s, ".i"))) {
-			if (read) {
-				/* read */
-				nand_read_options_t opts;
-				memset(&opts, 0, sizeof(opts));
-				opts.buffer	= (u_char*) addr;
-				opts.length	= size;
-				opts.offset	= off;
-				opts.quiet      = quiet;
-				ret = nand_read_opts(nand, &opts);
-			} else {
-				/* write */
-				nand_write_options_t opts;
-				memset(&opts, 0, sizeof(opts));
-				opts.buffer	= (u_char*) addr;
-				opts.length	= size;
-				opts.offset	= off;
-				/* opts.forcejffs2 = 1; */
-				opts.pad	= 1;
-				opts.blockalign = 1;
-				opts.quiet      = quiet;
-				ret = nand_write_opts(nand, &opts);
-			}
-		} else if (s != NULL && !strcmp(s, ".oob")) {
-			/* read out-of-band data */
+		if (!s || !strcmp(s, ".jffs2") ||
+		    !strcmp(s, ".e") || !strcmp(s, ".i")) {
 			if (read)
-				ret = nand->read_oob(nand, off, size, &size,
-						     (u_char *) addr);
+				ret = nand_read_skip_bad(nand, off, &size,
+							 (u_char *)addr);
 			else
-				ret = nand->write_oob(nand, off, size, &size,
-						      (u_char *) addr);
-		} else {
+				ret = nand_write_skip_bad(nand, off, &size,
+							  (u_char *)addr);
+		} else if (!strcmp(s, ".oob")) {
+			/* out-of-band data */
+			mtd_oob_ops_t ops = {
+				.oobbuf = (u8 *)addr,
+				.ooblen = size,
+				.mode = MTD_OOB_RAW
+			};
+
 			if (read)
-				ret = nand_read(nand, off, &size, (u_char *)addr);
+				ret = nand->read_oob(nand, off, &ops);
 			else
-				ret = nand_write(nand, off, &size, (u_char *)addr);
+				ret = nand->write_oob(nand, off, &ops);
+		} else {
+			printf("Unknown nand command suffix '%s'.\n", s);
+			return 1;
 		}
 
-		printf(" %d bytes %s: %s\n", size,
+		printf(" %zu bytes %s: %s\n", size,
 		       read ? "read" : "written", ret ? "ERROR" : "OK");
 
 		return ret == 0 ? 0 : 1;
@@ -381,13 +432,15 @@ int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 		}
 		return 1;
 	}
+
 	if (strcmp(cmd, "biterr") == 0) {
 		/* todo */
 		return 1;
 	}
 
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
 	if (strcmp(cmd, "lock") == 0) {
-		int tight  = 0;
+		int tight = 0;
 		int status = 0;
 		if (argc == 3) {
 			if (!strcmp("tight", argv[2]))
@@ -395,39 +448,8 @@ int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 			if (!strcmp("status", argv[2]))
 				status = 1;
 		}
-
 		if (status) {
-			ulong block_start = 0;
-			ulong off;
-			int last_status = -1;
-
-			struct nand_chip *nand_chip = nand->priv;
-			/* check the WP bit */
-			nand_chip->cmdfunc (nand, NAND_CMD_STATUS, -1, -1);
-			printf("device is %swrite protected\n",
-			       (nand_chip->read_byte(nand) & 0x80 ?
-				"NOT " : "" ) );
-
-			for (off = 0; off < nand->size; off += nand->oobblock) {
-				int s = nand_get_lock_status(nand, off);
-
-				/* print message only if status has changed
-				 * or at end of chip
-				 */
-				if (off == nand->size - nand->oobblock
-				    || (s != last_status && off != 0))	{
-
-					printf("%08lx - %08lx: %8lu pages %s%s%s\n",
-					       block_start,
-					       off-1,
-					       (off-block_start)/nand->oobblock,
-					       ((last_status & NAND_LOCK_STATUS_TIGHT) ? "TIGHT " : ""),
-					       ((last_status & NAND_LOCK_STATUS_LOCK) ? "LOCK " : ""),
-					       ((last_status & NAND_LOCK_STATUS_UNLOCK) ? "UNLOCK " : ""));
-				}
-
-				last_status = s;
-		       }
+			do_nand_status(nand);
 		} else {
 			if (!nand_lock(nand, tight)) {
 				puts("NAND flash successfully locked\n");
@@ -452,28 +474,34 @@ int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 		}
 		return 0;
 	}
+#endif
 
 usage:
-	printf("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
 }
 
 U_BOOT_CMD(nand, 5, 1, do_nand,
-	"nand    - NAND sub-system\n",
-	"info                  - show available NAND devices\n"
-	"nand device [dev]     - show or set current device\n"
-	"nand read[.jffs2]     - addr off|partition size\n"
-	"nand write[.jffs2]    - addr off|partition size - read/write `size' bytes starting\n"
-	"    at offset `off' to/from memory address `addr'\n"
-	"nand erase [clean] [off size] - erase `size' bytes from\n"
-	"    offset `off' (entire device if not specified)\n"
-	"nand bad - show bad blocks\n"
-	"nand dump[.oob] off - dump page\n"
-	"nand scrub - really clean NAND erasing bad blocks (UNSAFE)\n"
-	"nand markbad off - mark bad block at offset (UNSAFE)\n"
-	"nand biterr off - make a bit error at offset (UNSAFE)\n"
-	"nand lock [tight] [status] - bring nand to lock state or display locked pages\n"
-	"nand unlock [offset] [size] - unlock section\n");
+	   "nand     - NAND sub-system\n",
+	   "info - show available NAND devices\n"
+	   "nand device [dev] - show or set current device\n"
+	   "nand read - addr off|partition size\n"
+	   "nand write - addr off|partition size\n"
+	   "    read/write 'size' bytes starting at offset 'off'\n"
+	   "    to/from memory address 'addr', skipping bad blocks.\n"
+	   "nand erase [clean] [off size] - erase 'size' bytes from\n"
+	   "    offset 'off' (entire device if not specified)\n"
+	   "nand bad - show bad blocks\n"
+	   "nand dump[.oob] off - dump page\n"
+	   "nand scrub - really clean NAND erasing bad blocks (UNSAFE)\n"
+	   "nand markbad off - mark bad block at offset (UNSAFE)\n"
+	   "nand biterr off - make a bit error at offset (UNSAFE)\n"
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+	   "nand lock [tight] [status]\n"
+	   "    bring nand to lock state or display locked pages\n"
+	   "nand unlock [offset] [size] - unlock section\n"
+#endif
+);
 
 static int nand_load_image(cmd_tbl_t *cmdtp, nand_info_t *nand,
 			   ulong offset, ulong addr, char *cmd)
@@ -482,31 +510,22 @@ static int nand_load_image(cmd_tbl_t *cmdtp, nand_info_t *nand,
 	char *ep, *s;
 	size_t cnt;
 	image_header_t *hdr;
-	int jffs2 = 0;
 #if defined(CONFIG_FIT)
 	const void *fit_hdr = NULL;
 #endif
 
 	s = strchr(cmd, '.');
 	if (s != NULL &&
-	    (!strcmp(s, ".jffs2") || !strcmp(s, ".e") || !strcmp(s, ".i")))
-		jffs2 = 1;
+	    (strcmp(s, ".jffs2") && strcmp(s, ".e") && strcmp(s, ".i"))) {
+		printf("Unknown nand load suffix '%s'\n", s);
+		show_boot_progress(-53);
+		return 1;
+	}
 
 	printf("\nLoading from %s, offset 0x%lx\n", nand->name, offset);
 
-	cnt = nand->oobblock;
-	if (jffs2) {
-		nand_read_options_t opts;
-		memset(&opts, 0, sizeof(opts));
-		opts.buffer	= (u_char*) addr;
-		opts.length	= cnt;
-		opts.offset	= offset;
-		opts.quiet      = 1;
-		r = nand_read_opts(nand, &opts);
-	} else {
-		r = nand_read(nand, offset, &cnt, (u_char *) addr);
-	}
-
+	cnt = nand->writesize;
+	r = nand_read_skip_bad(nand, offset, &cnt, (u_char *) addr);
 	if (r) {
 		puts("** Read error\n");
 		show_boot_progress (-56);
@@ -536,19 +555,9 @@ static int nand_load_image(cmd_tbl_t *cmdtp, nand_info_t *nand,
 		puts ("** Unknown image type\n");
 		return 1;
 	}
+	show_boot_progress (57);
 
-	if (jffs2) {
-		nand_read_options_t opts;
-		memset(&opts, 0, sizeof(opts));
-		opts.buffer	= (u_char*) addr;
-		opts.length	= cnt;
-		opts.offset	= offset;
-		opts.quiet      = 1;
-		r = nand_read_opts(nand, &opts);
-	} else {
-		r = nand_read(nand, offset, &cnt, (u_char *) addr);
-	}
-
+	r = nand_read_skip_bad(nand, offset, &cnt, (u_char *) addr);
 	if (r) {
 		puts("** Read error\n");
 		show_boot_progress (-58);
@@ -594,7 +603,7 @@ int do_nandboot(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 	char *boot_device = NULL;
 	int idx;
 	ulong addr, offset = 0;
-#if defined(CONFIG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
+#if defined(CONFIG_CMD_MTDPARTS)
 	struct mtd_device *dev;
 	struct part_info *part;
 	u8 pnum;
@@ -612,7 +621,7 @@ int do_nandboot(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 			if (argc == 3)
 				addr = simple_strtoul(argv[1], NULL, 16);
 			else
-				addr = CFG_LOAD_ADDR;
+				addr = CONFIG_SYS_LOAD_ADDR;
 			return nand_load_image(cmdtp, &nand_info[dev->id->num],
 					       part->offset, addr, argv[0]);
 		}
@@ -622,7 +631,7 @@ int do_nandboot(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 	show_boot_progress(52);
 	switch (argc) {
 	case 1:
-		addr = CFG_LOAD_ADDR;
+		addr = CONFIG_SYS_LOAD_ADDR;
 		boot_device = getenv("bootdevice");
 		break;
 	case 2:
@@ -639,10 +648,10 @@ int do_nandboot(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 		offset = simple_strtoul(argv[3], NULL, 16);
 		break;
 	default:
-#if defined(CONFIG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
+#if defined(CONFIG_CMD_MTDPARTS)
 usage:
 #endif
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		show_boot_progress(-53);
 		return 1;
 	}
@@ -657,7 +666,7 @@ usage:
 
 	idx = simple_strtoul(boot_device, NULL, 16);
 
-	if (idx < 0 || idx >= CFG_MAX_NAND_DEVICE || !nand_info[idx].name) {
+	if (idx < 0 || idx >= CONFIG_SYS_MAX_NAND_DEVICE || !nand_info[idx].name) {
 		printf("\n** Device %d not available\n", idx);
 		show_boot_progress(-55);
 		return 1;
@@ -668,12 +677,12 @@ usage:
 }
 
 U_BOOT_CMD(nboot, 4, 1, do_nandboot,
-	"nboot   - boot from NAND device\n",
-	"[.jffs2] [partition] | [[[loadAddr] dev] offset]\n");
+	"nboot    - boot from NAND device\n",
+	"[partition] | [[[loadAddr] dev] offset]\n");
 
 #endif
 
-#else /* CFG_NAND_LEGACY */
+#else /* CONFIG_NAND_LEGACY */
 /*
  *
  * Legacy NAND support - to be phased out
@@ -726,15 +735,15 @@ void archflashwp(void *archdata, int wp);
 #define CONFIG_MTD_NAND_ECC_JFFS2
 
 /* bits for nand_legacy_rw() `cmd'; or together as needed */
-#define NANDRW_READ	0x01
-#define NANDRW_WRITE	0x00
-#define NANDRW_JFFS2	0x02
-#define NANDRW_JFFS2_SKIP	0x04
+#define NANDRW_READ         0x01
+#define NANDRW_WRITE        0x00
+#define NANDRW_JFFS2	    0x02
+#define NANDRW_JFFS2_SKIP   0x04
 
 /*
  * Imports from nand_legacy.c
  */
-extern struct nand_chip nand_dev_desc[CFG_MAX_NAND_DEVICE];
+extern struct nand_chip nand_dev_desc[CONFIG_SYS_MAX_NAND_DEVICE];
 extern int curr_device;
 extern int nand_legacy_erase(struct nand_chip *nand, size_t ofs,
 			    size_t len, int clean);
@@ -755,7 +764,7 @@ int do_nand (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 	switch (argc) {
 	case 0:
 	case 1:
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	case 2:
 		if (strcmp (argv[1], "info") == 0) {
@@ -763,7 +772,7 @@ int do_nand (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 
 			putc ('\n');
 
-			for (i = 0; i < CFG_MAX_NAND_DEVICE; ++i) {
+			for (i = 0; i < CONFIG_SYS_MAX_NAND_DEVICE; ++i) {
 				if (nand_dev_desc[i].ChipID ==
 				    NAND_ChipID_UNKNOWN)
 					continue;	/* list only known devices */
@@ -774,7 +783,7 @@ int do_nand (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 
 		} else if (strcmp (argv[1], "device") == 0) {
 			if ((curr_device < 0)
-			    || (curr_device >= CFG_MAX_NAND_DEVICE)) {
+			    || (curr_device >= CONFIG_SYS_MAX_NAND_DEVICE)) {
 				puts ("\nno devices available\n");
 				return 1;
 			}
@@ -784,7 +793,7 @@ int do_nand (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 
 		} else if (strcmp (argv[1], "bad") == 0) {
 			if ((curr_device < 0)
-			    || (curr_device >= CFG_MAX_NAND_DEVICE)) {
+			    || (curr_device >= CONFIG_SYS_MAX_NAND_DEVICE)) {
 				puts ("\nno devices available\n");
 				return 1;
 			}
@@ -793,14 +802,14 @@ int do_nand (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 			return 0;
 
 		}
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	case 3:
 		if (strcmp (argv[1], "device") == 0) {
 			int dev = (int) simple_strtoul (argv[2], NULL, 10);
 
 			printf ("\nDevice %d: ", dev);
-			if (dev >= CFG_MAX_NAND_DEVICE) {
+			if (dev >= CONFIG_SYS_MAX_NAND_DEVICE) {
 				puts ("unknown device\n");
 				return 1;
 			}
@@ -832,18 +841,18 @@ int do_nand (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 			return ret;
 		}
 
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	default:
 		/* at least 4 args */
 
 		if (strncmp (argv[1], "read", 4) == 0 ||
 		    strncmp (argv[1], "write", 5) == 0) {
-			ulong	addr = simple_strtoul (argv[2], NULL, 16);
-			off_t	off  = simple_strtoul (argv[3], NULL, 16);
-			size_t	size = simple_strtoul (argv[4], NULL, 16);
-			int	cmd = (strncmp (argv[1], "read", 4) == 0) ?
-					NANDRW_READ : NANDRW_WRITE;
+			ulong addr = simple_strtoul (argv[2], NULL, 16);
+			off_t off = simple_strtoul (argv[3], NULL, 16);
+			size_t size = simple_strtoul (argv[4], NULL, 16);
+			int cmd = (strncmp (argv[1], "read", 4) == 0) ?
+				  NANDRW_READ : NANDRW_WRITE;
 			size_t total;
 			int ret;
 			char *cmdtail = strchr (argv[1], '.');
@@ -860,19 +869,18 @@ int do_nand (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 							      (u_char *) addr);
 				}
 				return ret;
-			} else if (cmdtail && !strncmp (cmdtail, ".jffs2", 2))
-				cmd |= NANDRW_JFFS2;	/* skip bad blocks */
-			else if (cmdtail && !strncmp (cmdtail, ".jffs2s", 2)) {
+			} else if (cmdtail && !strncmp (cmdtail, ".jffs2s", 7)) {
 				cmd |= NANDRW_JFFS2;	/* skip bad blocks (on read too) */
 				if (cmd & NANDRW_READ)
 					cmd |= NANDRW_JFFS2_SKIP;	/* skip bad blocks (on read too) */
-			}
+			} else if (cmdtail && !strncmp (cmdtail, ".jffs2", 2))
+				cmd |= NANDRW_JFFS2;	/* skip bad blocks */
 #ifdef SXNI855T
 			/* need ".e" same as ".j" for compatibility with older units */
 			else if (cmdtail && !strcmp (cmdtail, ".e"))
 				cmd |= NANDRW_JFFS2;	/* skip bad blocks */
 #endif
-#ifdef CFG_NAND_SKIP_BAD_DOT_I
+#ifdef CONFIG_SYS_NAND_SKIP_BAD_DOT_I
 			/* need ".i" same as ".jffs2s" for compatibility with older units (esd) */
 			/* ".i" for image -> read skips bad block (no 0xff) */
 			else if (cmdtail && !strcmp (cmdtail, ".i")) {
@@ -880,9 +888,9 @@ int do_nand (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 				if (cmd & NANDRW_READ)
 					cmd |= NANDRW_JFFS2_SKIP;	/* skip bad blocks (on read too) */
 			}
-#endif /* CFG_NAND_SKIP_BAD_DOT_I */
+#endif /* CONFIG_SYS_NAND_SKIP_BAD_DOT_I */
 			else if (cmdtail) {
-				printf ("Usage:\n%s\n", cmdtp->usage);
+				cmd_usage(cmdtp);
 				return 1;
 			}
 
@@ -892,8 +900,7 @@ int do_nand (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 
 			ret = nand_legacy_rw (nand_dev_desc + curr_device,
 					      cmd, off, size,
-					      &total,
-					      (u_char *) addr);
+					      &total, (u_char *) addr);
 
 			printf (" %d bytes %s: %s\n", total,
 				(cmd & NANDRW_READ) ? "read" : "written",
@@ -919,7 +926,7 @@ int do_nand (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 
 			return ret;
 		} else {
-			printf ("Usage:\n%s\n", cmdtp->usage);
+			cmd_usage(cmdtp);
 			rcode = 1;
 		}
 
@@ -929,7 +936,7 @@ int do_nand (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 
 U_BOOT_CMD(
 	nand,	5,	1,	do_nand,
-	"nand    - legacy NAND sub-system\n",
+	"legacy NAND sub-system",
 	"info  - show available NAND devices\n"
 	"nand device [dev] - show or set current device\n"
 	"nand read[.jffs2[s]]  addr off size\n"
@@ -959,7 +966,7 @@ int do_nandboot (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	show_boot_progress (52);
 	switch (argc) {
 	case 1:
-		addr = CFG_LOAD_ADDR;
+		addr = CONFIG_SYS_LOAD_ADDR;
 		boot_device = getenv ("bootdevice");
 		break;
 	case 2:
@@ -976,7 +983,7 @@ int do_nandboot (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		offset = simple_strtoul(argv[3], NULL, 16);
 		break;
 	default:
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		show_boot_progress (-53);
 		return 1;
 	}
@@ -991,7 +998,7 @@ int do_nandboot (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 
 	dev = simple_strtoul(boot_device, &ep, 16);
 
-	if ((dev >= CFG_MAX_NAND_DEVICE) ||
+	if ((dev >= CONFIG_SYS_MAX_NAND_DEVICE) ||
 	    (nand_dev_desc[dev].ChipID == NAND_ChipID_UNKNOWN)) {
 		printf ("\n** Device %d not available\n", dev);
 		show_boot_progress (-55);
@@ -1000,11 +1007,11 @@ int do_nandboot (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	show_boot_progress (55);
 
 	printf ("\nLoading from device %d: %s at 0x%lx (offset 0x%lx)\n",
-		dev, nand_dev_desc[dev].name, nand_dev_desc[dev].IO_ADDR,
-		offset);
+	    dev, nand_dev_desc[dev].name, nand_dev_desc[dev].IO_ADDR,
+	    offset);
 
 	if (nand_legacy_rw (nand_dev_desc + dev, NANDRW_READ, offset,
-			SECTORSIZE, NULL, (u_char *)addr)) {
+			    SECTORSIZE, NULL, (u_char *)addr)) {
 		printf ("** Read error on %d\n", dev);
 		show_boot_progress (-56);
 		return 1;
@@ -1035,8 +1042,8 @@ int do_nandboot (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	show_boot_progress (57);
 
 	if (nand_legacy_rw (nand_dev_desc + dev, NANDRW_READ,
-			offset + SECTORSIZE, cnt, NULL,
-			(u_char *)(addr+SECTORSIZE))) {
+			    offset + SECTORSIZE, cnt, NULL,
+			    (u_char *)(addr+SECTORSIZE))) {
 		printf ("** Read error on %d\n", dev);
 		show_boot_progress (-58);
 		return 1;
@@ -1078,10 +1085,10 @@ int do_nandboot (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 
 U_BOOT_CMD(
 	nboot,	4,	1,	do_nandboot,
-	"nboot   - boot from NAND device\n",
+	"boot from NAND device",
 	"loadAddr dev\n"
 );
 
 #endif
 
-#endif /* CFG_NAND_LEGACY */
+#endif /* CONFIG_NAND_LEGACY */
diff --git a/common/main.c b/common/main.c
index 187ef8a..ba73494 100644
--- a/common/main.c
+++ b/common/main.c
@@ -441,7 +441,17 @@ void main_loop (void)
 			reset_cmd_timeout();
 		}
 #endif
-		len = readline (CFG_PROMPT);
+
+#if defined(CONFIG_PC302_SIMULATION)
+/* We are running in RTL simulation land */
+                
+                /* If we get here then the simulation is a success, so just stop and report 'pass' */
+                *(volatile unsigned int *)(0x58000004) = 0x00000004;
+                for (;;);   /* Just idle here until testbench is stopped */
+
+#endif /* CONFIG_PC302_SIMULATION */                
+                
+                len = readline (CFG_PROMPT);
 
 		flag = 0;	/* assume no special flags for now */
 		if (len > 0)
diff --git a/cpu/arm926ejs/config.mk b/cpu/arm926ejs/config.mk
index 8db4adb..a7fa838 100644
--- a/cpu/arm926ejs/config.mk
+++ b/cpu/arm926ejs/config.mk
@@ -21,10 +21,17 @@
 # MA 02111-1307 USA
 #
 
+ifeq ($(PC7302_THUMB), Y) 
+PLATFORM_RELFLAGS += -fno-strict-aliasing  -fno-common -ffixed-r7 \
+	             -msoft-float
+PLATFORM_CPPFLAGS += -mthumb -mthumb-interwork                     
+else
 PLATFORM_RELFLAGS += -fno-strict-aliasing  -fno-common -ffixed-r8 \
-	-msoft-float
+	             -msoft-float
+endif                                          
+
+PLATFORM_CPPFLAGS += -march=armv5t
 
-PLATFORM_CPPFLAGS += -march=armv4
 # =========================================================================
 #
 # Supply options according to compiler version
diff --git a/cpu/arm926ejs/cpu.c b/cpu/arm926ejs/cpu.c
index 56c6289..f4f920f 100644
--- a/cpu/arm926ejs/cpu.c
+++ b/cpu/arm926ejs/cpu.c
@@ -38,6 +38,36 @@ DECLARE_GLOBAL_DATA_PTR;
 #endif
 
 /* read co-processor 15, register #1 (control register) */
+#ifdef BUILD_FOR_THUMB
+static unsigned long read_p15_c1 (void)
+{
+	unsigned long value;
+
+	__asm__ __volatile__(
+		"@ Enter ARM mode   \n"
+                "push   {r6}        \n"
+                "adr    r6,2f       \n"
+                "bx     r6          \n"
+                ".align             \n"
+                ".arm               \n"
+                "2:                 \n"
+                "mrc	p15, 0, %0, c1, c0, 0   @ read control reg\n"
+                "@ Enter Thumb mode \n"
+                "adr    r6,3f + 1   \n"
+                "bx     r6          \n"
+                "3:                 \n"
+		".thumb             \n"
+                "pop    {r6}        \n"
+                : "=r" (value)
+		:
+		: "memory");
+
+#ifdef MMU_DEBUG
+	printf ("p15/c1 is = %08lx\n", value);
+#endif
+	return value;
+}
+#else
 static unsigned long read_p15_c1 (void)
 {
 	unsigned long value;
@@ -53,8 +83,36 @@ static unsigned long read_p15_c1 (void)
 #endif
 	return value;
 }
+#endif
 
 /* write to co-processor 15, register #1 (control register) */
+#ifdef BUILD_FOR_THUMB
+static void write_p15_c1 (unsigned long value)
+{
+#ifdef MMU_DEBUG
+	printf ("write %08lx to p15/c1\n", value);
+#endif
+	__asm__ __volatile__(
+		"@ Enter ARM mode   \n"
+		"push   {r6}        \n"
+                "adr    r6,2f       \n"
+                "bx     r6          \n"
+                ".align             \n"
+                ".arm               \n"
+                "2:                 \n"
+                "mcr	p15, 0, %0, c1, c0, 0   @ write it back\n"
+                "@ Enter Thumb mode \n"
+                "adr    r6,3f + 1   \n"
+                "bx     r6          \n"
+                ".thumb             \n"
+                "3:                 \n"
+		"pop    {r6}        \n"
+                :
+		: "r" (value)
+		: "memory");
+	read_p15_c1 ();
+}
+#else
 static void write_p15_c1 (unsigned long value)
 {
 #ifdef MMU_DEBUG
@@ -68,6 +126,7 @@ static void write_p15_c1 (unsigned long value)
 
 	read_p15_c1 ();
 }
+#endif
 
 static void cp_delay (void)
 {
@@ -101,6 +160,78 @@ int cpu_init (void)
 	return 0;
 }
 
+#ifdef BUILD_FOR_THUMB
+int cleanup_before_linux (void)
+{
+	/*
+	 * this function is called just before we call linux
+	 * it prepares the processor for linux
+	 *
+	 * we turn off caches etc ...
+	 */
+
+	unsigned long i;
+
+	disable_interrupts ();
+
+	/* turn off I/D-cache */
+
+	__asm__ __volatile__ (
+		"@ Enter ARM mode   \n"
+                "push   {r6}        \n"
+                "adr    r6,2f       \n"
+                "bx     r6          \n"
+                ".align             \n"
+                ".arm               \n"
+                "2:                 \n"
+                "mrc p15, 0, %0, c1, c0, 0\n"
+                "@ Enter Thumb mode \n"
+                "adr    r6,3f + 1   \n"
+                "bx     r6          \n"
+                ".thumb             \n"
+                "3:                 \n"
+                "pop    {r6}        \n"
+                :"=r" (i));
+	i &= ~(C1_DC | C1_IC);
+        __asm__ __volatile__ (
+		"@ Enter ARM mode   \n"
+                "push   {r6}        \n"
+                "adr    r6,2f       \n"
+                "bx     r6          \n"
+                ".align             \n"
+                ".arm               \n"
+                "2:                 \n"
+                "mcr p15, 0, %0, c1, c0, 0\n"
+                "@ Enter Thumb mode \n"
+                "adr    r6,3f + 1   \n"
+                "bx     r6          \n"
+                "3:                 \n"
+                ".thumb             \n"
+                "pop    {r6}        \n"
+                : :"r" (i));
+
+	/* flush I/D-cache */
+	i = 0;
+        __asm__ __volatile__ (
+		"@ Enter ARM mode   \n"
+                "push   {r6}        \n"
+                "adr    r6,2f       \n"
+                "bx     r6          \n"
+                ".align             \n"
+                ".arm               \n"
+                "2:                 \n"
+                "mcr p15, 0, %0, c7, c7, 0\n"
+                "@ Enter Thumb mode \n"
+                "adr    r6,3f + 1   \n"
+                "bx     r6          \n"
+                ".thumb             \n"
+                "3:                 \n"
+                "pop    {r6}        \n"
+                : :"r" (i));
+
+	return (0);
+}
+#else
 int cleanup_before_linux (void)
 {
 	/*
@@ -125,6 +256,7 @@ int cleanup_before_linux (void)
 
 	return (0);
 }
+#endif
 
 int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
diff --git a/cpu/arm926ejs/pc20x/Makefile b/cpu/arm926ejs/pc20x/Makefile
new file mode 100644
index 0000000..9b8b4b6
--- /dev/null
+++ b/cpu/arm926ejs/pc20x/Makefile
@@ -0,0 +1,51 @@
+#/*****************************************************************************
+# * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+# *****************************************************************************/
+
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).a
+
+COBJS	= emac.o serial.o timer.o
+SOBJS	= reset.o remap.o
+
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+START	:= $(addprefix $(obj),$(START))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/cpu/arm926ejs/pc20x/emac.c b/cpu/arm926ejs/pc20x/emac.c
new file mode 100644
index 0000000..b8e3885
--- /dev/null
+++ b/cpu/arm926ejs/pc20x/emac.c
@@ -0,0 +1,1281 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ *  board/picochip/cpe20x/firecracker_emac.c
+ *
+ * Copyright (c) 2007 picoChip Designs Ltd.
+ *
+ * Description:
+ *
+ * This module provides the network interface to the firecracker EMAC
+ * hardware.
+ *
+ * References:
+ *
+ * Synopsys DesignWare Ethernet Universal Databook Version 3.2
+ *  November 2005.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * v0.03 03jan07    - Port to the bootloader (U-Boot)
+ * v0.02 02jan07    - Fixed performance issues by using SLAB allocator.
+ *                  - Use hardware checksumming.
+ *                  - Disable fragmented packet handling code.
+ * v0.01 09nov06    - Initial version
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <asm/io.h>
+#include <pci.h>
+
+#include <asm/arch/pc20x.h>
+#include <asm/arch/emac.h>
+
+
+/* Stop and reset timeouts. These are pure guesswork! */
+#define EMAC_RESET_US                       (50)
+#define EMAC_STOP_US                        (50)
+#define EMAC_STOP_COUNT                     (10)
+
+
+/* EMAC_RX_CONTROL_FIELD_INIT and EMAC_TX_CONTROL_FIELD_INIT are the setup
+ * value of the receive and transmit descriptor control field respectively
+ */
+#define EMAC_RX_CONTROL_FIELD_INIT          (0)
+#define EMAC_TX_CONTROL_FIELD_INIT                  \
+        (EMAC_TX_DESC_CNTL_ENABLE_INT_COM |         \
+        EMAC_TX_DESC_CNTL_FIRST_SEG |               \
+        EMAC_TX_DESC_CNTL_LAST_SEG)
+
+
+/* EMAC_RX_REJECTION_MASK is a collection of the receive descriptor status
+ * bits that if set indicate that the received data is invalid and should
+ * be discarded.
+ */
+#define EMAC_RX_REJECTION_MASK                      \
+    (EMAC_DESC_STATUS_ERR_SUM |                     \
+     EMAC_RX_DESC_STATUS_FAIL_SRC_ADDR |            \
+     EMAC_RX_DESC_STATUS_LEN_ERR |                  \
+     EMAC_RX_DESC_STATUS_DRIBBLE_ERR)
+
+/* Timeout value (in uS) for various PHY operations */
+#define EMAC_PHY_TIMEOUT            (4000000)
+
+/* timeout for various */
+#define TOUT_LOOP   100000
+
+/* MII_WAIT_TIMEOUT - defines the number of jiffies to wait for the MII
+ * busy flag to be reset by the hardware.
+ */
+#define MII_WAIT_TIMEOUT 10
+
+/* EMAC_DMA_BUS_WIDTH defines the bus width of the EMAC DMA */
+#define EMAC_DMA_BUS_WIDTH_SHIFT    (2)
+#define EMAC_DMA_BUS_WIDTH          (1 << EMAC_DMA_BUS_WIDTH_SHIFT) /* 4 */
+#define EMAC_DMA_BUS_WIDTH_MASK     (EMAC_DMA_BUS_WIDTH - 1)        /* b'0011 */
+
+/* The maximum size of a single DMA transfer, allowing for size alignment */
+#define EMAC_MAX_DMA_LENGTH         (2032)
+
+/* The maximum packet size that can be handled by this driver */
+#define EMAC_MAX_PACKET_LENGTH      (EMAC_MAX_DMA_LENGTH * 2)
+
+/* The length mask to be applied to the receive descriptors */
+#define EMAC_RX_LENGTH_MASK         (0xf)
+#define EMAC_RX_LENGTH_ALLIGN       (16)
+
+#define ETH_LENGTH_OF_ADDRESS 6
+
+#if 0
+/* Default fixed MAC address to use in this driver. The hardware is read
+ * at initialisation and if no valid address is found there, this
+ * one is used.
+ */
+static unsigned char default_mac_address[ETH_LENGTH_OF_ADDRESS] = {
+    0x00, 0x15, 0xe1, 0x00, 0x00, 0x00
+};
+#endif
+
+/* Default receive and transmit ring lengths */
+#define EMAC_RX_RING_LENGTH 8
+#define EMAC_TX_RING_LENGTH 1
+
+/* CSR_CLOCK_RANGE defines the clock range setting to use */
+#define EMAC_CSR_CLOCK_RANGE EMAC_GMII_CSR_RANGE_100_150
+
+/* Phy registers */
+#define PHY_CTL 0x00
+#define PHY_STS 0x01
+
+/* Phy control bits */
+#define RESET       0x8000   /* reset, NB read back until 0 */
+#define AUTONEG_EN  0x1000   /* Autonegotiation enable */
+#define POWER_DOWN  0x0800   /* Power down */
+#define ISOLATE     0x0400   /* Isolate mii i/f electrically */
+#define AUTONEG     0x0200   /* Restart Autonegotiation */
+#define COLLISION   0x0080   /* Collision test */
+#define SPEED_10    0x0000   /* 10 Mbit/s */
+#define SPEED_100   0x2000   /* 100 Mbit/s */
+#define SPEED_1000  0x0040   /* 1000 Mbit/s */
+#define DUPLEX      0x0100   /* Duplex mode */
+#define LOOPBACK    0x4000
+
+/* Phy status bits: */
+#define AUTOCMPLT            0x0020 /* Autonegotiation completed */
+#define REMOTE_FAULT         0x0010 /* Remote fault condition */
+#define AUTONEG_CAPABLE      0x0008 /* Autonegotiation capable */
+#define LINK                 0x0004 /* Link status */
+#define JABBER_DETECT        0x0002 /* Jabber detect */
+#define EXTENDED_REGS        0x0001 /* Extended resister capabilities */
+
+
+/* emac_hw_desc mirrors the EMAC DMA descriptor. It must have the same
+ * endian and packing as the hardware.
+ * These are used for both receive and transmit descriptors.
+ */
+struct emac_dma_desc {
+    u32 status;
+    u32 control;
+    u32 buffer1;
+    u32 buffer2;
+};
+
+
+/* emac_desc structure is a structure that the accessed by the DMA hardware.
+ * Along with the DMA accessed data (that must appear at the start of the
+ * structure) this also holds management data used by the driver.
+ * A facility of the DMA hardware that allows a gap between descriptors
+ * in memory is utilised for the additional management information
+ */
+struct emac_desc {
+    /* Hardware Descriptor (must be first) */
+    struct emac_dma_desc dma;
+
+    /* Pointer to the device that uses this descriptor */
+    struct eth_device *dev;
+
+    /* Pointer to the ring used by this descriptor */
+    struct emac_ring *ring;
+
+    /* Pointer to the associated socket buffer wired up to this
+     * descriptor or NULL if it is not wired up to a socket buffer.
+     */
+    volatile void *skb;
+
+    /* The length of the mapped buffer associated with this descriptor.
+     * Used when unmapping.
+     */
+    unsigned int length;
+};
+
+
+/* emac_aligned_desc is a type that is big enough to hold the emac_desc
+ * padded up to the end of the last word (4 bytes). It is used for size
+ * information when allocating or traversing a descriptor ring by casting
+ * to this type.
+ */
+struct emac_aligned_desc {
+    u32 data[((sizeof(struct emac_desc) - 1) / 4) + 1];
+};
+
+/* emac_ring structure holds ring management and the address in
+ * DMA able memory of the hardware descriptor ring.
+ */
+struct emac_ring {
+
+    /* Pointer to the start of the descriptor ring in DMA able memory */
+    struct emac_aligned_desc *desc;
+
+    /* Physical address of the above descriptor ring, for the hardware */
+    dma_addr_t dma_ring_start;
+
+    /* The maximum number of elements in the ring */
+    unsigned int length;
+
+    /* The number of elements not in use */
+    unsigned int space;
+
+    /* The next to be processed by the driver */
+    struct emac_desc *next;
+    unsigned int next_idx;
+
+    /* The next to be processed by the hardware */
+    struct emac_desc *next_dma;
+    unsigned int next_dma_idx;
+
+    /* Pointer to the device that uses this ring */
+    struct eth_device *dev;
+};
+
+
+struct eth_device_stats {
+
+    unsigned long   rx_packets;     /* total packets received   */
+    unsigned long   tx_packets;     /* total packets transmitted    */
+    unsigned long   rx_bytes;       /* total bytes received     */
+    unsigned long   tx_bytes;       /* total bytes transmitted  */
+    unsigned long   rx_errors;      /* bad packets received     */
+    unsigned long   tx_errors;      /* packet transmit problems */
+    unsigned long   rx_dropped;     /* no space in linux buffers    */
+    unsigned long   tx_dropped;     /* no space available in linux  */
+    unsigned long   multicast;      /* multicast packets received   */
+    unsigned long   collisions;
+
+    /* detailed rx_errors: */
+    unsigned long   rx_length_errors;
+    unsigned long   rx_over_errors;     /* receiver ring buff overflow  */
+    unsigned long   rx_crc_errors;      /* recved pkt with crc error    */
+    unsigned long   rx_frame_errors;    /* recv'd frame alignment error */
+    unsigned long   rx_fifo_errors;     /* recv'r fifo overrun      */
+    unsigned long   rx_missed_errors;   /* receiver missed packet   */
+
+    /* detailed tx_errors */
+    unsigned long   tx_aborted_errors;
+    unsigned long   tx_carrier_errors;
+    unsigned long   tx_fifo_errors;
+    unsigned long   tx_heartbeat_errors;
+    unsigned long   tx_window_errors;
+
+    /* for cslip etc */
+    unsigned long   rx_compressed;
+    unsigned long   tx_compressed;
+};
+
+
+/* This structure is private to each device. It is used to pass
+ * packets in and out, so there is place for a packet
+ */
+struct emac_priv {
+
+    /* Statistics counters */
+    struct eth_device_stats stats;
+
+    /* Transmit and Receive descriptor rings */
+    struct emac_ring* tx_ring;
+    struct emac_ring* rx_ring;
+
+    /* PHY state */
+    int speed;
+    int duplex;
+    int link;
+    int oldspeed;
+    int oldduplex;
+    int oldlink;
+
+    /* Levels of speed, duplex and link */
+#define PHY_SPEED_10    10
+#define PHY_SPEED_100   100
+#define PHY_DUPLEX_HALF 0
+#define PHY_DUPLEX_FULL 1
+#define PHY_LINK_DOWN   0
+#define PHY_LINK_UP     1
+
+    /* Mirrored device registers */
+    u32 op_mode;
+};
+
+
+/* Static data structures: */
+static struct emac_ring rings[2];       /* One receive and one transmit ring */
+#define RING_DESC_BUF_SIZE  1024*10     /* Big enough for the Rx or Tx descs */
+static unsigned char descriptor_buf[2][RING_DESC_BUF_SIZE];
+#define RX_SKB_BUFLEN 1600
+static unsigned char rx_skb_buf[EMAC_RX_RING_LENGTH][RX_SKB_BUFLEN];
+
+
+/* Debugging levels: */
+#define LVL_FATAL       2   /* fatal error conditions         */
+#define LVL_ERR         3   /* error conditions         */
+#define LVL_WARNING     4   /* warning conditions           */
+#define LVL_NOTICE      5   /* normal but significant condition */
+#define LVL_INFO        6   /* informational            */
+#define LVL_DEBUG       7   /* debug-level messages         */
+#define LVL_TRACE       8   /* trace messages         */
+#define LVL_TRACE_IO    9   /* Register IO trace messages         */
+
+
+/* Define ENABLE_DEBUGGING to include code for debugging via printf.
+ * The value of ENABLE_DEBUGGING specifies the default debug level.
+ */
+//#define ENABLE_DEBUGGING LVL_TRACE
+#undef ENABLE_DEBUGGING
+
+
+/* Macros for register read/write. These hide the virtual addressing.
+ */
+#ifndef ENABLE_DEBUGGING
+
+#define EMAC_READ(__offset) \
+    *((volatile u32*)(PC20X_EMAC_BASE + __offset))
+
+#define EMAC_WRITE(__value, __offset) \
+    *((volatile u32*)(PC20X_EMAC_BASE + __offset)) = __value
+
+#define DB(__params)
+
+#else /* ENABLE_DEBUGGING */
+
+#define EMAC_READ(__offset) \
+    debug_ioread32(PC20X_EMAC_BASE + __offset)
+
+#define EMAC_WRITE(__value, __offset) \
+    debug_iowrite32(__value, (PC20X_EMAC_BASE + __offset))
+
+#define DB(__params) dbug_print __params
+
+/* Debugging level for this module */
+static volatile int debug_lvl = ENABLE_DEBUGGING;
+
+static void dbug_print(int lvl, const char *fmt, ...)
+{
+    static char lvl_ch[10] = {
+        '0', '1', 'F', 'E', 'W', 'N', 'I', 'D', 'T', '9'
+    };
+#define MAX_FORMAT_SIZE 1024
+    char buf[MAX_FORMAT_SIZE];
+    va_list args;
+    va_start(args, fmt);
+
+    if (debug_lvl >= lvl) {
+
+        vsprintf(buf, fmt, args);
+        printf("emac <%c>: %s", lvl_ch[lvl], buf);
+    }
+}
+
+static void debug_iowrite32(u32 val, unsigned int paddr)
+{
+    DB((LVL_TRACE_IO, "iowrite32(0x%08x)=0x%08x\n", paddr, val));
+    *((volatile u32*)paddr) = val;
+}
+
+static unsigned int debug_ioread32(unsigned int paddr)
+{
+    unsigned int val = *((volatile u32*)paddr);
+    DB((LVL_TRACE_IO, "ioread32(0x%08x)=0x%08x\n", paddr, val));
+    return val;
+}
+
+static void print_ping_seq(volatile void *skb)
+{
+    unsigned char *buf = (unsigned char *)skb;
+    DB((LVL_DEBUG, "ping seq - 0x%02x 0x%02x\n", buf[0x28], buf[0x29]));
+}
+
+static void print_ring(struct emac_ring *ring, char host, char dma, u32 hw_next)
+{
+    int i;
+    char str[200];
+    static volatile u32 hw_next_off;
+    static volatile int nw_next_idx;
+
+    hw_next_off = hw_next - ring->dma_ring_start;
+    nw_next_idx = hw_next_off / sizeof(struct emac_aligned_desc);
+
+    for (i = 0; i < ring->length; ++i) {
+        if (i == nw_next_idx) {
+            if (((struct emac_desc *)(&ring->desc[i]))->dma.status &
+                    EMAC_DESC_STATUS_OWNER) {
+                str[i] = 'D';
+            }
+            else {
+                str[i] = 'H';
+            }
+        }
+        else {
+            if (((struct emac_desc *)(&ring->desc[i]))->dma.status &
+                    EMAC_DESC_STATUS_OWNER) {
+                str[i] = 'd';
+            }
+            else {
+                str[i] = 'h';
+            }
+        }
+    }
+    str[i] = 0;
+
+    DB((LVL_DEBUG, "%s\n", str));
+}
+
+static void print_rings(struct eth_device *dev)
+{
+    struct emac_priv *priv = dev->priv;
+    static int rate_limit = 0;
+    u32 hw_next_tx = EMAC_READ(EMAC_DMA_CURR_TX_DESC_REG_OFFSET);
+    u32 hw_next_rx = EMAC_READ(EMAC_DMA_CURR_RX_DESC_REG_OFFSET);
+
+    if ((++rate_limit % 8) == 0) {
+        print_ring(priv->rx_ring, 'v', '.', hw_next_rx);
+        print_ring(priv->tx_ring, '.', '^', hw_next_tx);
+    }
+}
+
+#endif /* ENABLE_DEBUGGING */
+
+
+/*
+ * Move the next pointer in a ring on to the next descriptor
+ */
+static struct emac_desc *emac_next_desc(struct emac_ring *ring)
+{
+    ring->next_idx++;
+
+    if (ring->next_idx == ring->length) {
+        ring->next_idx = 0;
+    }
+
+    ring->next = (struct emac_desc *)&ring->desc[ring->next_idx];
+
+    DB((LVL_TRACE, "Next idx %u\n", ring->next_idx));
+
+    return ring->next;
+}
+
+
+/*
+ * Move the next DMA pointer in a ring on to the next descriptor
+ */
+static struct emac_desc *emac_next_dma_desc(struct emac_ring *ring)
+{
+    ring->next_dma_idx++;
+
+    if (ring->next_dma_idx == ring->length) {
+        ring->next_dma_idx = 0;
+    }
+
+    ring->next_dma = (struct emac_desc *)&ring->desc[ring->next_dma_idx];
+
+    DB((LVL_TRACE, "Next DMA idx %u\n", ring->next_dma_idx));
+
+    return ring->next_dma;
+}
+
+
+
+/* Reset the ring pointers state */
+static void emac_reset_ring_state(struct emac_ring *ring)
+{
+    ring->space = ring->length;
+    ring->next_idx = 0;
+    ring->next = (struct emac_desc *)ring->desc;
+    ring->next_dma_idx = 0;
+    ring->next_dma = (struct emac_desc *)ring->desc;
+}
+
+
+
+
+
+/* Read the bus for PHY at addr mii_id, register regnum, and
+ * return the value.  Clears miimcom first.  All PHY
+ */
+static int emac_mii_read(int mii_id, int regnum)
+{
+    unsigned int value = 0;
+
+    /* The emac_phy_[read|write] functions ensure that their operation
+     * has completed before they exit so we do not have to wait
+     * for a previous operation to finish here and we can go ahead and
+     * use the MII interface.
+     */
+
+    /* Setup the address register and start the read */
+    EMAC_WRITE(
+            ((mii_id << EMAC_GMII_ADDRESS_SHIFT) |
+             (regnum << EMAC_GMII_GMII_REG_SHIFT) |
+             EMAC_CSR_CLOCK_RANGE |
+             EMAC_GMII_BUSY),
+            EMAC_MAC_GMII_ADDR_REG_OFFSET);
+
+    /* Wait for the MII to finish */
+    udelay(1000);
+
+    /* Read back the register contents */
+    value = EMAC_READ(EMAC_MAC_GMII_DATA_REG_OFFSET);
+
+    return value;
+}
+
+
+/* Enable/disable, EMAC DMA */
+static void emac_dma_control(
+        struct eth_device *dev,
+        int rx_not_tx,
+        int enable)
+{
+    struct emac_priv *priv = dev->priv;
+    u32 mask;
+
+    /* Update the mirror */
+    if (rx_not_tx) {
+        mask = EMAC_START_RX;
+    }
+    else {
+        mask = EMAC_START_TX;
+    }
+
+    if (enable) {
+        priv->op_mode |= mask;
+    }
+    else {
+        priv->op_mode &= ~mask;
+    }
+
+    /* Write the mirror to the hardware */
+    EMAC_WRITE(priv->op_mode, EMAC_DMA_MODE_REG_OFFSET);
+}
+
+/* Make sure the EMAC DMA transmission is not suspended */
+static void emac_hw_tx_resume(struct eth_device *dev)
+{
+    u32 reg;
+
+    reg = EMAC_READ(EMAC_DMA_STATUS_REG_OFFSET);
+    if ((reg & EMAC_DMA_TX_STATE_MASK) == EMAC_DMA_TX_SUSPENDED) {
+        EMAC_WRITE(0, EMAC_DMA_TX_DEMAND_REG_OFFSET);
+    }
+}
+
+
+/* Make sure the EMAC DMA reception is not suspended */
+static void emac_hw_rx_resume(struct eth_device *dev)
+{
+    u32 reg;
+
+    reg = EMAC_READ(EMAC_DMA_STATUS_REG_OFFSET);
+    if ((reg & EMAC_DMA_RX_STATE_MASK) == EMAC_DMA_RX_SUSPENDED) {
+        EMAC_WRITE(0, EMAC_DMA_RX_DEMAND_REG_OFFSET);
+    }
+}
+
+
+/* There are multiple MAC Address register pairs on some controllers
+ * This function sets the numth pair to a given address
+ */
+void emac_set_mac_for_addr(u8 *addr)
+{
+    EMAC_WRITE((addr[5]<<8) | addr[4],
+            EMAC_MAC_ADDR_N_HIGH_REG_OFFSET(0));
+    EMAC_WRITE((addr[3]<<24) | (addr[2]<<16) | (addr[1]<<8) | addr[0],
+            EMAC_MAC_ADDR_N_LOW_REG_OFFSET(0));
+}
+
+
+/* Record the receive errors given a descriptor. If there are no
+ * errors, return 0.
+ */
+static int emac_rx_errors(struct eth_device *dev, struct emac_desc *desc)
+{
+    struct emac_priv *priv = dev->priv;
+    struct eth_device_stats *stats = &priv->stats;
+
+    /* Deal with errors in descriptors, and descriptors
+     * that hold partial frames. We only support a frame that fits
+     * into one descriptor.
+     */
+    if (((desc->dma.status & EMAC_RX_REJECTION_MASK) != 0) ||
+            ((desc->dma.status & EMAC_RX_DESC_STATUS_FIRST_DESC) == 0) ||
+            ((desc->dma.status & EMAC_RX_DESC_STATUS_LAST_DESC) == 0)) {
+
+        /* Record the error packets */
+        stats->rx_errors++;
+
+        /* Record the length errors */
+        if (desc->dma.status & EMAC_RX_DESC_STATUS_LEN_ERR) {
+            stats->rx_length_errors++;
+        }
+
+        /* Record the overflow errors */
+        else if (desc->dma.status & EMAC_RX_DESC_STATUS_OV_ERR) {
+            stats->rx_over_errors++;
+        }
+
+        /* Record the CRC errors */
+        else if (desc->dma.status & EMAC_RX_DESC_STATUS_CRC_ERR) {
+            stats->rx_crc_errors++;
+        }
+
+        /* Otherwise record a frame error */
+        else if (desc->dma.status & EMAC_DESC_STATUS_ERR_SUM) {
+            stats->rx_frame_errors++;
+        }
+
+        return 1;
+    }
+
+    return 0;
+}
+
+
+/* Initialises the EMAC and EMAC DMA registers and starts transmission and
+ * reception. Does not allocate buffers.
+ */
+static void emac_start(struct eth_device *dev)
+{
+    struct emac_priv *priv = dev->priv;
+    u32 reg;
+    unsigned int skip;
+
+    DB((LVL_TRACE, "emac_start\n"));
+
+    /* Set Host bus access parameters */
+    skip = (sizeof(struct emac_aligned_desc) -
+            sizeof(struct emac_dma_desc)) / EMAC_DMA_BUS_WIDTH;
+    EMAC_WRITE(
+            EMAC_BURST_LENGTH_8 |
+            ((skip << EMAC_DMA_SKIP_SHIFT) & EMAC_DMA_SKIP_MASK),
+            EMAC_DMA_BUS_MODE_REG_OFFSET);
+
+    /* Set the descriptor ring start addresses */
+    EMAC_WRITE(priv->rx_ring->dma_ring_start, EMAC_DMA_RX_LIST_REG_OFFSET);
+    EMAC_WRITE(priv->tx_ring->dma_ring_start, EMAC_DMA_TX_LIST_REG_OFFSET);
+
+    /* Set the MAC filter register up */
+    emac_set_mac_for_addr(dev->enetaddr);
+
+    /* Set up the frame filter control */
+    reg = 0;     /* Use defaults */
+    EMAC_WRITE(reg, EMAC_MAC_FRAME_FLT_REG_OFFSET);
+
+    /* Set the flow control reg */
+    reg = 0;
+    if (priv->duplex == PHY_DUPLEX_FULL) {
+        reg |= (EMAC_RX_FLOW_ENABLE | EMAC_TX_FLOW_ENABLE);
+    }
+    EMAC_WRITE(reg, EMAC_MAC_FLOW_CONTROL_REG_OFFSET);
+
+    /* Set the hardware up for duplex. Same settings for 10 and 100 speed */
+    reg =
+        EMAC_FRAME_BURST_ENABLE |
+        EMAC_PORT_SELECT |
+        EMAC_CHECKSUM_OFFLOAD |
+        EMAC_TX_ENABLE |
+        EMAC_RX_ENABLE;
+
+    if (priv->duplex == PHY_DUPLEX_HALF) {
+        reg |= EMAC_DIABLE_RECEIVE_OWN;
+    }
+    else {
+        reg |= EMAC_DUPLEX_MODE;
+    }
+
+    /* Set the control register.
+     * Starts the MAC reception and transmission
+     */
+    EMAC_WRITE(reg, EMAC_MAC_CONFIG_REG_OFFSET);
+
+    /* Set the operation mode */
+    priv->op_mode = 0;
+
+    /* Start the DMA reception and transmission */
+    emac_dma_control(dev, 1, 1);      /* Enable Rx */
+    emac_dma_control(dev, 0, 1);      /* Enable Tx */
+
+    DB((LVL_TRACE, "emac_start complete\n"));
+}
+
+
+/* Stop the receive and transmit rings. Stop interrupts. Reset the
+ * EMAC DMA controller. Does not free any ring buffers.
+ */
+static void emac_reset(struct eth_device *dev)
+{
+    struct emac_priv *priv = dev->priv;
+    u32 reg;
+    unsigned int stops;
+
+    DB((LVL_TRACE, "emac_reset\n"));
+
+    /* Stop the DMA hardware */
+    emac_dma_control(dev, 1, 0);    /* Disable Rx */
+    emac_dma_control(dev, 0, 0);    /* Disable Tx */
+
+    /* Stop the MAC hardware */
+    EMAC_WRITE(0, EMAC_MAC_CONFIG_REG_OFFSET);
+
+    /* Busy wait for the hardware to stop */
+    stops = EMAC_STOP_COUNT;
+    do {
+        /* Wait a while for the reset to happen */
+        udelay(EMAC_STOP_US);
+
+        reg = EMAC_READ(EMAC_DMA_STATUS_REG_OFFSET);
+        if ((reg & (EMAC_DMA_TX_STATE_MASK | EMAC_DMA_RX_STATE_MASK)) == 0) {
+            break;
+        }
+    } while(--stops > 0);
+
+    if (stops == 0) {
+        /* Timeout waiting for stop */
+        printf("emac: Can't stop EMAC DMA\n");
+    }
+
+    /* Set the reset bit to ensure the EMAC DMA is not running */
+    EMAC_WRITE(EMAC_SOFT_RESET, EMAC_DMA_BUS_MODE_REG_OFFSET);
+
+    /* Wait a while for the reset to happen */
+    udelay(EMAC_RESET_US);
+
+    /* Check that the reset has happened */
+    reg = EMAC_READ(EMAC_DMA_BUS_MODE_REG_OFFSET);
+    if ((reg & EMAC_SOFT_RESET) != 0) {
+        /* Reset has not occurred. Error */
+        printf("emac: Can't reset EMAC DMA\n");
+    }
+
+    /* Reset the receive rings state */
+    emac_reset_ring_state(priv->rx_ring);
+
+    DB((LVL_TRACE, "emac_reset complete\n"));
+}
+
+
+/* Called every time the controller might need to be made
+ * aware of new link state.  The PHY code conveys this
+ * information through variables in the phydev structure, and this
+ * function converts those variables into the appropriate
+ * register values, and can bring down the device if needed.
+ */
+static void emac_adjust_link(struct eth_device *dev)
+{
+    struct emac_priv *priv = dev->priv;
+    int new_state = 0;
+
+    if (priv->link) {
+
+        /* Now we make sure that we can be in full duplex mode.
+         * If not, we operate in half-duplex mode. */
+        if (priv->duplex != priv->oldduplex) {
+            new_state = 1;
+            priv->oldduplex = priv->duplex;
+        }
+
+        if (priv->speed != priv->oldspeed) {
+            new_state = 1;
+            priv->oldspeed = priv->speed;
+        }
+
+        if (!priv->oldlink) {
+            new_state = 1;
+            priv->oldlink = 1;
+        }
+
+        /* Something changed. Stop everything, set the new mode and
+         * restart everything again once more.
+         */
+        if (new_state) {
+
+            emac_reset(dev);
+            emac_start(dev);
+        }
+    }
+    else if (priv->oldlink) {
+        new_state = 1;
+        priv->oldlink = 0;
+        priv->oldspeed = 0;
+        priv->oldduplex = -1;
+
+        emac_reset(dev);
+    }
+}
+
+
+/* Initializes driver's PHY state, and attaches to the PHY.
+ * Returns 0 on success.
+ */
+static int emac_init_phy(struct eth_device *dev)
+{
+    struct emac_priv *priv = dev->priv;
+    int speed_100, speed_1000;
+    int timebase = 0;
+
+    priv->oldlink = 0;
+    priv->oldspeed = 0;
+    priv->oldduplex = -1;
+
+    /* Check on phy auto-negotiation progress */
+    if ((emac_mii_read(CONFIG_PHY_ADDR, PHY_STS) & AUTONEG_CAPABLE) ==
+            AUTONEG_CAPABLE) {
+
+        /* The phy is auto-negotiation capable */
+
+        timebase = get_timer (0);
+        do {
+            if ((emac_mii_read(CONFIG_PHY_ADDR, PHY_STS) & AUTOCMPLT) ==
+                    AUTOCMPLT) {
+                printf("Ethernet PHY auto-negotiation complete\n" );
+                break;
+            }
+        }
+        while (get_timer (timebase) < EMAC_PHY_TIMEOUT);
+    }
+
+    if ((emac_mii_read(CONFIG_PHY_ADDR, PHY_STS) & LINK) == 0) {
+        printf("Ethernet link: is down !\n");
+        priv->link = 0;
+        return 1;
+    }
+    else {
+        printf("Ethernet link: is up\n");
+        priv->link = 1;
+    }
+
+    priv->duplex = (emac_mii_read(CONFIG_PHY_ADDR, PHY_CTL) & DUPLEX) != 0;
+    printf("Ethernet link: %s-duplex mode\n", priv->duplex ? "Full" : "Half");
+
+    speed_100 = (emac_mii_read(CONFIG_PHY_ADDR, PHY_CTL) & SPEED_100) != 0;
+    speed_1000 = (emac_mii_read(CONFIG_PHY_ADDR, PHY_CTL) & SPEED_1000) != 0;
+    printf("Ethernet link: 10%s Mbit/s\n", speed_1000 ? "00" : speed_100? "0" : "");
+
+    if (speed_1000) {
+        priv->speed = 1000;
+    }
+    else if (speed_100) {
+        priv->speed = 100;
+    }
+    else {
+        priv->speed = 10;
+    }
+
+    emac_adjust_link(dev);
+
+    return 0;
+}
+
+/*
+ * Allocate a descriptor ring
+ */
+static struct emac_ring *emac_allocate_ring(
+        struct eth_device *dev,
+        unsigned int length,
+        unsigned int ring_num)
+{
+    struct emac_ring *ring = NULL;
+    struct emac_desc *desc;
+    int i;
+
+    /* First allocate the ring structure itself (use static data) */
+    ring = &rings[ring_num];
+
+    ring->desc = (struct emac_aligned_desc *)&descriptor_buf[ring_num][0];
+    /* Align on word boundary */
+    ring->desc =
+        (struct emac_aligned_desc *)(((unsigned int)ring->desc + 3) & 0xfffffffc);
+
+    /* DMA address same as descriptor address */
+    ring->dma_ring_start = (dma_addr_t)ring->desc;
+
+    /* Zero the DMA descriptors */
+    memset(ring->desc, 0, sizeof(struct emac_aligned_desc) * length);
+
+    /* Setup the ring structure */
+    ring->length = length;
+    emac_reset_ring_state(ring);
+    ring->dev = dev;
+
+    /* Setup all the descriptors */
+    for (i = 0; i < length; ++i) {
+
+        /* pointer to the descriptor */
+        desc = (struct emac_desc *)&ring->desc[i];
+
+        /* Setup the descriptor */
+        desc->dev = dev;
+        desc->ring = ring;
+
+        /* Mark it as owned by the HOST so the hardware will not use it */
+        desc->dma.status &= ~EMAC_DESC_STATUS_OWNER;
+    }
+
+    return ring;
+}
+
+
+/*
+ * Setup the descriptor fields to point to the data buffer.
+ * If this function fails, it descriptor is not changed
+ */
+static int emac_wireup_desc_dma(
+        struct eth_device *dev,
+        struct emac_desc *desc,
+        volatile void *ptr,
+        unsigned int length)
+{
+    dma_addr_t dma_addr;
+    int ret = 0;
+    u32 buf1_length = 0, buf2_length = 0;
+
+    /* Limit the length to the maximum. When we allocate a socket
+     * buffer of this length, a larger buffer is allocated and we
+     * cannot handle it.
+     */
+    if (length > (EMAC_MAX_DMA_LENGTH * 2)) {
+        length = (EMAC_MAX_DMA_LENGTH * 2);
+    }
+
+    /* Create a DMA mapping for the whole data buffer */
+    dma_addr = (dma_addr_t)ptr;
+
+    /* Record the direction and length for unmapping later */
+    desc->length = length;
+
+    /* Decrement the space left on the ring if we are not
+     * replacing an existing buffer
+     */
+    if (desc->dma.buffer1 == 0) {
+        desc->ring->space--;
+    }
+
+    /* Set the first DMA buffer pointer to the start of the buffer */
+    desc->dma.buffer1 = (u32)dma_addr;
+
+    /* If the length is less that the DMA length, use the first buffer only,
+     * otherwise use both buffers.
+     */
+    if (length <= EMAC_MAX_DMA_LENGTH) {
+
+        buf1_length = length;
+    }
+    else {
+
+        /* Set the maximum size for the first buffer */
+        buf1_length = EMAC_MAX_DMA_LENGTH;
+
+        /* Set the length of the second buffer */
+        buf2_length = length - EMAC_MAX_DMA_LENGTH;
+
+        /* Set the second DMA pointer, part way through the mapped area */
+        desc->dma.buffer2 = (u32)dma_addr + EMAC_MAX_DMA_LENGTH;
+    }
+
+    /* Modify the control field */
+    buf1_length =
+        (buf1_length << EMAC_DESC_CNTL_TBS1_SHIFT) & EMAC_DESC_CNTL_TBS1_MASK;
+    buf2_length =
+        (buf2_length << EMAC_DESC_CNTL_TBS2_SHIFT) & EMAC_DESC_CNTL_TBS2_MASK;
+    desc->dma.control &= ~EMAC_DESC_CNTL_TBS1_MASK;
+    desc->dma.control &= ~EMAC_DESC_CNTL_TBS2_MASK;
+    desc->dma.control = desc->dma.control | buf1_length | buf2_length;
+
+    return ret;
+}
+
+/*
+ * Get the status of a packet given the first descriptor that is wired up to
+ * it. This function looks at the ownership of the first and last descriptors
+ * and decides if the packet is owned by the host, hardware or shared between
+ * both.
+ */
+#define EMAC_DMA_OWNED 0
+#define EMAC_HOST_OWNED 1
+#define EMAC_JOINTLY_OWNED 2
+static int emac_get_next_dma_packet_status(struct emac_ring *ring)
+{
+    struct emac_desc *head_desc = ring->next_dma;
+
+    /* The next_dma descriptor must be the head of a packet */
+    if (head_desc->skb == NULL) {
+        DB((LVL_ERR, "emac: Internal Ring ERROR\n"));
+        return 0;
+    }
+
+    if ((head_desc->dma.status & EMAC_DESC_STATUS_OWNER) != 0) {
+        return EMAC_DMA_OWNED;
+    }
+
+    return EMAC_HOST_OWNED;
+}
+
+
+
+void emac_release(struct eth_device *dev)
+{
+    struct emac_priv *priv = dev->priv;
+
+    /* Force an update to the link status immediately, do not wait for the PHY
+     * driver code to do it's poll. This saves time and is less complex
+     * as we do not have to implement a wait. If the PHY driver happens to
+     * trigger the link down around the same time as we do this, a second
+     * link down event will be swallowed.
+     */
+    priv->link = 0;
+    emac_adjust_link(dev);
+
+    /* Free the descriptor rings */
+    priv->rx_ring = NULL;
+    priv->tx_ring = NULL;
+}
+
+
+/*
+ * Open and close
+ */
+
+static int emac_open(struct eth_device *dev, bd_t * bis)
+{
+    struct emac_priv *priv = dev->priv;
+    struct sk_buff *skb;
+    int ret = 1;
+    int i;
+    struct emac_desc *desc = NULL;
+
+    /* Allocate receive descriptor ring */
+    priv->rx_ring = emac_allocate_ring(dev, EMAC_RX_RING_LENGTH, 0);
+    if (priv->rx_ring == NULL) {
+        ret = 0;
+        DB((LVL_ERR, "Failed to allocate RX ring\n"));
+        goto out;
+    }
+
+    /* Allocate transmit descriptor ring */
+    priv->tx_ring = emac_allocate_ring(dev, EMAC_TX_RING_LENGTH, 1);
+    if (priv->tx_ring == NULL) {
+        ret = 0;
+        DB((LVL_ERR, "Failed to allocate TX ring\n"));
+        goto out;
+    }
+
+    /* Allocate receive socket buffers and setup receive descriptors */
+    for (i = 0; i < EMAC_RX_RING_LENGTH; ++i) {
+
+        /* Handy pointer to the descriptor */
+        desc = (struct emac_desc *)&priv->rx_ring->desc[i];
+
+        /* Setup the receive control */
+        desc->dma.control = EMAC_RX_CONTROL_FIELD_INIT;
+
+        skb = (void *)&rx_skb_buf[i][0];
+
+        /* Connect the socket buffer to the descriptor */
+        emac_wireup_desc_dma(dev, desc, skb, RX_SKB_BUFLEN);
+
+        /* Associate the descriptor with the socket buffer */
+        desc->skb = skb;
+
+        /* Mark it as owned by the DMA so the hardware will fill it */
+        desc->dma.status |= EMAC_DESC_STATUS_OWNER;
+    }
+
+    /* Mark the last receive descriptor as the end of the ring */
+    desc->dma.control |= EMAC_DESC_CNTL_END_RING;
+
+    /* Setup transmit descriptors */
+    for (i = 0; i < EMAC_TX_RING_LENGTH; ++i) {
+
+        /* Handy pointer to the descriptor */
+        desc = (struct emac_desc *)&priv->tx_ring->desc[i];
+
+        desc->dma.control = EMAC_TX_CONTROL_FIELD_INIT;
+    }
+
+    /* Mark the last transmit descriptor as the end of the ring */
+    desc->dma.control |= EMAC_DESC_CNTL_END_RING;
+
+    /* Configure the PHY and start link status monitoring */
+    ret = emac_init_phy(dev);
+    if (ret != 0) {
+        DB((LVL_ERR, "Failed to initialise PHY driver\n"));
+        goto out;
+    }
+
+    return 0;
+out:
+    if (ret != 0) {
+        emac_release(dev);
+    }
+    return ret;
+}
+
+
+/* Pass a new received socket buffer to the networking layer */
+static int emac_pass_up_skb(
+        struct eth_device *dev,
+        volatile void *skb,
+        int data_length)
+{
+#ifdef ENABLE_DEBUGGING
+    //print_ping_seq(skb);
+#endif
+
+    /* Pass the buffer to the client */
+    NetReceive(skb, data_length);
+
+    return 0;
+}
+
+/* Processing of status bits. This does a similar job to the interrupt handler
+ * except it is polled.
+ */
+static void emac_status_processing(struct eth_device *dev)
+{
+    u32 statusword;
+
+    /* Retrieve the interrupt status */
+    statusword = EMAC_READ(EMAC_DMA_STATUS_REG_OFFSET);
+    /* Clear all interrupt status bits we will service */
+    EMAC_WRITE(statusword, EMAC_DMA_STATUS_REG_OFFSET);
+
+    /* Handle TX/RX stopped interrupt by restarting */
+    if (statusword & (EMAC_TX_STOPPED_INT | EMAC_RX_STOPPED_INT)) {
+        DB((LVL_WARNING, "Rx or Tx stopped seen, Restarting\n"));
+        emac_dma_control(dev, 1, 1);      /* Enable Rx */
+        emac_dma_control(dev, 0, 1);      /* Enable Tx */
+    }
+}
+
+
+/*
+ * The poll implementation.
+ */
+static int emac_poll(struct eth_device *dev)
+{
+    struct emac_priv *priv = dev->priv;
+    struct emac_desc *desc;
+    struct emac_ring *ring = priv->rx_ring;
+    volatile void *full_skb;
+    unsigned int data_length = 0;
+
+    DB((LVL_TRACE, "emac_poll\n"));
+
+    /* Process status bits */
+    emac_status_processing(dev);
+
+    if (emac_get_next_dma_packet_status(ring) == EMAC_HOST_OWNED) {
+
+        /* Handy pointer to this descriptor, and the socket buffer
+         * that is full of received data
+         */
+        desc = ring->next_dma;
+        full_skb = desc->skb;
+
+        /* Move on to the next packet for future processing */
+        emac_next_dma_desc(ring);
+
+        /* Discard bad frames and count errors */
+        if (emac_rx_errors(dev, desc) == 0) {
+
+            /* Get the received length from the descriptor */
+            data_length = (desc->dma.status & EMAC_RX_DESC_STATUS_FLEN_MASK)
+                >> EMAC_RX_DESC_STATUS_FLEN_SHIFT;
+
+            /* Pass the socket buffer that has received data to
+             * the network layer
+             */
+            emac_pass_up_skb(dev, full_skb, data_length);
+
+            /* Re-use the socket buffer that is already connected to the
+             * descriptor. Set the ownership to DMA owned.
+             */
+            desc->dma.status |= EMAC_DESC_STATUS_OWNER;
+        }
+    }
+
+    /* Kick the hardware to continue receiving if it is suspended as there
+     * are now more descriptors available for the DMA to write into.
+     */
+    emac_hw_rx_resume(dev);
+
+    return data_length;
+}
+
+
+
+/*
+ * Transmit a packet (called by the kernel)
+ */
+int emac_tx(struct eth_device *dev, volatile void *skb, int length)
+{
+    struct emac_priv *priv = dev->priv;
+    struct emac_desc *desc, *first_desc;
+    struct emac_ring *ring = priv->tx_ring;
+    int i = 0;
+
+    DB((LVL_TRACE, "emac_tx\n"));
+
+#ifdef ENABLE_DEBUGGING
+    //print_ping_seq(skb);
+#endif
+
+    /* Add the socket buffer to the transmit ring. We assume that the
+     * socket buffer is not larger that a page. This is a valid assumption
+     * as we have a maximum MTU of 4k (a page) and the networking layer
+     * should not be sending us frames larger than this.
+     */
+
+    /* Handy pointer to the first transmit descriptor to be added */
+    first_desc = ring->next;
+    desc = first_desc;
+
+    /* Set the descriptor to point to the buffer  */
+    emac_wireup_desc_dma(dev, desc, skb, length);
+
+    /* Associate the first descriptor with the socket buffer head */
+    desc->skb = skb;
+
+    /* Move on to the next descriptor where the
+     * following frame will be added
+     */
+    emac_next_desc(ring);
+
+    /* Set the ownership so that the packet will be sent */
+    first_desc->dma.status |= EMAC_DESC_STATUS_OWNER;
+
+    /* Kick the EMAC DMA */
+    emac_hw_tx_resume(dev);
+
+    /* Wait for the send to complete */
+    while (first_desc->dma.status & EMAC_DESC_STATUS_OWNER){
+        if (i++ > TOUT_LOOP) {
+            DB((LVL_WARNING, "emac: tx timeout\n"));
+            return 0;
+        }
+        udelay(10); /* give the nic a chance to write to the register */
+
+        /* Process status bits */
+        emac_status_processing(dev);
+    }
+
+    return 1;
+}
+
+/*
+ * The init function (sometimes called probe).
+ */
+void pc20x_eth_initialize(bd_t * bis)
+{
+    struct eth_device *nic = NULL;
+    struct emac_priv *priv = NULL;
+
+    nic = (struct eth_device *) malloc(sizeof (*nic));
+    priv = (struct emac_priv *) malloc(sizeof (*priv));
+    nic->priv = priv;
+
+    sprintf(nic->name, "pc20x_emac");
+
+    /* Reset the private data */
+    memset(priv, 0, sizeof(struct emac_priv));
+
+    /* Assign the hardware address of the interface */
+    memcpy(nic->enetaddr, bis->bi_enetaddr, ETH_LENGTH_OF_ADDRESS);
+
+    nic->init = emac_open;
+    nic->recv = emac_poll;
+    nic->send = emac_tx;
+    nic->halt = emac_release;
+
+    eth_register(nic);
+}
diff --git a/cpu/arm926ejs/pc20x/remap.S b/cpu/arm926ejs/pc20x/remap.S
new file mode 100644
index 0000000..9d029d3
--- /dev/null
+++ b/cpu/arm926ejs/pc20x/remap.S
@@ -0,0 +1,116 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <asm/arch/pc20x.h>
+#include <asm/arch/rap.h>
+#include <asm/arch/procif.h>
+
+	.align	5
+
+/*!
+ *
+ * Remap the bootable flash back to its 'correct' location in the
+ * pc20x memory map.
+ * Once this function returns we will be able to access
+ * sdram at addr 0x00000000.
+ *                
+ */
+ .global remap_flash
+ 
+ remap_flash:      
+ 
+        /* Check the remap in the rap block and return if we are already remapped */
+        ldr     r2, = PC20X_REMAP_BASE
+        ldr     r3, [r2,#RapRemapModeRegOffset]
+        ands    r3, r3, #REMAP_NORMAL_MODE
+        
+        /* If we are, don't remap */
+        bne     remap_flash_return                      
+ 	
+        /* Preserve link register across call */
+        mov r11,lr                                       
+
+        
+        /* Check to see if we are doing a software reboot */
+        ldr     r2, = PC20X_PROCIF_BASE                 
+        ldr     r3, [r2,#ProcifExtTabEnt0RegOffset]   
+        cmp     r3, #PC20X_BOOTABLE_FLASH_BASE
+
+        /* If we are, don't remap */
+        beq     remap_flash_return                      
+        
+        bl  noodle_program_counter
+        
+        
+        /* We are now executing code from the 'correct' Bootable Flash memory address */
+        
+        /* Perform the remap in the rap block */
+        ldr     r2, = PC20X_REMAP_BASE
+        mov     r3, #REMAP_NORMAL_MODE
+        str     r3, [r2,#RapRemapModeRegOffset]
+ 	
+	/* Allow things to settle down... */
+        nop
+        nop
+        nop
+        nop
+        nop
+        nop
+        nop
+        nop
+        nop
+        nop
+        nop
+        nop
+        nop
+        nop
+        nop
+        nop
+
+        /* Restore link register */
+        mov     lr, r11                                 
+
+        /* on return, execute code from Bootable Flash memory */
+        orr     lr, lr, #PC20X_BOOTABLE_FLASH_BASE	
+
+remap_flash_return:
+
+        /* Return to my caller */
+        mov	pc, lr		                        
+        
+ 
+ /*!
+ *
+ * Set the pc so we are executing code from Bootable Flash memory
+ * at the 'correct' address in the PC20x memory map.
+ *                
+ */
+ noodle_program_counter:
+ 
+        /* On return, execute code from Bootable Flash memory */
+        orr     lr, lr, #PC20X_BOOTABLE_FLASH_BASE	
+
+        /* Return to my caller */
+        mov     pc, lr		                        
diff --git a/cpu/arm926ejs/pc20x/reset.S b/cpu/arm926ejs/pc20x/reset.S
new file mode 100644
index 0000000..34b81b4
--- /dev/null
+++ b/cpu/arm926ejs/pc20x/reset.S
@@ -0,0 +1,60 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <config.h>
+#include <asm/arch/pc20x.h>
+#include <asm/arch/procif.h>
+
+	.align	5
+
+ /*!
+ *
+ * Perform a software reset of the PC20x device.
+ *
+ * Note: We will never return from this function
+ *
+ */
+.globl reset_cpu
+reset_cpu:
+
+        /* Set up the new reset exception vector in the procif */
+        ldr     r2, = PC20X_PROCIF_BASE                 
+        mov     r3, #PC20X_BOOTABLE_FLASH_BASE
+        str     r3, [r2,#ProcifExtTabEnt0RegOffset]
+        
+        /* Replace the default reset exception instruction at addr 0xFFFF0000 */
+        ldr     r3, ldr_instruction
+        str     r3, [r2]                                
+        
+        /* Perform a software reboot */
+        mov     pc, r2                                  
+
+reset_loop_forever:
+
+        /* We will never return from this function */
+        b       reset_loop_forever                      
+
+ldr_instruction:
+
+        /* ldr pc,[0xffff0020]... */
+       .word 0xe59ff018                                 
diff --git a/cpu/arm926ejs/pc20x/serial.c b/cpu/arm926ejs/pc20x/serial.c
new file mode 100644
index 0000000..565ad12
--- /dev/null
+++ b/cpu/arm926ejs/pc20x/serial.c
@@ -0,0 +1,360 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+
+#ifdef CFG_DW_APB_UART
+
+#include <asm/arch/pc20x.h>
+#include <asm/arch/uart.h>
+
+#if !defined(CONFIG_CONS_INDEX)
+#error	"No console index specified."
+#elif (CONFIG_CONS_INDEX < 1) || (CONFIG_CONS_INDEX > 2)
+#error	"Invalid console index value specified."
+#endif
+
+/* Macros ------------------------------------------------------------------ */
+#define IO_WRITE(addr, val) (*(volatile unsigned int *)(addr) = (val))
+#define IO_READ(addr) (*(volatile unsigned int *)(addr))
+
+/* uart[] array is zero based whilst CONFIG_CONS_INDEX is '1' based */
+#define CONSOLE_PORT (CONFIG_CONS_INDEX - 1)
+
+/* Constants --------------------------------------------------------------- */
+static volatile unsigned char *const uart[] = {
+                                                (void *)PC20X_UART1_BASE,
+                                                (void *)PC20X_UART2_BASE
+                                              };
+
+/* Prototypes--------------------------------------------------------------- */
+/*!
+ *
+ * Write a character to the uart
+ *
+ * Note: This function will block if the Tx FIFO is full
+ *
+ * \param uartNumb Which uart to use
+ * \param c The character to output
+ *
+ */ 
+static void dwApbUart_putc (int uartNum, char c);
+
+/*!
+ *
+ * Read a character from the uart
+ *          
+ * Note: This function will block if the Rx FIFO is empty
+ *
+ * \param uartNumb Which uart to use   
+ */   
+static int dwApbUart_getc (int uartNum);
+
+/*!
+ *
+ * Test if there is a character available to be read from the uart
+ *
+ * \param uartNumb Which uart to use     
+ *
+ * \return 0 no character availbale to be read
+ *         1 character available to be read
+ *
+ */  
+static int dwApbUart_tstc (int uartNum);
+
+
+/* Functions --------------------------------------------------------------- */
+
+/*****************************************************************************
+ *
+ * serial_init()
+ *
+ * Purpose: Initialise the console uart
+ *
+ * Args:    
+ *
+ * Returns:
+ *
+ ****************************************************************************/
+int serial_init (void)
+{
+    unsigned int lcrRegister;
+
+    unsigned int baudRate = CONFIG_BAUDRATE;
+    unsigned int uartNum = CONSOLE_PORT;
+    unsigned int divisor;
+    unsigned int temp;
+    
+
+#ifdef CONFIG_PC20X_SIMULATION
+    /* If running in RTL simulation land, perform some test bench 'magic' */
+	
+    /* Program the 'TrickBox' to start up the uart baud rate clock */
+    *(volatile unsigned int *)(0xe0000058) = 0x1;
+
+    /* Program the 'TrickBox' to cross wire the two on chip uarts
+       Uart1 tx -> Uart2 rx
+       Uart1 rx <- Uart2 tx */
+    *(volatile unsigned int *)(0xe0000050) = 0x4;
+#endif
+
+    /* Setup the baud rate */
+    
+    /* Wait while the UART is busy... */
+    while ((IO_READ(uart[uartNum] + UartUartStatusRegOffset) & UartUartStatusBusyMask));
+
+    /* Set the Divisor Latch Access Bit in the Line Control Register */
+    lcrRegister = IO_READ(uart[uartNum] + UartLineCtrlRegOffset);
+    lcrRegister = lcrRegister | UartLineCtrlDLABMask;
+    IO_WRITE (uart[uartNum] + UartLineCtrlRegOffset, lcrRegister);
+  
+#ifdef CONFIG_PC20X_SIMULATION        
+    /* If running in RTL simulation land just set the baud rate to the highest value possible */
+
+    IO_WRITE (uart[uartNum] + UartDivisorLowRegOffset, 0x01);
+    IO_WRITE (uart[uartNum] + UartDivisorHighRegOffset, 0x00);
+    
+#else
+    /* Baud Rate = Baud Rate Gen Clock / (16 * divisor) */
+         
+    temp = 16 * baudRate;
+    divisor = CONFIG_DW_APB_UART_CLOCK / temp;
+    
+    IO_WRITE (uart[uartNum] + UartDivisorLowRegOffset, (divisor & UartDivisorMask));
+    IO_WRITE (uart[uartNum] + UartDivisorHighRegOffset, ((divisor >> 8) & UartDivisorMask));
+
+#endif        
+
+    /* Clear the Divisor Latch Access Bit in the Line Control Register */
+    lcrRegister = IO_READ(uart[uartNum] + UartLineCtrlRegOffset);
+    lcrRegister = lcrRegister  & ~(UartLineCtrlDLABMask); 
+    IO_WRITE (uart[uartNum] + UartLineCtrlRegOffset, lcrRegister);
+
+    /* Enable the Rx & Tx fifos */
+    IO_WRITE (uart[uartNum] + UartFIFOCtrlRegOffset, UartFIFOCtrlEnable);
+	        
+     /* Setup the UART for...
+       8 data bit word length
+       1 stop bit
+       parity disabled */
+                  
+    /* Wait while the UART is busy... */
+    while ((IO_READ(uart[uartNum] + UartUartStatusRegOffset) & UartUartStatusBusyMask)); 
+   
+    lcrRegister = IO_READ(uart[uartNum] + UartLineCtrlRegOffset);
+    lcrRegister = lcrRegister | UartLineCtrlDLS8bits;
+    lcrRegister = lcrRegister & UartLineCtrl1StopBit;
+    lcrRegister = lcrRegister & UartLineCtrlParityDisable;
+    IO_WRITE (uart[uartNum] + UartLineCtrlRegOffset, lcrRegister);
+	
+    return (0);
+}
+
+
+/*****************************************************************************
+ *
+ * serial_putc()
+ *
+ * Purpose: Write a character to the console uart 
+ *
+ * Args:    
+ *
+ * Returns:
+ *
+ ****************************************************************************/
+void serial_putc(const char c)
+{
+    if (c == '\n')
+    {
+        dwApbUart_putc (CONSOLE_PORT, '\r');
+    }
+
+    dwApbUart_putc (CONSOLE_PORT, c);
+}
+
+
+/*****************************************************************************
+ *
+ * serial_puts()
+ *
+ * Purpose: Write a string to the console uart 
+ *
+ * Args:    
+ *
+ * Returns:
+ *
+ ****************************************************************************/
+
+void serial_puts(const char *s)
+{
+
+    while (*s)
+    {
+        serial_putc(*s++);
+    }
+        
+}
+
+
+/*****************************************************************************
+ *
+ * serial_getc()
+ *
+ * Purpose: Read a character from the console uart 
+ *
+ * Args:    
+ *
+ * Returns:
+ *
+ ****************************************************************************/
+
+int serial_getc(void)
+{
+	
+    return dwApbUart_getc(CONSOLE_PORT);
+    
+}
+
+
+/*****************************************************************************
+ *
+ * serial_tstc()
+ *
+ * Purpose: Test to see if there are any characters availale to be read
+ *          from the console uart 
+ *
+ * Args:    
+ *
+ * Returns: 0 - no character availbale in the Rx FIFO
+ *          1 - character available in the Rx FIFO
+ *
+ ****************************************************************************/
+int serial_tstc(void)
+{
+
+    return dwApbUart_tstc(CONSOLE_PORT);
+
+}
+
+
+/*****************************************************************************
+ *
+ * serial_setbtg()
+ *
+ * Purpose: set the uart baud rate. 
+ *
+ * Args:    
+ *
+ * Returns: 
+ *
+ ****************************************************************************/
+void serial_setbrg(void)
+{
+	/* Not used right now ! */
+}
+
+static void dwApbUart_putc (int uartNum, char c)
+{
+	
+    /* Wait until there is space in the Tx FIFO... */
+	
+    while (!(IO_READ(uart[uartNum] + UartLineStatusRegOffset) & UartLineStatusTHREMask));
+    
+    /* Send the character */
+    IO_WRITE (uart[uartNum] + UartTXHoldingRegOffset, c);
+}
+      
+static int dwApbUart_getc (int uartNum)
+{
+
+    /* Wait until there is a character in the Rx FIFO... */
+    while (!dwApbUart_tstc(CONSOLE_PORT));
+
+    /* Go and read a character... */
+    return (IO_READ (uart[uartNum] + UartRXBufferRegOffset));
+    
+}
+
+static int dwApbUart_tstc (int uartNum)
+{
+
+    return (IO_READ (uart[uartNum] + UartLineStatusRegOffset) & UartLineStatusDataReadyMask);
+
+}
+
+
+/* Used to turn U-Boot booting into a self-checking testcase for the Firecracker simulation environment */
+
+void uart2_serial_init(void)
+{
+	int lcrRegister;
+
+	/* Setup uart2 in an identical fashion to uart 1 */
+         
+       	/* Set up the baud rate divisor registers */
+ 
+	/*   Wait while UART is busy... */
+        while ((*(volatile unsigned int *)(PC20X_UART2_BASE + UartUartStatusRegOffset) & UartUartStatusBusyMask));
+
+	/*   Set DLAB bit in LCR */
+        lcrRegister = *(volatile unsigned int *)(PC20X_UART2_BASE + UartLineCtrlRegOffset);
+	lcrRegister = lcrRegister | UartLineCtrlDLABMask; 
+        *(volatile unsigned int *)(PC20X_UART2_BASE + UartLineCtrlRegOffset) = lcrRegister;
+  
+	/*   Write to the DLL register */
+        *(volatile unsigned int *)(PC20X_UART2_BASE + UartDivisorLowRegOffset) = 0x01;
+
+        /*   Clear DLAB bit in LCR */
+        lcrRegister = *(volatile unsigned int *)(PC20X_UART2_BASE + UartLineCtrlRegOffset);
+	lcrRegister = lcrRegister  & ~(UartLineCtrlDLABMask); 
+        *(volatile unsigned int *)(PC20X_UART2_BASE + UartLineCtrlRegOffset) = lcrRegister;
+
+	/* Setup the FIFO Control Register  - Enable the Rx / Tx fifos */
+        *(volatile unsigned int *)(PC20X_UART2_BASE + UartFIFOCtrlRegOffset) = 0x01;
+
+	/* Setup the Line Control Register */
+	
+	/*   Wait while UART is busy... */
+        while ((*(volatile unsigned int *)(PC20X_UART2_BASE + UartUartStatusRegOffset) & UartUartStatusBusyMask));
+        
+	/*   Setup for 8 data bit word length */
+	*(volatile unsigned int *)(PC20X_UART2_BASE + UartLineCtrlRegOffset) |= UartLineCtrlDLS8bits;
+}
+
+void uart2_send_command (void)
+{
+
+	while ( ! (*(volatile unsigned int *)(PC20X_UART2_BASE + UartLineStatusRegOffset) & UartLineStatusTHREMask));
+
+	/* Write a '?' character to the Tx FIFO... */
+        *(char *)(PC20X_UART2_BASE + UartTXHoldingRegOffset) = '?';
+
+	while ( ! (*(volatile unsigned int *)(PC20X_UART2_BASE + UartLineStatusRegOffset) & UartLineStatusTHREMask));
+
+	/* Write a '\n' character to the Tx FIFO... */
+        *(char *)(PC20X_UART2_BASE + UartTXHoldingRegOffset) = '\n';
+}
+
+#endif
diff --git a/cpu/arm926ejs/pc20x/timer.c b/cpu/arm926ejs/pc20x/timer.c
new file mode 100644
index 0000000..075f20e
--- /dev/null
+++ b/cpu/arm926ejs/pc20x/timer.c
@@ -0,0 +1,123 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file timer.c
+* \brief Useful functions for timer implementation.
+*
+* Copyright (c) 2006-2008 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/*
+ * (C) Copyright 2003
+ * Texas Instruments <www.ti.com>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * (C) Copyright 2002-2004
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * (C) Copyright 2004
+ * Philippe Robin, ARM Ltd. <philippe.robin@arm.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <arm926ejs.h>
+#include <asm/arch/timer.h>
+
+/*
+ * The timer is a decrementer, it runs at a frequency of CONFIG_SYS_HZ.
+ */
+
+/* We have CONFIG_SYS_HZ timer ticks per second */
+#define TICKS_PER_HZ        (CONFIG_SYS_HZ)
+
+/* The number of clock ticks per 1 uS */
+#define TICKS_PER_US        (TICKS_PER_HZ / (1000 * 1000))
+
+/* The number of clock ticks per 'x' uS */
+#define USEC_TO_COUNT(x)    ((x) * TICKS_PER_US)
+
+/* The time (in seconds) for 'x' timer ticks */
+#define TICKS_TO_HZ(x)	    ((x) / TICKS_PER_HZ)
+
+/* Macro to read the 32 bit timer.
+ * Since the timer decrements, we invert the read value
+ * to give us an incrementing count value.
+ */
+#define READ_TIMER()        ( ~(*(volatile unsigned int *)\
+                                (CFG_TIMERBASE +\
+                                 TimerNCurrentValueRegOffset(0))) )
+
+/* Timer init function */
+int timer_init(void)
+{
+	/* Our timer will have already been started,
+         * therefore we do nothing.
+         */
+
+        return 0;
+}
+
+/* Restart counting from 0 */
+void reset_timer (void)
+{
+        /* Our timer is a free running timer,
+         * we never restart it.
+         */
+}
+
+/* Return how many HZ passed since "base" */
+ulong get_timer (ulong base)
+{
+	return  TICKS_TO_HZ(READ_TIMER()) - base;
+}
+
+/* Delay 'usec' micro seconds */
+void udelay (unsigned long usec)
+{
+	ulong current, end;
+
+	/* Read the current timer value */
+        current = READ_TIMER();
+
+        /* Work out what the final timer value needs to be */
+	end = current + USEC_TO_COUNT(usec);
+
+        while ((signed)(end - READ_TIMER()) > 0)
+        {
+            /* Wait while counting... */
+	    continue;
+        }
+}
diff --git a/cpu/arm926ejs/pc302/Makefile b/cpu/arm926ejs/pc302/Makefile
new file mode 100644
index 0000000..d162b49
--- /dev/null
+++ b/cpu/arm926ejs/pc302/Makefile
@@ -0,0 +1,66 @@
+#/*****************************************************************************
+# * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+# *****************************************************************************/
+ 
+#/*!
+#* \file
+#* \brief Makefile
+#*
+#* Copyright (c) 2006-2009 picoChip Designs Ltd
+#*
+#* This program is free software; you can redistribute it and/or modify
+#* it under the terms of the GNU General Public License version 2 as
+#* published by the Free Software Foundation.
+#*
+#* All enquiries to support@picochip.com
+#*/ 
+
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).a
+
+COBJS	= emac.o serial.o timer.o spi.o utilities.o
+COBJS 	+= pc302_gpio.o
+COBJS 	+= cmd_pc302_gpio.o
+SOBJS	= reset.o remap.o
+
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+START	:= $(addprefix $(obj),$(START))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/cpu/arm926ejs/pc302/cmd_pc302_gpio.c b/cpu/arm926ejs/pc302/cmd_pc302_gpio.c
new file mode 100644
index 0000000..2d600c2
--- /dev/null
+++ b/cpu/arm926ejs/pc302/cmd_pc302_gpio.c
@@ -0,0 +1,117 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file cmd_pc302_gpio.c
+* \brief This file implements some test commands for the gpio pins on
+*        the PC302 device.
+*
+* Copyright (c) 2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+
+#ifdef CONFIG_CMD_PC302_GPIO
+
+#include <command.h>
+#include <asm/arch/utilities.h>
+#include <asm/arch/pc302_gpio.h>
+
+int do_gpioset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+
+    int pin, value, ret;
+
+    /* We need three arguments */
+    if (argc < 3)
+    {
+        goto usage;
+    }
+
+    pin = simple_strtoul(argv[1], NULL, 0);
+    value = simple_strtoul(argv[2], NULL, 0);
+
+    /* Check the range on the 'pin' value */
+    if ( (pin < PC302_GPIO_PIN_ARM_0) ||
+         (pin > PC302_GPIO_PIN_SDGPIO_15) )
+    {
+        /* Oops, we have an out of range pin specified */
+        printf ("pin out of range !\n");
+        return 1;
+    }
+
+    /* Check on the 'value' specified */
+    if ( (value < 0) ||
+         (value > 1) )
+    {
+        /* Oops, we have an out of range value specified */
+        printf ("value out of range !\n");
+        return 1;
+    }
+
+    /* Initialise the gpio library */
+    ret = pc302_gpio_init();
+    if (ret != 0)
+    {
+        /* We have a problem initialising the gpio library */
+        printf ("Can't initialise the gpio library !\n");
+        return 1;
+    }
+
+    /* Request the gpio pin */
+    ret = pc302_gpio_request (pin, "pin");
+    if (ret != 0)
+    {
+        /* We have a problem requesting the gpio pin */
+        printf ("Can't request gpio pin %d !\n", pin);
+        return 1;
+    }
+
+    /* Set the gpio pin to be an output */
+    ret = pc302_gpio_direction_output (pin, 0);
+    if (ret != 0)
+    {
+        /* We have a problem setting the gpio pin as an output */
+        printf ("Can't set gpio pin %d as an output !\n", pin);
+        pc302_gpio_free (pin);
+        return 1;
+    }
+
+    /* Set the value of the gpio pin */
+    ret = pc302_gpio_set_value( pin, value);
+    if (ret != 0)
+    {
+        /* We have a problem setting the value of the gpio pin */
+        printf ("Can't set value of gpio pin %d !\n", pin);
+        pc302_gpio_free (pin);
+        return 1;
+    }
+
+    /* Free the pin */
+    pc302_gpio_free (pin);
+
+    return 0;
+
+usage:
+    printf("Usage:\n%s\n", cmdtp->usage);
+    return 1;
+}
+
+/***************************************************/
+
+U_BOOT_CMD(
+	gpioset, 3, 0, do_gpioset,
+	"gpioset - set a gpio pin high or low\n",
+	"pin value - 'pin' is the gpio pin to set\n"
+        "                    'value' is 1 or 0\n"
+);
+
+#endif /* CONFIG_CMD_PC302_GPIO */
diff --git a/cpu/arm926ejs/pc302/emac.c b/cpu/arm926ejs/pc302/emac.c
new file mode 100644
index 0000000..edc7367
--- /dev/null
+++ b/cpu/arm926ejs/pc302/emac.c
@@ -0,0 +1,805 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file emac.c
+* \brief Ethernet driver for the PC302.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+
+#ifdef CFG_DW_EMAC
+
+#include <malloc.h>
+#include <net.h>
+#include <asm/io.h>
+#include <asm/arch/pc302.h>
+#include <asm/arch/emac.h>
+#include <asm/arch/mii_phy.h>
+#include <asm/arch/utilities.h>
+
+/* Macros ------------------------------------------------------------------ */
+
+/* !
+ *  \brief Timeout value (in uS) for various EMAC operations
+ */
+#define EMAC_TX_TIMEOUT             (1000)
+
+/* !
+ *  \brief Timeout value (in uS) for various PHY operations
+ */
+#define EMAC_PHY_TIMEOUT            (4000000)
+
+/* !
+ *  \brief Length (in bytes) of a MAC address
+ */
+#define EMAC_LENGTH_OF_MAC_ADDRESS  (6)
+
+/* !
+ *  \brief Default receive and transmit ring lengths
+ */
+#define EMAC_RX_NUM_DESCRIPTOR      (8)
+#define EMAC_TX_NUM_DESCRIPTOR      (2)
+#define EMAC_DESCRIPTOR_BUF_SIZE    (2048)
+
+/* !
+ *  \brief Values used in the emac_priv structure
+ */
+#define EMAC_PHY_SPEED_10           (0)
+#define EMAC_PHY_SPEED_100          (1)
+#define EMAC_PHY_DUPLEX_HALF        (0)
+#define EMAC_PHY_DUPLEX_FULL        (1)
+#define EMAC_PHY_LINK_DOWN          (0)
+#define EMAC_PHY_LINK_UP            (1)
+#define EMAC_PHY_AUTO_NEG_COMPLETE  (1)
+
+/* !
+ *  \brief Macros used to read from, and write to, emac registers
+ */
+#define EMAC_READ(__offset) \
+                 (*((volatile u32*)(PC302_EMAC_BASE + __offset)))
+
+#define EMAC_WRITE(__value, __offset) \
+                  (*((volatile u32*)(PC302_EMAC_BASE + __offset)) = __value)
+
+/*!
+ * \brief Define the auto-negotiation advertisment register
+ *        value.
+ *
+ * Note: This advertises 100 mpbs capability only.
+ */
+#define PHY_AUTO_NEG_ADVERT_VALUE   (0x0181)
+
+/* Constants --------------------------------------------------------------- */
+
+/* !
+ *  \brief This structure defines the Tx and Rx descriptor format
+ */
+struct emac_dma_descriptor
+{
+    unsigned int buffer;
+    unsigned int status;
+};
+
+/* !
+ *  \brief This structure is used to hold private data for the network code
+ */
+struct emac_priv
+{
+    /* Useful phy state */
+    unsigned int auto_negotiation;
+    unsigned int speed;
+    unsigned int duplex;
+    unsigned int link;
+
+    /* Rx descriptor count */
+    unsigned int rx_desc;
+
+    /* Tx descriptor count */
+    unsigned int tx_desc;
+};
+
+/* !
+ *  \brief Statically assign some memory for the Rx & Tx,
+ *         descriptors, and the rx buffers
+ */
+volatile static struct
+emac_dma_descriptor rx_descriptor[EMAC_RX_NUM_DESCRIPTOR];
+
+volatile static struct
+emac_dma_descriptor tx_descriptor[EMAC_TX_NUM_DESCRIPTOR];
+
+/* The rx buffer has to be 64 bit aligned otherwise very bad things happen */
+__attribute__((aligned(8))) static unsigned char
+rx_buffer[EMAC_RX_NUM_DESCRIPTOR][EMAC_DESCRIPTOR_BUF_SIZE];
+
+/* Types ------------------------------------------------------------------- */
+
+/* Prototypes--------------------------------------------------------------- */
+
+/*!
+ *
+ * Read a register in a phy connected to the emac management port.
+ *
+ * \param phy_id The phy id of the phy to access
+ * \param register_number The register to read from
+ * \return The value read
+ *
+ */
+static unsigned short emac_mii_read(unsigned int phy_id,
+                                    unsigned int register_number);
+
+/*!
+ *
+ * Write to a register in a phy connected to the emac management port.
+ *
+ * \param phy_id The phy id of the phy to access
+ * \param register_number The register to write to
+ * \param data The data to write
+ *
+ */
+static void emac_mii_write(unsigned int phy_id,
+                           unsigned int register_number,
+                           unsigned short data);
+/*!
+ * Initialise the phy connected to the emac management port.
+ *
+ * \param dev Pointer to the eth_device structure
+ *
+ */
+static int emac_init_phy(struct eth_device *dev);
+
+/*!
+ *
+ * Obtain the link speed from the phy.
+ *
+ * \param dev Pointer to the eth_device structure
+ *
+ */
+static void emac_phy_get_link_speed(struct eth_device *dev);
+
+/*!
+ *
+ * Obtain the link status from the phy.
+ *
+ * \param dev Pointer to the eth_device structure
+ *
+ */
+static void emac_phy_get_link_status(struct eth_device *dev);
+
+/*!
+ *
+ * emac_set_mac_addr()
+ *
+ * Set up the MAC address in the emac.
+ *
+ * \param dev Pointer to the eth_device structure
+ *
+ */
+static void emac_set_mac_addr(struct eth_device *dev);
+
+/*!
+ *
+ * Initialise the emac registers.
+ *
+ * \param dev Pointer to the eth_device structure
+ *
+ */
+static void emac_startup(struct eth_device *dev);
+
+/*!
+ *
+ * Initialise the emac buffer descriptors and phy.
+ *
+ * \param dev Pointer to the eth_device structure
+ * \param bis Pointer to the board init structure
+ * \return Zero on success, non zero on error
+ *
+ */
+static int emac_open(struct eth_device *dev, bd_t *bis);
+
+/*!
+ *
+ * Receive a packet
+ *
+ * \param dev Pointer to the eth_device structure
+ * \return Zero on success, non zero on error
+ *
+ */
+static int emac_rx_packet(struct eth_device *dev);
+
+/*!
+ *
+ * Transmit a packet
+ *
+ * \param dev Pointer to the eth_device structure
+ * \param packet Pointer to the packet data to transmit
+ * \param length  Length (in bytes) of the packet to send
+ * \return Zero on success, non zero on error
+ *
+ */
+static int emac_tx_packet(struct eth_device *dev,
+                          volatile void *packet,
+                          int length);
+
+/*!
+ *
+ *  Stop the emac
+ *
+ * \param dev Pointer to the eth_device structure
+ *
+ */
+static void emac_halt(struct eth_device *dev);
+
+/*!
+ *
+ * Initialise and register the network driver with the U-Boot network code.
+ *
+ * \param bis Pointer to the board init structure
+ *
+ */
+void pc302_eth_initialize(bd_t * bis);
+
+/* Functions --------------------------------------------------------------- */
+
+static unsigned short emac_mii_read(unsigned int phy_id,
+                                    unsigned int register_number)
+{
+    unsigned int write_data = 0x60020000;
+    unsigned int phy_management_idle = 0;
+    unsigned short value_read = 0;
+
+    /* Mask input parameters */
+    phy_id &= EMAC_PHY_ID_MASK;
+    register_number &= EMAC_PHY_REG_MASK;
+
+    write_data |= ((phy_id << EMAC_PHY_ID_SHIFT) |
+                  (register_number << EMAC_PHY_REG_SHIFT));
+
+    EMAC_WRITE(write_data, EMAC_PHY_MAINTAIN_REG_OFFSET);
+
+    /* Wait for the phy access to complete */
+    do
+    {
+        phy_management_idle = EMAC_READ(EMAC_NETWORK_STATUS_REG_OFFSET);
+        phy_management_idle &= EMAC_PHY_MANAGEMENT_IDLE;
+    }
+    while(!phy_management_idle);
+
+    /* Read back the data obtained from the phy */
+    value_read = (unsigned short)EMAC_READ(EMAC_PHY_MAINTAIN_REG_OFFSET);
+
+    return(value_read);
+}
+
+static void emac_mii_write(unsigned int phy_id,
+                           unsigned int register_number,
+                           unsigned short data)
+{
+    unsigned int write_data = 0x50020000;
+    unsigned int phy_management_idle = 0;
+
+    /* Mask input parameters */
+    phy_id &= EMAC_PHY_ID_MASK;
+    register_number &= EMAC_PHY_REG_MASK;
+
+    write_data |= ((phy_id << EMAC_PHY_ID_SHIFT) |
+                   (register_number << EMAC_PHY_REG_SHIFT) | data);
+    EMAC_WRITE(write_data, EMAC_PHY_MAINTAIN_REG_OFFSET);
+
+    /* Wait for the phy access to complete */
+    do
+    {
+        phy_management_idle = EMAC_READ(EMAC_NETWORK_STATUS_REG_OFFSET);
+        phy_management_idle &= EMAC_PHY_MANAGEMENT_IDLE;
+    }
+    while (!phy_management_idle);
+}
+
+static int emac_init_phy(struct eth_device *dev)
+{
+    struct emac_priv *priv = dev->priv;
+    unsigned int network_control_register = 0;
+    unsigned int network_config_register = 0;
+    unsigned short phy_control = 0;
+
+    /* Initialise the phy status parameters in the private data structure */
+    priv->auto_negotiation = ~(EMAC_PHY_AUTO_NEG_COMPLETE);
+    priv->link = EMAC_PHY_LINK_DOWN;
+    priv->speed = EMAC_PHY_SPEED_10;
+    priv->duplex = EMAC_PHY_DUPLEX_HALF;
+
+    /* Set phy management MDC Clock to 200 MHz (pclk) / 96 */
+    network_config_register = EMAC_READ(EMAC_NETWORK_CFG_REG_OFFSET);
+    network_config_register &= EMAC_MDC_CLOCK_DIV_MASK;
+    network_config_register |= EMAC_MDC_CLOCK_DIV_96;
+    EMAC_WRITE(network_config_register, EMAC_NETWORK_CFG_REG_OFFSET);
+
+    /* Enable phy management */
+    network_control_register = EMAC_READ(EMAC_NETWORK_CTRL_REG_OFFSET);
+    network_control_register |= EMAC_MDIO_ENABLE;
+    EMAC_WRITE(network_control_register, EMAC_NETWORK_CTRL_REG_OFFSET);
+
+    /* If we are running on PC302 Rev D silicon and we are using a
+     * Reduced MII (RMII) connected Ethernet Phy then we need the
+     * link speed to be 100 mbps.
+     */
+    if ((pc302_read_device_revision() == PC302_REV_D) &&
+        pc302_get_rmii_enabled())
+    {
+        /* Are we already set for 100 mpbs ? */
+        emac_phy_get_link_speed(dev);
+        if (priv->speed == EMAC_PHY_SPEED_100)
+        {
+            /* No need to do anything */
+        }
+        else
+        {
+            /* Setup the phy auto-negotiation advertisment register */
+            emac_mii_write(CONFIG_PHY_ADDR, PHY_ANAR,
+                           PHY_AUTO_NEG_ADVERT_VALUE);
+
+            /* Re-start auto-negotiation */
+            emac_mii_write(CONFIG_PHY_ADDR, PHY_BMCR,
+                           (PHY_BMCR_AUTO_NEG_ENABLE | PHY_BMCR_RESTART_NEG));
+
+            /* Allow some time for the auto-negotiation process to start */
+            udelay(100);
+        }
+    }
+
+    emac_phy_get_link_status(dev);
+
+    if (priv->link == EMAC_PHY_LINK_DOWN)
+    {
+        /* Oops, no valid link established, time to bail out */
+        return (1);
+    }
+    else
+    {
+        /* We have a valid link established */
+
+        /* Obtain the link speed */
+        emac_phy_get_link_speed(dev);
+
+        /* Obtain the link duplex setting */
+        phy_control = emac_mii_read(CONFIG_PHY_ADDR, PHY_BMCR);
+        if (phy_control & PHY_BMCR_FULL_DUPLEX)
+        {
+            priv->duplex = EMAC_PHY_DUPLEX_FULL;
+        }
+    }
+
+    /* Report the phy setup */
+    if (priv->speed == EMAC_PHY_SPEED_100)
+    {
+        printf("%s: 100Mbit/s\n", dev->name);
+    }
+    else
+    {
+        printf("%s: 10Mbit/s\n", dev->name);
+    }
+
+    if (priv->link == EMAC_PHY_DUPLEX_FULL)
+    {
+        printf("%s: Full-duplex mode\n", dev->name);
+    }
+    else
+    {
+        printf("%s: Half-duplex mode\n", dev->name);
+    }
+
+    return(0);
+}
+
+static void emac_phy_get_link_speed(struct eth_device *dev)
+{
+    struct emac_priv *priv = dev->priv;
+    unsigned short phy_control = 0;
+    unsigned short phy_status = 0;
+    unsigned short ana = 0;
+    unsigned short anlpa = 0;
+    unsigned int timebase = 0;
+
+    /* Check to make sure the phy has auto-negotiation enabled */
+    phy_control = emac_mii_read(CONFIG_PHY_ADDR, PHY_BMCR);
+    if (phy_control & PHY_BMCR_AUTO_NEG_ENABLE)
+    {
+        /* Auto-negotiation is enabled
+         * now need to check on auto-negotiation progress
+         */
+        phy_status = emac_mii_read(CONFIG_PHY_ADDR, PHY_BMSR);
+        if (phy_status & PHY_BMSR_AUTO_NEG_ABLE)
+        {
+            /* The phy is auto-negotiation capable */
+            timebase = get_timer(0);
+            do
+            {
+                phy_status = emac_mii_read(CONFIG_PHY_ADDR, PHY_BMSR);
+                if (phy_status & PHY_BMSR_AUTO_NEG_COMPLETE)
+                {
+                    break;
+                }
+            }
+            while (get_timer (timebase) < EMAC_PHY_TIMEOUT);
+
+            /* Read the auto-negotiation advertisment register */
+            ana = emac_mii_read(CONFIG_PHY_ADDR, PHY_ANAR);
+
+            /* Read the auto-negotiation link partner ability register */
+            anlpa = emac_mii_read(CONFIG_PHY_ADDR, PHY_ANLPAR);
+
+            anlpa &= ana;
+
+            if (anlpa & (PHY_ANLPAR_100TXF | PHY_ANLPAR_100TXH))
+            {
+                priv->speed = EMAC_PHY_SPEED_100;
+            }
+            else
+            {
+                priv->speed = EMAC_PHY_SPEED_10;
+            }
+        }
+        else
+        {
+            /* We are not capable of performing auto-negotiation
+             * so we just get the speed settings from the Phy control reg
+             */
+            if (phy_control & PHY_BMCR_100MB)
+            {
+                priv->speed = EMAC_PHY_SPEED_100;
+            }
+            else
+            {
+                priv->speed = EMAC_PHY_SPEED_10;
+            }
+        }
+    }
+    else
+    {
+        /* Auto-negotiation is not enabled
+         * so we just get the speed settings from the Phy control reg
+         */
+        if (phy_control & PHY_BMCR_100MB)
+        {
+            priv->speed = EMAC_PHY_SPEED_100;
+        }
+        else
+        {
+            priv->speed = EMAC_PHY_SPEED_10;
+        }
+    }
+}
+
+static void emac_phy_get_link_status(struct eth_device *dev)
+{
+    struct emac_priv *priv = dev->priv;
+    unsigned  short phy_status = 0;
+    unsigned int timebase = 0;
+
+    /* Check on auto-negotiation progress */
+    phy_status = emac_mii_read(CONFIG_PHY_ADDR, PHY_BMSR);
+    if (phy_status & PHY_BMSR_AUTO_NEG_ABLE)
+    {
+        /* The phy is auto-negotiation capable */
+        timebase = get_timer(0);
+        do
+        {
+            phy_status = emac_mii_read(CONFIG_PHY_ADDR, PHY_BMSR);
+            if (phy_status & PHY_BMSR_AUTO_NEG_COMPLETE)
+            {
+                /* We have a successful auto-negotiation */
+                printf("%s: Auto-Negotiation complete\n", dev->name);
+                priv->auto_negotiation = EMAC_PHY_AUTO_NEG_COMPLETE;
+                break;
+            }
+        }
+        while (get_timer(timebase) < EMAC_PHY_TIMEOUT);
+    }
+
+    if (phy_status & PHY_BMSR_LINK_UP)
+    {
+        /* We have a valid link established */
+        printf("%s: Link up\n", dev->name);
+        priv->link = EMAC_PHY_LINK_UP;
+    }
+    else
+    {
+        /* We do not have a valid link established */
+        printf("%s: Link down !\n", dev->name);
+        priv->link = EMAC_PHY_LINK_DOWN;
+    }
+}
+
+static void emac_set_mac_addr(struct eth_device *dev)
+{
+    unsigned int mac_addr_bottom = 0;
+    unsigned int mac_addr_top = 0;
+
+    mac_addr_bottom = *((unsigned int *)dev->enetaddr);
+    mac_addr_top = *((unsigned short *)(dev->enetaddr + 4));
+
+    EMAC_WRITE(mac_addr_bottom, EMAC_SPEC_ADDR_1_BOT_31_0_REG_OFFSET);
+    EMAC_WRITE(mac_addr_top, EMAC_SPEC_ADDR_1_TOP_47_32_REG_OFFSET);
+}
+
+static void emac_startup(struct eth_device *dev)
+{
+    struct emac_priv *priv = dev->priv;
+    unsigned int network_config_register = 0;
+    unsigned int network_control_register = 0;
+    unsigned int dma_config_register = 0;
+
+    /* Make sure the Tx & Rx are halted */
+    network_control_register = EMAC_READ(EMAC_NETWORK_CTRL_REG_OFFSET);
+    network_control_register &= ~(EMAC_RX_ENABLE | EMAC_TX_ENABLE);
+    EMAC_WRITE(network_control_register, EMAC_NETWORK_CTRL_REG_OFFSET);
+
+    /* Setup the Rx Buffer Queue Base Address */
+    EMAC_WRITE((unsigned int)&rx_descriptor, EMAC_RX_BUFF_Q_BASE_ADDR_REG_OFFSET);
+
+    /* Setup the Tx Buffer Queue Base Address */
+    EMAC_WRITE((unsigned int)&tx_descriptor, EMAC_TX_BUFF_Q_BASE_ADDR_REG_OFFSET);
+
+    /* Setup the size of the DMA Receive Buffer */
+    dma_config_register = EMAC_READ(EMAC_DMA_CFG_REG_OFFSET);
+    dma_config_register &= ~(EMAC_DMA_RX_BUFFER_SIZE_MASK);
+    dma_config_register |= EMAC_DMA_RX_BUFFER_SIZE;
+    EMAC_WRITE(dma_config_register, EMAC_DMA_CFG_REG_OFFSET);
+
+    /* Setup the Network Configuration Register */
+    network_config_register = EMAC_READ(EMAC_NETWORK_CFG_REG_OFFSET);
+    network_config_register |= EMAC_64_BIT_AMBA_DATA_BUS_WITDH;
+    network_config_register |= EMAC_LENGTH_FIELD_ERROR_FRAME_DISCARD;
+    network_config_register |= EMAC_FCS_REMOVE;
+
+    if (priv->duplex == EMAC_PHY_DUPLEX_FULL)
+    {
+        network_config_register |= EMAC_FULL_DUPLEX;
+    }
+    else
+    {
+        network_config_register &= ~(EMAC_FULL_DUPLEX);
+    }
+
+    if (priv->speed == EMAC_PHY_SPEED_100)
+    {
+        network_config_register |= EMAC_SPEED_100_MBPS;
+    }
+    else
+    {
+        network_config_register &= ~(EMAC_SPEED_100_MBPS);
+    }
+
+    EMAC_WRITE(network_config_register, EMAC_NETWORK_CFG_REG_OFFSET);
+
+    /* Setup the Network Control Register */
+    network_control_register = EMAC_READ(EMAC_NETWORK_CTRL_REG_OFFSET);
+    network_control_register |= (EMAC_RX_ENABLE | EMAC_TX_ENABLE);
+    EMAC_WRITE(network_control_register, EMAC_NETWORK_CTRL_REG_OFFSET);
+}
+
+static int emac_open(struct eth_device *dev, bd_t *bis)
+{
+    struct emac_priv *priv = dev->priv;
+    unsigned int i = 0;;
+    unsigned int buffer_address = 0;
+    unsigned int return_code = 0;
+
+    /* Initialise the Rx descriptor count */
+    priv->rx_desc = 0;
+
+    /* Initialise the Tx descriptor count */
+    priv->tx_desc = 0;
+
+    /* Initialise the Rx descriptors */
+    for (i = 0; i < EMAC_RX_NUM_DESCRIPTOR; i++)
+    {
+        buffer_address = (unsigned int)&rx_buffer[i][0];
+        if (i == (EMAC_RX_NUM_DESCRIPTOR - 1))
+        {
+            /* we are on the last descriptor entry */
+            buffer_address |= EMAC_RX_DESC_WRAP;
+        }
+        rx_descriptor[i].buffer = buffer_address;
+        rx_descriptor[i].status = 0;
+    }
+
+    /* Initialise the Tx descriptors */
+    for (i = 0; i < EMAC_TX_NUM_DESCRIPTOR; i++)
+    {
+        tx_descriptor[i].buffer = 0;
+        tx_descriptor[i].status = EMAC_TX_DESC_HOST_OWN;
+
+        if (i == (EMAC_TX_NUM_DESCRIPTOR - 1))
+        {
+            /* we are on the last descriptor entry */
+            tx_descriptor[i].status |= EMAC_TX_DESC_WRAP;
+        }
+    }
+
+    /* Check out the phy status */
+    return_code = emac_init_phy(dev);
+    if (return_code != 0)
+    {
+        /* Oops, we've had an error */
+        return(return_code);
+    }
+
+    /* Initialise the emac registers */
+    emac_startup(dev);
+
+    return (0);
+}
+
+static int emac_rx_packet(struct eth_device *dev)
+{
+    struct emac_priv *priv = dev->priv;
+    unsigned int start_of_frame = 0;
+    unsigned int end_of_frame = 0;
+    unsigned int frame_error = 0;
+    unsigned int length = 0;
+    void * buffer_start;
+
+    if (rx_descriptor[priv->rx_desc].buffer & EMAC_RX_DESC_HOST_OWN)
+    {
+        /* We have some received data */
+
+        /* Make sure we have a whole frame */
+        start_of_frame = rx_descriptor[priv->rx_desc].status & EMAC_RX_DESC_START_OF_FRAME;
+        end_of_frame = rx_descriptor[priv->rx_desc].status & EMAC_RX_DESC_END_OF_FRAME;
+        if (start_of_frame && end_of_frame)
+        {
+            /* We have a complete frame */
+            length = rx_descriptor[priv->rx_desc].status & EMAC_RX_DESC_LENGTH_MASK;
+
+            /* Noodle the buffer start address for the higher level network stack
+               The start address should be 8 byte aligned, also bits 0 & 1 can be
+               set by the emac, so these need to be masked out as well */
+
+            buffer_start = (void *)
+                           (rx_descriptor[priv->rx_desc].buffer & 0xFFFFFFF8);
+
+            /* Send received packet to the higher network layers */
+            NetReceive(buffer_start, length);
+        }
+        else
+        {
+            /* Oops, not a complete frame */
+            frame_error++;
+        }
+
+        /* Reclaim the buffer just used */
+        rx_descriptor[priv->rx_desc].buffer &= ~(EMAC_RX_DESC_HOST_OWN);
+
+        /* Increment the Rx descriptor counter */
+        priv->rx_desc++;
+        if (priv->rx_desc == EMAC_RX_NUM_DESCRIPTOR)
+        {
+            /* We have exhausted the supply of Rx descriptors */
+            priv->rx_desc = 0;
+        }
+    }
+
+    if (frame_error)
+    {
+        printf ("frame error\n");
+        return (1);
+    }
+
+    return(0);
+}
+
+static int emac_tx_packet(struct eth_device *dev,
+                          volatile void *packet,
+                          int length)
+{
+    struct emac_priv *priv = dev->priv;
+    unsigned int i = 0;
+    unsigned int network_control_register = 0;
+
+    /* Set up the Tx descriptor */
+
+    /* Make sure the wrap bit is set for the last descriptor */
+    if (priv->tx_desc == (EMAC_TX_NUM_DESCRIPTOR - 1))
+    {
+        /* we are on the last descriptor entry */
+        tx_descriptor[priv->tx_desc].status = EMAC_TX_DESC_WRAP;
+    }
+
+    tx_descriptor[priv->tx_desc].status |= length & EMAC_TX_BUFFER_LENGTH_MASK;
+    tx_descriptor[priv->tx_desc].status |= EMAC_TX_LAST_BUFFER;
+    tx_descriptor[priv->tx_desc].status &= ~(EMAC_TX_NO_CRC_APPEND);
+    tx_descriptor[priv->tx_desc].status &= ~(EMAC_TX_DESC_HOST_OWN);
+
+    /* Setup the Tx descriptor buffer */
+    tx_descriptor[priv->tx_desc].buffer = (unsigned int)packet;
+
+    /* Start the packet transmission */
+    network_control_register = EMAC_READ(EMAC_NETWORK_CTRL_REG_OFFSET);
+    network_control_register |= EMAC_START_TX;
+    EMAC_WRITE(network_control_register, EMAC_NETWORK_CTRL_REG_OFFSET);
+
+    /* Wait for transmission to complete */
+    for (i = 0; i <= EMAC_TX_TIMEOUT; i++)
+    {
+	if (tx_descriptor[priv->tx_desc].status & EMAC_TX_DESC_HOST_OWN)
+        {
+            /* The emac has completed transmission */
+            break;
+        }
+	udelay(1);
+    }
+
+    /* Increment the Tx descriptor counter */
+    priv->tx_desc++;
+    if (priv->tx_desc == EMAC_TX_NUM_DESCRIPTOR)
+    {
+        /* We have exhausted the supply of Tx descriptors */
+        priv->tx_desc = 0;
+    }
+
+    /* We could add some error reporting in here, but no one cares anyway */
+    return(0);
+}
+
+static void emac_halt(struct eth_device *dev)
+{
+    unsigned int status_register = 0;
+
+    /* Halt the Tx & Rx */
+    EMAC_WRITE(0, EMAC_NETWORK_CTRL_REG_OFFSET);
+
+    /* Clear the statistics counters */
+    EMAC_WRITE(EMAC_CLEAR_STATS_REGISTERS, EMAC_NETWORK_CTRL_REG_OFFSET);
+
+    /* Clear the Tx status registers */
+    status_register = EMAC_READ(EMAC_TX_STATUS_REG_OFFSET);
+    EMAC_WRITE(status_register, EMAC_TX_STATUS_REG_OFFSET);
+
+    /* Clear the Rx status registers */
+    status_register = EMAC_READ(EMAC_RX_STATUS_REG_OFFSET);
+    EMAC_WRITE(status_register, EMAC_RX_STATUS_REG_OFFSET);
+}
+
+void pc302_eth_initialize(bd_t * bis)
+{
+    struct eth_device *dev = NULL;
+    struct emac_priv *priv = NULL;
+
+    /* Create some storage for useful structures */
+    dev = (struct eth_device *) malloc(sizeof (*dev));
+    priv = (struct emac_priv *) malloc(sizeof (*priv));
+    dev->priv = priv;
+
+    sprintf(dev->name, "pc302_emac");
+
+    /* Reset the private data */
+    memset(priv, 0, sizeof(struct emac_priv));
+
+    /* Copy the hardware address of the interface */
+    memcpy(dev->enetaddr, bis->bi_enetaddr, EMAC_LENGTH_OF_MAC_ADDRESS);
+
+    /* Set the hardware MAC address */
+    emac_set_mac_addr(dev);
+
+    dev->init = emac_open;
+    dev->recv = emac_rx_packet;
+    dev->send = emac_tx_packet;
+    dev->halt = emac_halt;
+
+    /* Register our emac with the networking environment */
+    eth_register(dev);
+}
+
+#endif /* CFG_DW_EMAC */
diff --git a/cpu/arm926ejs/pc302/pc302_gpio.c b/cpu/arm926ejs/pc302/pc302_gpio.c
new file mode 100644
index 0000000..f86b698
--- /dev/null
+++ b/cpu/arm926ejs/pc302/pc302_gpio.c
@@ -0,0 +1,1354 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file pc302_gpio.c
+* \brief This file implements a driver for the GPIO pins on the picoChip PC302
+*        device. This includes both the ARM and SD GPIO.
+*
+* Copyright (c) 2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+#include <malloc.h>
+#include <asm/errno.h>
+#include <asm/arch/axi2cfg.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/pc302_gpio.h>
+#include <asm/arch/utilities.h>
+
+/* Include for BUG, BUG_ON */
+#include <linux/mtd/compat.h>
+
+/* Macros ------------------------------------------------------------------ */
+/** The number of pads available for GPIO. */
+#define PC302_GPIO_NUM_PADS ( 24 )
+
+/** The maximum length of a pin name. */
+#define PC302_GPIO_PIN_NAME_MAX ( 32 )
+
+/** The width of the arm gpio ports */
+#define PC302_ARM_GPIO_PORT_WIDTH   ( 8 )
+
+/** The AXI2PICO wake up command */
+#define PC302_AXI2PICO_WAKE_UP  ( 0 )
+
+/** The base address of SD-GPIO config registers in the AXI2Pico. */
+#define PC302_GPIO_SD_PIN_CONFIG_BASE   0x9800
+
+/** The base address of SD-GPIO analogue value registers in the AXI2Pico. */
+#define PC302_GPIO_SD_PIN_ANALOGUE_VALUE_BASE   0x9801
+
+/** The base address of SD-GPIO analogue rate registers in the AXI2Pico. */
+#define PC302_GPIO_SD_PIN_ANALOGUE_RATE_BASE    0x9802
+
+/** The address of the control value register in the AXI2Pico. */
+#define PC302_GPIO_SD_CONTROL_VAL_REG   0x9882
+
+/** The address of the output value register in the AXI2Pico. */
+#define PC302_GPIO_SD_OUTPUT_VAL_REG    0x9884
+
+/** The address of the input value register in the AXI2Pico. */
+#define PC302_GPIO_SD_INPUT_VAL_REG     0x9880
+
+/** The address of the sleep register in the AXI2Pico. */
+#define PC302_AXI2PICO_SLEEP_REG        0xA060
+
+/** The spacing between SD-GPIO config registers. */
+#define PC302_GPIO_SD_PIN_CONFIG_SPACING    4
+
+/**
+ * Macro to get the address of a config register for a SD-GPIO pin.
+ *
+ * \param _n The SD-GPIO pin number.
+ * \return Returns the base address of the register.
+ */
+#define PC302_GPIO_SD_PIN_CONFIG( _n ) \
+    PC302_GPIO_SD_PIN_CONFIG_BASE + ( _n * PC302_GPIO_SD_PIN_CONFIG_SPACING )
+
+/**
+ * Macro to get the address of a analogue rate register for a SD-GPIO pin.
+ *
+ * \param _n The SD-GPIO pin number.
+ * \return Returns the base address of the register.
+ */
+#define PC302_GPIO_SD_PIN_ANALOGUE_RATE( _n ) \
+    PC302_GPIO_SD_PIN_ANALOGUE_RATE_BASE + \
+        ( _n * PC302_GPIO_SD_PIN_CONFIG_SPACING )
+
+/**
+ * Macro to get the address of a analogue value register for a SD-GPIO pin.
+ *
+ * \param _n The SD-GPIO pin number.
+ * \return Returns the base address of the register.
+ */
+#define PC302_GPIO_SD_PIN_ANALOGUE_VAL( _n ) \
+    PC302_GPIO_SD_PIN_ANALOGUE_VALUE_BASE + \
+        ( _n * PC302_GPIO_SD_PIN_CONFIG_SPACING )
+
+/** Control source bit. */
+#define PC302_GPIO_SD_CONFIG_CS_MASK ~( 1 << 15 )
+
+/** Analogue not digital bit. */
+#define PC302_GPIO_SD_CONFIG_AND ( 1 << 14 )
+
+/** The mask for analogue converter size in the config register. */
+#define PC302_GPIO_SD_CONV_SZ_MASK ( 0xF )
+
+/** Soft reset lock bit. */
+#define PC302_GPIO_SD_CONFIG_SR_LOCK ( 1 << 13 )
+
+/** PC302 AXI2Pico CAEID. */
+#define PC302_AXI2PICO_CAEID    ( 0x00A8 )
+
+/** PC302 PAI CAEID. */
+#define PC302_PAI_CAEID         ( 0x0578 )
+
+/** The address of the sleep register in the PAI. */
+#define PC302_PAI_SLEEP_REG     ( 0xA060 )
+
+/** The PAI wake up command */
+#define PC302_PAI_WAKE_UP       ( 0 )
+
+/** Mask for valid bits in the PAI pai_io_ctrl register. */
+#define PC302_PAI_IO_CTRL_REG_MASK  ( 0xF )
+
+/** The address of the pai_io_ctrl register in the PAI. */
+#define PC302_PAI_IO_CTRL_REG   ( 0x0009 )
+
+/* Constants --------------------------------------------------------------- */
+/** Define some bit values for ARM_GPIO Muxing control */
+typedef enum
+{
+    PAI_GPIO_PIN_ARM_4 = 0xB,
+    PAI_GPIO_PIN_ARM_5 = 0xA,
+    PAI_GPIO_PIN_ARM_6 = 0x9,
+    PAI_GPIO_PIN_ARM_7 = 0x8,
+
+} pc302_pai_arm;
+
+/** Define some bit values for SDGPIO_GPIO Muxing control */
+typedef enum
+{
+    PAI_SDGPIO_PIN_ARM_4 = 0x7,
+    PAI_SDGPIO_PIN_ARM_5 = 0x6,
+    PAI_SDGPIO_PIN_ARM_6 = 0x5,
+    PAI_SDGPIO_PIN_ARM_7 = 0x4,
+
+} pc302_pai_sdgpio;
+
+/** GPIO pin type. */
+typedef enum
+{
+    PC302_GPIO_ARM,
+    PC302_GPIO_SD,
+
+} pc302gpio_pin_type;
+
+/** Private representation to store state of a GPIO pin. */
+struct pc302gpio_pin_allocation
+{
+    /** The pin number (not pad number). */
+    int pin_num;
+
+    /** Boolean flag for an input GPIO. */
+    int is_input;
+
+    /** Boolean flag for whether the pin is active. */
+    int enabled;
+
+    /** The pad number. */
+    int pad;
+
+    /** The name of the pin - filled in when the pin is requested. */
+    char name[ PC302_GPIO_PIN_NAME_MAX ];
+
+    /** The cached value of the pin. Used for output GPIO pins to remember the
+     * last value set. */
+    int value;
+
+    /** Analogue not digital flag. 0 == digital, non-zero == analogue. */
+    int a_not_d;
+};
+
+/**
+ * The current boot mode.
+ */
+static u32 boot_mode = 1;
+
+static struct pc302gpio_pin_allocation *pc302gpio_pads[ PC302_GPIO_NUM_PADS ];
+
+/* Prototypes--------------------------------------------------------------- */
+/**
+ * Get the pad number for the requested GPIO pin. This is needed as some pins
+ * are multiplexed and we need to check whether the pad is already in use
+ * either by the other shared pin or the EBI bus.
+ *
+ * \param pin The pin number being requested.
+ * \return Returns the pad number in the range 0 ... PC302_GPIO_NUM_PADS on
+ * success or negative on failure (invalid pin number, pad already in use
+ * etc).
+ */
+static int
+pc302gpio_get_pad( picoifGpioPinNum_t pin );
+
+/**
+ * Set the pin multiplexing for shared GPIO pins.
+ *
+ * \param gpio The pin to set the multiplex value of.
+ * \return Returns zero on success or if the multiplexing does not need to be
+ * set, non-zero on failure.
+ */
+static int
+set_pin_mux( unsigned gpio );
+
+/**
+ * Allocate a GPIO pin state structure.
+ *
+ * \param name The name of the pin (this can be anything - it can be the
+ * function of the pin or the application using it for example).
+ * \return Returns a pointer to the pin on success, NULL on failure.
+ */
+static struct pc302gpio_pin_allocation *
+pc302gpio_alloc_pin( const char *name );
+
+/**
+ * Set the direction of a GPIO pin.
+ *
+ * \param pin The pin to set the direction of.
+ * \param input Flag for input GPIO pins.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int
+pc302gpio_set_direction( struct pc302gpio_pin_allocation *pin,
+                         int input );
+
+/**
+ * Get the pin type.
+ *
+ * \param pin The pin to query.
+ * \return Returns the type of GPIO pin.
+ */
+static pc302gpio_pin_type
+pc302gpio_get_pin_type( struct pc302gpio_pin_allocation *pin );
+
+/**
+ * Given a GPIO pin number, find the PC302 representation of it.
+ *
+ * \param gpio The GPIO pin number.
+ * \return Returns a pointer to the internal representation.
+ */
+static struct pc302gpio_pin_allocation *
+pc302gpio_find_pin( unsigned gpio );
+
+/**
+ * Given a GPIO pin number, find the number of the pin in the block. The
+ * global enumeration of pin numbers include both types and are non
+ * contiguous. This function takes the pin number and turns it into a number
+ * in the range 0->15 for the block that controls it.
+ *
+ * \param pin The pin to query.
+ * \return Returns the block pin number on success, non-zero on failure.
+ */
+static int
+pc302gpio_pin_to_block_pin( struct pc302gpio_pin_allocation *pin );
+
+/**
+ * Set the value of an output SDGPIO pin.
+ *
+ * \param pin The pin to set the value of.
+ * \param value The value to set the pin to. Intepreted as non-zero == 1.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int
+pc302gpio_sd_set_value( struct pc302gpio_pin_allocation *pin,
+                        int value );
+
+/**
+ * Get the value of an input SDGPIO pin.
+ *
+ * \param pin The pin to get the value of.
+ * \return Returns the value read on success, negative on failure.
+ */
+static int
+pc302gpio_sd_get_value( struct pc302gpio_pin_allocation *pin );
+
+/**
+ * Get the value of an input ARM GPIO pin.
+ *
+ * \param pin The pin to get the value of.
+ * \return Returns the value read on success, negative on failure.
+ */
+static int
+pc302gpio_arm_get_value( struct pc302gpio_pin_allocation *pin );
+
+/**
+ * Set the direction of an SD-GPIO pin.
+ *
+ * \param pin The pin to set the direction of.
+ * \param input Boolean flag to set the pin to input.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int
+pc302gpio_sd_set_direction( struct pc302gpio_pin_allocation *pin,
+                            int input );
+
+/**
+ * Set the value of an output ARM GPIO pin.
+ *
+ * \param pin The pin to set the value of.
+ * \param value The value to set the pin to. Intepreted as non-zero == 1.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int
+pc302gpio_arm_set_value( struct pc302gpio_pin_allocation *pin,
+                         int value );
+
+/**
+ * Set the direction of an ARM GPIO pin.
+ *
+ * \param pin The pin to set the direction of.
+ * \param input Boolean flag to set the pin to input.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int
+pc302gpio_arm_set_direction( struct pc302gpio_pin_allocation *pin,
+                             int input );
+
+/**
+ * Set the value of a GPIO pin.
+ *
+ * \param pin The pin to set the value of.
+ * \param value The value to set.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int
+pc302gpio_set_value( struct pc302gpio_pin_allocation *pin,
+                     int value );
+
+/**
+ * Get the value of a GPIO pin.
+ *
+ * \param pin The pin to get the value of.
+ * \return Returns the value of the pin on success,
+ * negative on failure.
+ */
+static int
+pc302gpio_get_value( struct pc302gpio_pin_allocation *pin );
+
+/**
+ * Given a GPIO pin number, setup the pai gpio muxing.
+ *
+ * \param gpio The GPIO pin number.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int
+pc302gpio_pai_muxing( picoifGpioPinNum_t pin );
+
+/**
+ * Read the System Configuration Register
+ *
+ * \return The value read.
+ */
+static u32
+syscfg_read( void );
+
+/**
+ * Update the System Configuration Register
+ *
+ * \param mask Which bits we want to update
+ * \param val The new value for the bits we want to update.
+ */
+static void
+syscfg_update( u32 mask,
+               u32 val );
+
+/* Functions --------------------------------------------------------------- */
+static int
+pc302gpio_get_pad( picoifGpioPinNum_t pin )
+{
+    int ret = -EINVAL;
+
+    if ( pin >= PC302_GPIO_PIN_ARM_0 && pin <= PC302_GPIO_PIN_ARM_7 )
+    {
+        /* ARM GPIO */
+
+        /* If we are in parallel boot mode, then to use the bottom 4
+         * bits of ARM GPIO we need to noodle with the PAI block
+         * gpio mux control.*/
+        ret = -EIO;
+        if ( 0 == boot_mode && pin >= PC302_GPIO_PIN_ARM_4 )
+        {
+            ret = pc302gpio_pai_muxing( pin );
+            if ( 0 != ret )
+                goto out;
+        }
+
+        ret = pin - PC302_GPIO_PIN_ARM_0;
+    }
+    else if ( pin >= PC302_GPIO_PIN_SDGPIO_0 && pin <= PC302_GPIO_PIN_SDGPIO_7 )
+    {
+        /* SD-GPIO */
+
+        /* If we are in parallel boot mode, then to use the bottom 4
+         * bits of SDGPIO GPIO we need to noodle with the PAI block
+         * gpio mux control. */
+        ret = -EIO;
+        if ( 0 == boot_mode && pin >= PC302_GPIO_PIN_SDGPIO_4 )
+        {
+            ret = pc302gpio_pai_muxing( pin );
+            if ( 0 != ret )
+                goto out;
+        }
+
+        ret = pin - PC302_GPIO_PIN_ARM_0;
+    }
+    else if ( pin >= PC302_GPIO_PIN_ARM_8 &&
+              pin <= PC302_GPIO_PIN_ARM_15 )
+    {
+        /* Shared ARM GPIO */
+        ret = pin - PC302_GPIO_PIN_ARM_0;
+
+    }
+    else if ( pin >= PC302_GPIO_PIN_SDGPIO_8 &&
+              pin <= PC302_GPIO_PIN_SDGPIO_15 )
+    {
+        /* Shared SD-GPIO */
+        ret = pin - PC302_GPIO_PIN_ARM_0 - 8;
+    }
+
+out:
+    return ret;
+}
+
+static int
+set_pin_mux( unsigned gpio )
+{
+    int is_arm = 0;
+    u32 val;
+    unsigned shared_pin_num;
+
+    if ( ( gpio >= PC302_GPIO_PIN_ARM_0 && gpio <= PC302_GPIO_PIN_SDGPIO_7 ) )
+    {
+        if ( gpio == PC302_GPIO_PIN_SDGPIO_0 )
+        {
+            /* Need to set SDGPIO Freq_Synth Mux bit to 0 */
+            syscfg_update( AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK, (u32)0 );
+        }
+        return 0;
+    }
+
+    if ( ( gpio >= PC302_GPIO_PIN_ARM_8 && gpio <= PC302_GPIO_PIN_ARM_15 ) )
+        is_arm = 1;
+
+    switch ( gpio )
+    {
+        case PC302_GPIO_PIN_ARM_8 ... PC302_GPIO_PIN_ARM_15:
+            shared_pin_num = gpio - PC302_GPIO_PIN_ARM_8;
+            break;
+
+        case PC302_GPIO_PIN_SDGPIO_8 ... PC302_GPIO_PIN_SDGPIO_15:
+            shared_pin_num = gpio - PC302_GPIO_PIN_SDGPIO_8;
+            break;
+
+        default:
+            return -EINVAL;
+            BUG();
+    }
+
+    val = syscfg_read();
+    val &=
+        ~( 1 << ( shared_pin_num + AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO ) );
+    if ( is_arm )
+        val |= ( 1 << ( shared_pin_num +
+                        AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO ) );
+
+    syscfg_update( AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_MASK, val );
+
+    return 0;
+}
+
+static struct pc302gpio_pin_allocation *
+pc302gpio_alloc_pin( const char *name )
+{
+    struct pc302gpio_pin_allocation *p = malloc( sizeof( *p ) );
+
+    if ( p )
+    {
+        sprintf( p->name, "%s", name );
+        p->pin_num = -1;
+        p->pad = -1;
+        p->enabled = 0;
+        p->is_input = 0;
+        p->a_not_d = 0;
+    }
+
+    return p;
+}
+
+static pc302gpio_pin_type
+pc302gpio_get_pin_type( struct pc302gpio_pin_allocation *pin )
+{
+    int ret;
+    BUG_ON( !pin );
+
+    switch ( pin->pin_num )
+    {
+        case PC302_GPIO_PIN_ARM_0 ... PC302_GPIO_PIN_ARM_7:
+        case PC302_GPIO_PIN_ARM_8 ... PC302_GPIO_PIN_ARM_15:
+            ret = PC302_GPIO_ARM;
+            break;
+
+        case PC302_GPIO_PIN_SDGPIO_0 ... PC302_GPIO_PIN_SDGPIO_7:
+        case PC302_GPIO_PIN_SDGPIO_8 ... PC302_GPIO_PIN_SDGPIO_15:
+            ret = PC302_GPIO_SD;
+            break;
+
+        default:
+            ret = -EINVAL;
+            break;
+    }
+
+    return ret;
+}
+
+static int
+pc302gpio_pin_to_block_pin( struct pc302gpio_pin_allocation *pin )
+{
+    unsigned ret;
+
+    BUG_ON( NULL == pin );
+
+    switch ( pin->pin_num )
+    {
+        case PC302_GPIO_PIN_ARM_0 ... PC302_GPIO_PIN_ARM_7:
+            ret =  pin->pin_num - PC302_GPIO_PIN_ARM_0;
+            break;
+
+        case PC302_GPIO_PIN_ARM_8 ... PC302_GPIO_PIN_ARM_15:
+            ret =  ( pin->pin_num - PC302_GPIO_PIN_ARM_8 ) + 8;
+            break;
+
+        case PC302_GPIO_PIN_SDGPIO_0 ... PC302_GPIO_PIN_SDGPIO_7:
+            ret =  pin->pin_num - PC302_GPIO_PIN_SDGPIO_0;
+            break;
+
+        case PC302_GPIO_PIN_SDGPIO_8 ... PC302_GPIO_PIN_SDGPIO_15:
+            ret =  ( pin->pin_num - PC302_GPIO_PIN_SDGPIO_8 ) + 8;
+            break;
+
+        default:
+            ret = -1;
+            BUG();
+    }
+
+    return ret;
+}
+
+static int
+pc302gpio_sd_set_value( struct pc302gpio_pin_allocation *pin,
+                        int value )
+{
+    unsigned block_pin;
+    int ret;
+    u16 data;
+    BUG_ON( NULL == pin );
+
+    if ( pin->is_input )
+        return -EINVAL;
+
+    block_pin = pc302gpio_pin_to_block_pin( pin );
+
+    if ( !pin->a_not_d )
+    {
+        /* Digital mode */
+        ret = pc302_config_read( PC302_AXI2PICO_CAEID,
+                                 PC302_GPIO_SD_OUTPUT_VAL_REG, 1, &data );
+        if ( 1 != ret )
+        {
+            printf ("%s : ret = %d\n",  __FUNCTION__, ret);
+            printf( "%s : failed to read SDGPIO output value reg\n", __FUNCTION__ );
+            return -EIO;
+        }
+
+        data &= ~( 1 << block_pin );
+        data |= ( !!value ) << block_pin;
+
+        ret = pc302_config_write( PC302_AXI2PICO_CAEID,
+                                  PC302_GPIO_SD_OUTPUT_VAL_REG,
+                                  1, &data );
+        if ( 1 != ret )
+        {
+            printf( "%s : failed to output control register for SDGPIO"
+                    "pin %u\n", __FUNCTION__, block_pin );
+            return -EIO;
+        }
+    }
+    else
+    {
+        /* Analogue mode */
+        data = (u16)value;
+        ret = pc302_config_write( PC302_AXI2PICO_CAEID,
+                                  PC302_GPIO_SD_PIN_ANALOGUE_VAL( block_pin ),
+                                  1, &data );
+        if ( 1 != ret )
+        {
+            printf( "%s : failed to write analogue value register for "
+                    "SDGPIO pin %u\n", __FUNCTION__, block_pin );
+            return -EIO;
+        }
+    }
+
+    return 0;
+}
+
+static int
+pc302gpio_sd_get_value( struct pc302gpio_pin_allocation *pin )
+{
+    unsigned block_pin;
+    int ret;
+    u16 data;
+    BUG_ON( NULL == pin );
+
+    if ( !pin->is_input && !pin->a_not_d )
+        return -EINVAL;
+
+    block_pin = pc302gpio_pin_to_block_pin( pin );
+
+    if ( !pin->a_not_d )
+    {
+        /* Digital mode */
+        ret = pc302_config_read( PC302_AXI2PICO_CAEID,
+                                 PC302_GPIO_SD_INPUT_VAL_REG, 1, &data );
+        if ( 1 != ret )
+        {
+            printf( "%s : failed to read SDGPIO input value reg\n",
+                    __FUNCTION__ );
+            return -EIO;
+        }
+
+        return !!( data & ( 1 << block_pin ) );
+    }
+    else
+    {
+        /* Analogue mode */
+        ret = pc302_config_read( PC302_AXI2PICO_CAEID,
+                                 PC302_GPIO_SD_PIN_ANALOGUE_VAL( block_pin ),
+                                 1, &data );
+        if ( 1 != ret )
+        {
+            printf( "%s : failed to read the analogue value register "
+                    "for SDGPIO pin %u\n", __FUNCTION__, block_pin );
+            return -EIO;
+        }
+
+        return (int)data;
+    }
+}
+
+static int
+pc302gpio_arm_get_value( struct pc302gpio_pin_allocation *pin )
+{
+    unsigned block_pin;
+    unsigned int port_ds;
+    u32 pin_offset;
+    u32 val;
+    BUG_ON( NULL == pin );
+
+    if ( !pin->is_input )
+        return -EINVAL;
+
+    block_pin = pc302gpio_pin_to_block_pin( pin );
+
+    if ( block_pin >= PC302_GPIO_PIN_ARM_0 &&
+         block_pin <= PC302_GPIO_PIN_ARM_7 )
+    {
+        port_ds = PC302_GPIO_BASE + GPIO_EXT_PORT_A_REG_OFFSET;
+        pin_offset = block_pin;
+    }
+    else if ( block_pin >= ( PC302_GPIO_PIN_ARM_8 -
+                             PC302_ARM_GPIO_PORT_WIDTH ) &&
+              block_pin <= ( PC302_GPIO_PIN_ARM_15 -
+                             PC302_ARM_GPIO_PORT_WIDTH ) )
+    {
+        port_ds = PC302_GPIO_BASE + GPIO_EXT_PORT_B_REG_OFFSET;
+        pin_offset = block_pin - PC302_ARM_GPIO_PORT_WIDTH;
+    }
+    else
+    {
+        printf( "%s : cannot set value of ARM GPIO pin (%d)\n",
+                __FUNCTION__, block_pin );
+        return -ENXIO;
+    }
+
+    val = pc302_read_from_register( port_ds );
+
+    return !!( val & ( 1 << pin_offset ) );
+}
+
+static int
+pc302gpio_sd_set_direction( struct pc302gpio_pin_allocation *pin,
+                            int input )
+{
+    int ret;
+    u16 data;
+    unsigned block_pin;
+
+    /* Set the pin to be controlled by the configuration bus. */
+    block_pin = pc302gpio_pin_to_block_pin( pin );
+
+    ret = pc302_config_read( PC302_AXI2PICO_CAEID,
+                             PC302_GPIO_SD_PIN_CONFIG( block_pin ),
+                             1, &data );
+    if ( 1 != ret )
+    {
+        printf( "%s : failed to read config register for SDGPIO \
+                pin %u\n", __FUNCTION__, block_pin );
+        return -EIO;
+    }
+
+    data &= PC302_GPIO_SD_CONFIG_CS_MASK;
+    ret = pc302_config_write( PC302_AXI2PICO_CAEID,
+                              PC302_GPIO_SD_PIN_CONFIG( block_pin ),
+                              1, &data );
+    if ( 1 != ret )
+    {
+        printf( "%s : failed to write config register for SDGPIO \
+                pin %u\n", __FUNCTION__, block_pin );
+        return -EIO;
+    }
+
+    /* Configure the pin to drive or not drive the output as appropriate.
+    */
+    ret = pc302_config_read( PC302_AXI2PICO_CAEID,
+                             PC302_GPIO_SD_CONTROL_VAL_REG, 1, &data );
+    if ( 1 != ret )
+    {
+        printf( "%s : failed to read SDGPIO control value register\n",
+                __FUNCTION__ );
+        return -EIO;
+    }
+
+    if ( input )
+        data &= ~( 1 << block_pin );
+    else
+        data |= ( 1 << block_pin );
+
+    ret = pc302_config_write( PC302_AXI2PICO_CAEID,
+                              PC302_GPIO_SD_CONTROL_VAL_REG, 1, &data );
+    if ( 1 != ret )
+    {
+        printf( "%s : failed to write control value register for SDGPIO \
+                pin %u\n", __FUNCTION__, block_pin );
+        return -EIO;
+    }
+
+    return 0;
+}
+
+static int
+pc302gpio_arm_set_direction( struct pc302gpio_pin_allocation *pin,
+                             int input )
+{
+    unsigned block_pin;
+    unsigned int port_ddr;
+    unsigned int port_cr;
+    u32 val;
+    u32 pin_offset;
+
+    /* Set the pin to be controlled by the configuration bus. */
+    block_pin = pc302gpio_pin_to_block_pin( pin );
+
+    if ( block_pin >= PC302_GPIO_PIN_ARM_0 &&
+         block_pin <= PC302_GPIO_PIN_ARM_7 )
+    {
+        port_ddr = PC302_GPIO_BASE + GPIO_SW_PORT_A_DDR_REG_OFFSET;
+        port_cr = PC302_GPIO_BASE + GPIO_SW_PORT_A_CTL_REG_OFFSET;
+        pin_offset = block_pin;
+    }
+    else if ( block_pin >= ( PC302_GPIO_PIN_ARM_8 -
+                             PC302_ARM_GPIO_PORT_WIDTH ) &&
+              block_pin <= ( PC302_GPIO_PIN_ARM_15 -
+                             PC302_ARM_GPIO_PORT_WIDTH ) )
+    {
+        port_ddr = PC302_GPIO_BASE + GPIO_SW_PORT_B_DDR_REG_OFFSET;
+        port_cr = PC302_GPIO_BASE + GPIO_SW_PORT_B_CTL_REG_OFFSET;
+        pin_offset = block_pin - PC302_ARM_GPIO_PORT_WIDTH;
+    }
+    else
+    {
+        printf( "%s : cannot set direction of ARM GPIO pin (%d)\n",
+                __FUNCTION__, block_pin );
+        return -ENXIO;
+    }
+
+    /* Set the direction register (a bit set indicates output). */
+    val = pc302_read_from_register( port_ddr );
+    if ( input )
+        val &= ~( 1 << pin_offset );
+    else
+        val |= ( 1 << pin_offset );
+    pc302_write_to_register( port_ddr, val );
+
+    /* Set the control register for the pin to be software controlled. */
+    val = pc302_read_from_register( port_cr );
+    val &= ~( 1 << pin_offset );
+    pc302_write_to_register( port_cr, val );
+
+    return 0;
+}
+
+static int
+pc302gpio_arm_set_value( struct pc302gpio_pin_allocation *pin,
+                         int value )
+{
+    unsigned block_pin;
+    u32 val;
+    u32 pin_offset;
+    unsigned int port_dr;
+    BUG_ON( NULL == pin );
+
+    if ( pin->is_input )
+        return -EINVAL;
+
+    block_pin = pc302gpio_pin_to_block_pin( pin );
+
+    if ( block_pin >= PC302_GPIO_PIN_ARM_0 &&
+         block_pin <= PC302_GPIO_PIN_ARM_7 )
+    {
+        port_dr = PC302_GPIO_BASE + GPIO_SW_PORT_A_DR_REG_OFFSET;
+        pin_offset = block_pin;
+    }
+    else if ( block_pin >= ( PC302_GPIO_PIN_ARM_8 -
+                             PC302_ARM_GPIO_PORT_WIDTH ) &&
+              block_pin <= ( PC302_GPIO_PIN_ARM_15 -
+                             PC302_ARM_GPIO_PORT_WIDTH ) )
+    {
+        port_dr = PC302_GPIO_BASE + GPIO_SW_PORT_B_DR_REG_OFFSET;
+        pin_offset = block_pin - PC302_ARM_GPIO_PORT_WIDTH;
+    }
+    else
+    {
+        printf( "%s : cannot set value of ARM GPIO pin (%d)\n",
+                __FUNCTION__, block_pin );
+        return -ENXIO;
+    }
+
+    val = pc302_read_from_register( port_dr );
+    val &= ~( 1 << pin_offset );
+    val |= ( !!value << pin_offset );
+
+    pc302_write_to_register( port_dr, val );
+
+    return 0;
+}
+
+static int
+pc302gpio_set_direction( struct pc302gpio_pin_allocation *pin,
+                         int input )
+{
+    int ret;
+    pc302gpio_pin_type ptype;
+    BUG_ON( NULL == pin );
+
+    ptype = pc302gpio_get_pin_type( pin );
+
+    if ( PC302_GPIO_ARM == ptype )
+        ret = pc302gpio_arm_set_direction( pin, input );
+    else if ( PC302_GPIO_SD == ptype )
+        ret = pc302gpio_sd_set_direction( pin, input );
+    else
+        ret = -EINVAL;
+
+    if ( !ret )
+        pin->is_input = !!input;
+
+    return ret;
+}
+
+static int
+pc302gpio_set_value( struct pc302gpio_pin_allocation *pin,
+                     int value )
+{
+    int ret;
+    pc302gpio_pin_type ptype;
+    BUG_ON( NULL == pin );
+
+    ptype = pc302gpio_get_pin_type( pin );
+
+    if ( PC302_GPIO_ARM == ptype )
+        ret = pc302gpio_arm_set_value( pin, value );
+    else if ( PC302_GPIO_SD == ptype )
+        ret = pc302gpio_sd_set_value( pin, value );
+    else
+        ret = -EINVAL;
+
+    if ( !ret && !pin->a_not_d )
+    {
+        /* Digital mode */
+        pin->value = !!value;
+    }
+    else
+    {
+        /* Analogue mode */
+        pin->value = value;
+    }
+    return ret;
+}
+
+static int
+pc302gpio_get_value( struct pc302gpio_pin_allocation *pin )
+{
+    int ret;
+    pc302gpio_pin_type ptype;
+    BUG_ON( NULL == pin );
+
+    ptype = pc302gpio_get_pin_type( pin );
+
+    if ( PC302_GPIO_ARM == ptype )
+        ret = pc302gpio_arm_get_value( pin );
+    else if ( PC302_GPIO_SD == ptype )
+        ret = pc302gpio_sd_get_value( pin );
+    else
+        ret = -EINVAL;
+
+    if ( ret >= 0 && !pin->a_not_d )
+    {
+        /* Digital mode */
+        pin->value = !!ret;
+    }
+    else
+    {
+        /* Analogue mode */
+        pin->value = ret;
+    }
+    return ret;
+}
+
+static struct pc302gpio_pin_allocation *
+pc302gpio_find_pin( unsigned gpio )
+{
+    int i;
+
+    for ( i = 0 ; i < PC302_GPIO_NUM_PADS; ++i )
+    {
+        if ( pc302gpio_pads[ i ] && pc302gpio_pads[ i ]->pin_num == gpio )
+            return pc302gpio_pads[ i ];
+    }
+
+    return NULL;
+}
+
+static int
+pc302gpio_pai_muxing( picoifGpioPinNum_t pin )
+{
+    int ret= -EINVAL;
+
+    u16 data = PC302_PAI_WAKE_UP;
+
+    /* We are about to setup a gpio mux in the PAI block,
+     * therefore before we do anything else we need to wake up
+     * the PAI block. */
+    ret = pc302_config_write( PC302_PAI_CAEID,
+                              PC302_PAI_SLEEP_REG, 1, &data );
+    if ( 1 != ret )
+    {
+        printf( "%s : failed to wake up the PAI block.\n", __FUNCTION__ );
+        return ret;
+    }
+
+    /* Read back the current value of the pai_io_ctrl register */
+    ret = pc302_config_read( PC302_PAI_CAEID,
+                             PC302_PAI_IO_CTRL_REG, 1, &data );
+    if ( 1 != ret )
+    {
+        printf( "%s : failed to read from the PAI io_ctrl register.\n",
+                __FUNCTION__ );
+        return -EIO;
+    }
+
+    /* Make sure we have valid data */
+    data &= PC302_PAI_IO_CTRL_REG_MASK;
+
+    if ( ( pin >= PC302_GPIO_PIN_ARM_4 ) &&
+         ( pin <= PC302_GPIO_PIN_ARM_7 ) )
+    {
+        /* We are muxing an ARM gpio pin */
+        switch ( pin )
+        {
+            case PC302_GPIO_PIN_ARM_4:
+                data |= PAI_GPIO_PIN_ARM_4;
+                break;
+
+            case PC302_GPIO_PIN_ARM_5:
+                data |= PAI_GPIO_PIN_ARM_5;
+                break;
+
+            case PC302_GPIO_PIN_ARM_6:
+                data |= PAI_GPIO_PIN_ARM_6;
+                break;
+
+            case PC302_GPIO_PIN_ARM_7:
+                data |= PAI_GPIO_PIN_ARM_7;
+                break;
+
+            default:
+                break;
+        }
+        /* Write the updated value to the pai_io_ctrl register */
+        ret = pc302_config_write( PC302_PAI_CAEID,
+                                  PC302_PAI_IO_CTRL_REG, 1, &data );
+        if ( 1 != ret )
+        {
+            printf( "%s : failed to write to the PAI "
+                    "io_ctrl register.\n", __FUNCTION__ );
+            return ret;
+        }
+    }
+    else if ( ( pin >= PC302_GPIO_PIN_SDGPIO_4 ) &&
+              ( pin <= PC302_GPIO_PIN_SDGPIO_7 ) )
+    {
+        /* We are muxing an sd gpio pin */
+        switch ( pin )
+        {
+            case PC302_GPIO_PIN_SDGPIO_4:
+                data |= PAI_SDGPIO_PIN_ARM_4;
+                break;
+
+            case PC302_GPIO_PIN_SDGPIO_5:
+                data |= PAI_SDGPIO_PIN_ARM_5;
+                break;
+
+            case PC302_GPIO_PIN_SDGPIO_6:
+                data |= PAI_SDGPIO_PIN_ARM_6;
+                break;
+
+            case PC302_GPIO_PIN_SDGPIO_7:
+                data |= PAI_SDGPIO_PIN_ARM_7;
+                break;
+
+            default:
+                break;
+        }
+        /* Write the updated value to the pai_io_ctrl register */
+        ret = pc302_config_write( PC302_PAI_CAEID,
+                                  PC302_PAI_IO_CTRL_REG, 1, &data );
+        if ( 1 != ret )
+        {
+            printf( "%s : failed to write to the PAI "
+                    "io_ctrl register.\n", __FUNCTION__ );
+            return ret;
+        }
+    }
+    else
+    {
+        /* We have been called with an out of range pin specified */
+        printf( "%s : pc302gpio: out of range gpio for "
+                "pai muxing.\n", __FUNCTION__ );
+        return  -EINVAL;
+    }
+
+    return 0;
+}
+
+static u32
+syscfg_read(void)
+{
+    return (u32)pc302_read_from_register( PC302_AXI2CFG_BASE +
+                                          AXI2CFG_SYS_CONFIG_REG_OFFSET );
+}
+
+static void
+syscfg_update(u32 mask,
+              u32 val)
+{
+    u32 tmp = syscfg_read();
+    tmp &= ~mask;
+    tmp |= (val & mask);
+    pc302_write_to_register( ( PC302_AXI2CFG_BASE +
+                               AXI2CFG_SYS_CONFIG_REG_OFFSET ),
+                              (unsigned int)tmp );
+}
+
+/* Public Functions -------------------------------------------------------- */
+int
+pc302_gpio_request( unsigned gpio,
+                    const char *label )
+{
+    int pad_num;
+    int ret = 0;
+    struct pc302gpio_pin_allocation *pin;
+    pc302gpio_pin_type ptype;
+
+    pad_num = pc302gpio_get_pad( gpio );
+
+    ret = -EINVAL;
+    if ( pad_num < 0 )
+        goto out;
+
+    /* If the pad is already in use then fail. */
+    ret = -EBUSY;
+    if ( pc302gpio_pads[ pad_num ] )
+        goto out;
+
+    ret = -EIO;
+    if ( set_pin_mux( gpio ) )
+        goto out;
+
+    pc302gpio_pads[ pad_num ] = pc302gpio_alloc_pin( label );
+    pc302gpio_pads[ pad_num ]->pin_num = gpio;
+    pc302gpio_pads[ pad_num ]->pad = pad_num;
+
+    pin = pc302gpio_find_pin( gpio );
+    ptype = pc302gpio_get_pin_type( pin );
+
+    ret = 0;
+
+out:
+
+    return ret;
+}
+
+void
+pc302_gpio_free( unsigned gpio )
+{
+    unsigned i;
+    unsigned found = 0;
+    struct pc302gpio_pin_allocation *pin;
+    pc302gpio_pin_type ptype;
+
+
+    pin = pc302gpio_find_pin( gpio );
+    if (!pin)
+        return;
+    ptype = pc302gpio_get_pin_type( pin );
+
+    /* Find the pin. */
+    for ( i = 0; i < PC302_GPIO_NUM_PADS; ++i )
+    {
+        if ( pc302gpio_pads[ i ] && pc302gpio_pads[ i ]->pin_num == gpio )
+        {
+            found = 1;
+            break;
+        }
+    }
+
+    if ( !found )
+        return;
+
+    free( pc302gpio_pads[ i ] );
+    pc302gpio_pads[ i ] = NULL;
+}
+
+int
+pc302_gpio_direction_input( unsigned gpio )
+{
+    int pad_num;
+    struct pc302gpio_pin_allocation *pin;
+    int ret;
+
+    pad_num = pc302gpio_get_pad( gpio );
+    if ( pad_num < 0 )
+    {
+        ret = pad_num;
+        goto out;
+    }
+
+    pin = pc302gpio_pads[ pad_num ];
+
+    ret = -ENXIO;
+    if ( !pin )
+        goto out;
+
+    pin->is_input = 1;
+    ret = pc302gpio_set_direction( pin, 1 );
+
+out:
+    return ret;
+}
+
+int
+pc302_gpio_direction_output( unsigned gpio,
+                             int value )
+{
+    int pad_num;
+    struct pc302gpio_pin_allocation *pin;
+    int ret;
+
+    pad_num = pc302gpio_get_pad( gpio );
+    if ( pad_num < 0 )
+    {
+        ret = pad_num;
+        goto out;
+    }
+
+    pin = pc302gpio_pads[ pad_num ];
+
+    ret = -ENXIO;
+    if ( !pin )
+        goto out;
+
+    pin->is_input = 0;
+    ret = pc302gpio_set_direction( pin, 0 );
+    if ( 0 != ret )
+    {
+        goto out;
+    }
+    else
+    {
+        ret = pc302gpio_set_value( pin, value );
+    }
+
+out:
+    return ret;
+}
+
+int
+pc302_gpio_set_value( unsigned gpio,
+                      int value )
+{
+    struct pc302gpio_pin_allocation *pin;
+    int ret;
+
+    pin = pc302gpio_find_pin( gpio );
+
+    ret = -EINVAL;
+    if ( !pin )
+        goto out;
+
+    ret = pc302gpio_set_value( pin, value );
+
+out:
+    return ret;
+}
+
+int
+pc302_gpio_get_value( unsigned gpio )
+{
+    struct pc302gpio_pin_allocation *pin;
+    int ret;
+
+    pin = pc302gpio_find_pin( gpio );
+
+    ret = -EINVAL;
+    if ( !pin )
+        goto out;
+
+    ret = pc302gpio_get_value( pin );
+out:
+    return ret;
+}
+
+int
+pc302_gpio_configure_dac( unsigned gpio,
+                          u8 converter_size,
+                          u16 analogue_rate )
+{
+    int ret;
+    u16 data;
+    unsigned block_pin;
+    struct pc302gpio_pin_allocation *pin = pc302gpio_find_pin( gpio );
+
+    if ( !pin )
+        return -EINVAL;
+
+    /* Set the pin to be controlled by the configuration bus. */
+    block_pin = pc302gpio_pin_to_block_pin( pin );
+
+    ret = pc302_config_read( PC302_AXI2PICO_CAEID,
+                             PC302_GPIO_SD_PIN_CONFIG( block_pin ),
+                             1, &data );
+    if ( 1 != ret )
+    {
+        printf( "%s : failed to read config register for SDGPIO \
+                pin %u\n", __FUNCTION__, block_pin );
+        return -EIO;
+    }
+
+    data &= PC302_GPIO_SD_CONFIG_CS_MASK;
+    data &= ~PC302_GPIO_SD_CONV_SZ_MASK;
+    data |= ( PC302_GPIO_SD_CONFIG_AND |
+            ( converter_size & PC302_GPIO_SD_CONV_SZ_MASK ) );
+
+    ret = pc302_config_write( PC302_AXI2PICO_CAEID,
+                              PC302_GPIO_SD_PIN_CONFIG( block_pin ),
+                              1, &data );
+    if ( 1 != ret )
+    {
+        printf( "%s : failed to write config register for SDGPIO \
+                pin %u\n", __FUNCTION__, block_pin );
+        return -EIO;
+    }
+
+    /* Configure the pin to drive the output. */
+    ret = pc302_config_read( PC302_AXI2PICO_CAEID,
+                             PC302_GPIO_SD_CONTROL_VAL_REG, 1, &data );
+    if ( 1 != ret )
+    {
+        printf( "%s : failed to read SDGPIO control value register\n",
+                __FUNCTION__ );
+        return -EIO;
+    }
+
+    data |= ( 1 << block_pin );
+
+    ret = pc302_config_write( PC302_AXI2PICO_CAEID,
+                              PC302_GPIO_SD_CONTROL_VAL_REG, 1, &data );
+    if ( 1 != ret )
+    {
+        printf( "%s : failed to write control value register for SDGPIO \
+                pin %u\n", __FUNCTION__, block_pin );
+        return -EIO;
+    }
+
+    /* Write the Analogue rate register */
+    data = analogue_rate;
+    ret = pc302_config_write( PC302_AXI2PICO_CAEID,
+                              PC302_GPIO_SD_PIN_ANALOGUE_RATE( block_pin ),
+                              1, &data );
+    if ( 1 != ret )
+    {
+        printf( "%s : failed to write analogue rate register for SDGPIO \
+                pin %u\n", __FUNCTION__, block_pin );
+        return -EIO;
+    }
+
+    /* Set the a_not_d flag in the pin allocation structure */
+    pin->a_not_d = 1;
+
+    return 0;
+}
+
+int
+pc302_gpio_init( void )
+{
+    int ret;
+
+    u16 data = PC302_AXI2PICO_WAKE_UP;
+
+    /* Get the current boot mode. */
+    u32 syscfg = syscfg_read();
+    boot_mode = ( syscfg & AXI2CFG_SYS_CONFIG_BOOT_MODE_MASK ) >>
+                AXI2CFG_SYS_CONFIG_BOOT_MODE_LO;
+
+    /* This driver can use the sdgpio, therefore before we do anything
+     * else we need to wake up the AXI2PICO block. */
+    ret = pc302_config_write( PC302_AXI2PICO_CAEID,
+                              PC302_AXI2PICO_SLEEP_REG, 1, &data );
+    if ( 1 != ret )
+    {
+        /* Config write has failed */
+        printf( "%s : failed to wake up the AXI2PICO block.\n", __FUNCTION__ );
+        return -EIO;
+    }
+
+    return 0;
+}
diff --git a/cpu/arm926ejs/pc302/remap.S b/cpu/arm926ejs/pc302/remap.S
new file mode 100644
index 0000000..be58b69
--- /dev/null
+++ b/cpu/arm926ejs/pc302/remap.S
@@ -0,0 +1,93 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+ 
+/*!
+* \file
+* \brief remap.S
+*
+* Copyright (c) 2006-2008 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/ 
+
+#include <config.h>
+#include <asm/arch/pc302.h>
+#include <asm/arch/axi2cfg.h>
+
+	.align	5
+ 
+/*!
+ *
+ * Remap the EBI connected parallel flash memory from its aliased
+ * location to its 'correct' location in the pc302 memory map.
+ *              
+ * Note: Once this function returns we will be able to access
+ *       DDR SDRAM at address 0x00000000 (assuming DDR SDRAM
+ *       has been initialised).
+ *                
+ */
+ .global remap_flash
+ 
+ remap_flash:     
+ 	    
+        /* Preserve link register across call */
+        mov r11,lr                                      
+        
+        bl  noodle_program_counter
+        
+        /* We are now executing code from the 'correct' 
+           Bootable Flash memory address */
+        
+        /* Perform the 'remap' in the axi2cfg block */
+        ldr     r0, =PC302_AXI2CFG_BASE
+        ldr     r1, [r0, #AXI2CFG_SYS_CONFIG_REG_OFFSET]
+        bic     r1, #AXI2CFG_SYS_CONFIG_RW_REMAP_MASK
+        str     r1, [r0, #AXI2CFG_SYS_CONFIG_REG_OFFSET]
+ 	
+	/* Allow things to settle down... */
+        nop
+        nop
+        nop
+        nop
+        nop
+        nop
+        nop
+        nop
+        nop
+        nop
+        nop
+        nop
+        nop
+        nop
+        nop
+        nop
+
+        /* Restore link register */
+        mov     lr, r11                                 
+        
+        /* on return, execute code from Bootable Flash memory */
+        orr     lr, lr, #PC302_BOOTABLE_FLASH_BASE	
+
+remap_flash_return:
+        
+        /* Return to my caller */
+        mov	pc, lr		                        
+       
+/*!
+ *
+ * Set the pc so we are executing code from Bootable
+ * at the 'correct' address in the PC302 memory map.
+ *                
+ */
+ noodle_program_counter:
+ 
+        /* On return, execute code from Bootable Flash memory */
+        orr     lr, lr, #PC302_BOOTABLE_FLASH_BASE	
+
+        /* Return to my caller */
+        mov     pc, lr		                        
diff --git a/cpu/arm926ejs/pc302/reset.S b/cpu/arm926ejs/pc302/reset.S
new file mode 100644
index 0000000..d6496cc
--- /dev/null
+++ b/cpu/arm926ejs/pc302/reset.S
@@ -0,0 +1,93 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file reset.S
+* \brief Function used to reset the PC302 device.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/* Includes ---------------------------------------------------------------- */
+#include <config.h>
+#include <asm/arch/pc302.h>
+#include <asm/arch/wdog.h>
+#include <asm/arch/gpio.h>
+
+/* Macros ------------------------------------------------------------------ */
+#define ASSERT_RESET_PIN            0x80    /* Using ARM GPIO 7 */
+#define RESET_PIN_IS_OUTPUT         0x80
+
+/* Functions --------------------------------------------------------------- */
+
+	.align	5
+
+/*!
+ *
+ * Perform a software reset of the PC302 device.
+ *
+ * Note: The method used to provide the reset functionailty is
+ *       hardware platform dependant.
+ * Note: We will never return from this function.
+ *
+ */
+.globl reset_cpu
+
+reset_cpu:
+
+#if defined(CONFIG_PICOCHIP_PC7302) && defined(CONFIG_USE_GPIO_RESET_METHOD)
+
+        /* We are running on a picoChip PC7302 platform
+           and have been asked to reset using the ARM GPIO method */
+
+        /* Get base address of the arm gpio block */
+        ldr r0,=PC302_GPIO_BASE
+
+        /* Assert the reset pin (in the data register) */
+        ldr r1,[r0, #GPIO_SW_PORT_A_DR_REG_OFFSET]
+        orr r1,r1,#ASSERT_RESET_PIN
+        str r1,[r0, #GPIO_SW_PORT_A_DR_REG_OFFSET]
+
+        /* Set up the reset pin to be an output */
+        ldr r1,[r0, #GPIO_SW_PORT_A_DDR_REG_OFFSET]
+        orr r1,r1,#RESET_PIN_IS_OUTPUT
+        str r1,[r0, #GPIO_SW_PORT_A_DDR_REG_OFFSET]
+
+        /* The reset input to the device should now be active */
+
+#else
+        /* Use the 'fallback' watchdog method for reseting */
+
+        ldr     r0, =PC302_WDOG_BASE
+
+        /* Read the control register */
+        ldr     r1, [r0, #WDOG_CONTROL_REG_OFFSET]
+
+        /* Clear the 'Response mode' bit */
+        bic     r1, #WDOGCONTROLREGRMODMASK
+
+        /* Set the 'Watchdog Enable' bit */
+        orr     r1, #WDOGCONTROLREGWDT_ENMASK
+
+        /* Write to the control register */
+        str     r1, [r0, #WDOG_CONTROL_REG_OFFSET]
+
+        /* The Watchdog is hardwired for a 1 second timeout */
+
+        /* 'Kick' the Watchdog into life */
+        mov     r1, #WDOG_COUNTER_RESTART_KICK_VALUE
+        str     r1, [r0, #WDOG_CONTROL_REG_OFFSET]
+
+#endif
+
+reset_loop_forever:
+
+        /* We will never return from this function */
+        b       reset_loop_forever
diff --git a/cpu/arm926ejs/pc302/serial.c b/cpu/arm926ejs/pc302/serial.c
new file mode 100644
index 0000000..7c95b3d
--- /dev/null
+++ b/cpu/arm926ejs/pc302/serial.c
@@ -0,0 +1,277 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+ 
+/*!
+* \file
+* \brief serial.c
+*
+* Copyright (c) 2006-2008 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/ 
+
+#include <common.h>
+
+#ifdef CFG_DW_APB_UART
+
+/* Includes ----------------------------------------------------------------- */
+#include <asm/arch/pc302.h>
+#include <asm/arch/uart.h>
+
+/* Macros ------------------------------------------------------------------- */
+#if !defined(CONFIG_CONS_INDEX)
+#error	"No console index specified."
+#elif (CONFIG_CONS_INDEX < 1) || (CONFIG_CONS_INDEX > 2)
+#error	"Invalid console index value specified."
+#endif
+
+#define IO_WRITE(addr, val) (*(volatile unsigned int *)(addr) = (val))
+#define IO_READ(addr) (*(volatile unsigned int *)(addr))
+
+/* uart[] array is zero based whilst CONFIG_CONS_INDEX is '1' based */
+#define CONSOLE_PORT (CONFIG_CONS_INDEX - 1)
+
+/* Constants ---------------------------------------------------------------- */
+static volatile unsigned char *const uart[] = {
+                                                (void *)PC302_UART1_BASE,
+                                                (void *)PC302_UART2_BASE
+                                              };
+
+/* Prototypes---------------------------------------------------------------- */
+/*!
+ *
+ * Write a character to the uart
+ *
+ * Note: This function will block if the Tx FIFO is full
+ *
+ * \param uartNumb Which uart to use
+ * \param c The character to output
+ *
+ */ 
+static void dwApbUart_putc (int uartNum, char c);
+
+/*!
+ *
+ * Read a character from the uart
+ *          
+ * Note: This function will block if the Rx FIFO is empty
+ *
+ * \param uartNumb Which uart to use   
+ */   
+static int dwApbUart_getc (int uartNum);
+
+/*!
+ *
+ * Test if there is a character available to be read from the uart
+ *
+ * \param uartNumb Which uart to use     
+ *
+ * \return 0 no character availbale to be read
+ *         1 character available to be read
+ *
+ */  
+static int dwApbUart_tstc (int uartNum);
+
+/* Functions ---------------------------------------------------------------- */
+
+/*****************************************************************************
+ *
+ * serial_init()
+ *
+ * Purpose: Initialise the console uart
+ *
+ * Args:    
+ *
+ * Returns:
+ *
+ *****************************************************************************/
+int serial_init (void)
+{
+    unsigned int lcrRegister;
+
+    unsigned int baudRate = CONFIG_BAUDRATE;
+    unsigned int uartNum = CONSOLE_PORT;
+    unsigned int divisor;
+    unsigned int temp;
+
+    /* Setup the baud rate */
+    
+    /* Wait while the UART is busy... */
+    while ((IO_READ(uart[uartNum] + UART_UART_STATUS_REG_OFFSET) & UART_UART_STATUS_BUSY_MASK));
+
+    /* Set the Divisor Latch Access Bit in the Line Control Register */
+    lcrRegister = IO_READ(uart[uartNum] + UART_LINE_CTRL_REG_OFFSET);
+    lcrRegister = lcrRegister | UART_LINE_CTRL_DLAB_MASK;
+    IO_WRITE (uart[uartNum] + UART_LINE_CTRL_REG_OFFSET, lcrRegister);
+  
+#ifdef CONFIG_PC302_SIMULATION        
+    /* If running in RTL simulation land just set the baud rate to the highest value possible */
+    IO_WRITE (uart[uartNum] + UART_DIVISOR_LOW_REG_OFFSET, 0x01);
+    IO_WRITE (uart[uartNum] + UART_DIVISOR_HIGH_REG_OFFSET, 0x00);
+#else
+    /* Baud Rate = Baud Rate Gen Clock / (16 * divisor) */ 
+    temp = 16 * baudRate;
+    divisor = CONFIG_DW_APB_UART_CLOCK / temp;
+    
+    IO_WRITE (uart[uartNum] + UART_DIVISOR_LOW_REG_OFFSET, (divisor & UART_DIVISOR_MASK));
+    IO_WRITE (uart[uartNum] + UART_DIVISOR_HIGH_REG_OFFSET, ((divisor >> 8) & UART_DIVISOR_MASK));
+#endif        
+
+    /* Clear the Divisor Latch Access Bit in the Line Control Register */
+    lcrRegister = IO_READ(uart[uartNum] + UART_LINE_CTRL_REG_OFFSET);
+    lcrRegister = lcrRegister  & ~(UART_LINE_CTRL_DLAB_MASK); 
+    IO_WRITE (uart[uartNum] + UART_LINE_CTRL_REG_OFFSET, lcrRegister);
+
+    /* Enable the Rx & Tx fifos */
+    IO_WRITE (uart[uartNum] + UART_FIFO_CTRL_REG_OFFSET, UART_FIFO_CTRL_ENABLE);
+	        
+     /* Setup the UART for...
+       8 data bit word length
+       1 stop bit
+       parity disabled */
+                  
+    /* Wait while the UART is busy... */
+    while ((IO_READ(uart[uartNum] + UART_UART_STATUS_REG_OFFSET) & UART_UART_STATUS_BUSY_MASK)); 
+   
+    lcrRegister = IO_READ(uart[uartNum] + UART_LINE_CTRL_REG_OFFSET);
+    lcrRegister = lcrRegister | UART_LINE_CTRL_DLS_8BITS;
+    lcrRegister = lcrRegister & UART_LINE_CTRL_1STOP_BIT;
+    lcrRegister = lcrRegister & UART_LINE_CTRL_PARITY_DISABLE;
+    IO_WRITE (uart[uartNum] + UART_LINE_CTRL_REG_OFFSET, lcrRegister);
+	
+    return (0);
+}
+
+/*****************************************************************************
+ *
+ * serial_putc()
+ *
+ * Purpose: Write a character to the console uart 
+ *
+ * Args:    
+ *
+ * Returns:
+ *
+ *****************************************************************************/
+void serial_putc(const char c)
+{
+    if (c == '\n')
+    {
+        dwApbUart_putc (CONSOLE_PORT, '\r');
+    }
+
+    dwApbUart_putc (CONSOLE_PORT, c);
+}
+
+/*****************************************************************************
+ *
+ * serial_puts()
+ *
+ * Purpose: Write a string to the console uart 
+ *
+ * Args:    
+ *
+ * Returns:
+ *
+ *****************************************************************************/
+
+void serial_puts(const char *s)
+{
+
+    while (*s)
+    {
+        serial_putc(*s++);
+    }
+        
+}
+
+/*****************************************************************************
+ *
+ * serial_getc()
+ *
+ * Purpose: Read a character from the console uart 
+ *
+ * Args:    
+ *
+ * Returns:
+ *
+ *****************************************************************************/
+
+int serial_getc(void)
+{
+	
+    return dwApbUart_getc(CONSOLE_PORT);
+    
+}
+
+/*****************************************************************************
+ *
+ * serial_tstc()
+ *
+ * Purpose: Test to see if there are any characters availale to be read
+ *          from the console uart 
+ *
+ * Args:    
+ *
+ * Returns: 0 - no character availbale in the Rx FIFO
+ *          1 - character available in the Rx FIFO
+ *
+ *****************************************************************************/
+int serial_tstc(void)
+{
+
+    return dwApbUart_tstc(CONSOLE_PORT);
+
+}
+
+/*****************************************************************************
+ *
+ * serial_setbtg()
+ *
+ * Purpose: set the uart baud rate. 
+ *
+ * Args:    
+ *
+ * Returns: 
+ *
+ *****************************************************************************/
+void serial_setbrg(void)
+{
+	/* Not used right now ! */
+}
+
+static void dwApbUart_putc (int uartNum, char c)
+{
+	
+    /* Wait until there is space in the Tx FIFO... */
+	
+    while (!(IO_READ(uart[uartNum] + UART_LINE_STATUS_REG_OFFSET) & UART_LINE_STATUS_THRE_MASK));
+    
+    /* Send the character */
+    IO_WRITE (uart[uartNum] + UART_TX_HOLDING_REG_OFFSET, c);
+}
+    
+static int dwApbUart_getc (int uartNum)
+{
+
+    /* Wait until there is a character in the Rx FIFO... */
+    while (!dwApbUart_tstc(CONSOLE_PORT));
+
+    /* Go and read a character... */
+    return (IO_READ (uart[uartNum] + UART_RX_BUFFER_REG_OFFSET));
+    
+}
+   
+static int dwApbUart_tstc (int uartNum)
+{
+
+    return (IO_READ (uart[uartNum] + UART_LINE_STATUS_REG_OFFSET) & UART_LINE_STATUS_DATA_READY_MASK);
+
+}
+
+#endif
diff --git a/cpu/arm926ejs/pc302/spi.c b/cpu/arm926ejs/pc302/spi.c
new file mode 100644
index 0000000..d911371
--- /dev/null
+++ b/cpu/arm926ejs/pc302/spi.c
@@ -0,0 +1,704 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file spi.c
+* \brief SPI driver for the PC302.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+
+#ifdef CFG_DW_SPI
+
+/* Define this to use a GPIO as the spi flash chip select.
+   Note: On the PC7302 platform we only have a single spi flash device.
+   Note: If this is not defined then we use the chip select generated by the
+         SPI block.
+   Note: Using this option on a PC7302 platform will require a board
+         modification.
+*/
+//#define USE_GPIO_AS_CHIP_SELECT
+
+#include <spi.h>
+#include <malloc.h>
+#include <asm/io.h>
+#include <asm/arch/pc302.h>
+#include <asm/arch/spi.h>
+#include <asm/arch/axi2cfg.h>
+#include <asm/arch/gpio.h>
+
+/* Macros ------------------------------------------------------------------ */
+/*!
+ * \brief Debug macro
+ */
+#ifdef	SPI_DEBUG
+#define spi_debug(fmt,args...)	printf (fmt ,##args)
+#else
+#define spi_debug(fmt,args...)
+#endif	/* SPI_DEBUG */
+
+/* !
+ *  \brief Macros used to read from, and write to, the spi registers.
+ *         Note: These macros provide 16 bit access.
+ */
+#define SPI_READ(__offset) \
+                  *((volatile u16*)(PC302_SSI_BASE + __offset))
+
+#define SPI_WRITE(__value, __offset) \
+                   *((volatile u16*)(PC302_SSI_BASE + __offset)) = __value
+
+/* !
+ *  \brief Macros used to read from, and write to, the axi2cfg registers.
+ *         Note: These macros provide 32 bit access.
+ */
+#define AXI2CFG_READ(__offset) \
+                  *((volatile u32*)(PC302_AXI2CFG_BASE + __offset))
+
+#define AXI2CFG_WRITE(__value, __offset) \
+                   *((volatile u32*)(PC302_AXI2CFG_BASE + __offset)) = __value
+
+/* Constants --------------------------------------------------------------- */
+/* !
+ *  \brief This structure is used for generic and device specific
+ *         spi driver data.
+ */
+struct pc302_spi_slave
+{
+    /* Generic spi slave description */
+    struct spi_slave slave;
+
+    /* Additional driver data for the pc302 implementation */
+
+    /* Serial clock polarity */
+    unsigned int scpol;
+
+    /* Serial clock phase */
+    unsigned int scph;
+
+    /* Serial bus speed (Hz) */
+    unsigned int max_hz;
+
+    /* Pointer to hold location of the Tx data 'copy' */
+    u8 * dout_copy;
+
+    /* Keep a count of the data to tx */
+    unsigned int byte_count_tx;
+};
+
+/*!
+ * \brief Function return codes
+ */
+enum return_codes
+{
+    SUCCESS = 0,    /* Successful outcome */
+    FAILURE = 1     /* Error response */
+};
+
+/* Types ------------------------------------------------------------------- */
+
+/* Prototypes--------------------------------------------------------------- */
+
+void spi_init()
+{
+    /* Nothing specific required in here */
+}
+
+struct spi_slave *spi_setup_slave(unsigned int bus,
+                                  unsigned int cs,
+                                  unsigned int max_hz,
+                                  unsigned int mode)
+{
+    struct pc302_spi_slave  *spi_slave;
+
+    unsigned int    spi_max_clock = 0;
+    unsigned int    spi_min_clock = 0;
+
+    /* Have we been passed a valid combination of bus and cs ?
+       Note: PC302 device has a single SPI controller (bus) and
+             4 possible SPI chip selects */
+
+    if (bus > (PC302_MAX_NUMBER_SPI_BUSSES - 1))
+    {
+        /* Oops, request bus is out of range. */
+        printf ("Oops, SPI 'bus' out of range. "
+                "(We only have %d SPI bus(ses) available).\n",
+                (unsigned int)PC302_MAX_NUMBER_SPI_BUSSES);
+        return NULL;
+    }
+
+    if (cs > (PC302_MAX_NUMBER_SPI_CS - 1))
+    {
+        /* Oops, requested chip select is out of range */
+        printf ("Oops, SPI 'cs' out of range. "
+                "(We only have %d 'cs' available).\n",
+                (unsigned int)PC302_MAX_NUMBER_SPI_CS);
+        return NULL;
+    }
+
+    /* Have we been passed a valid SPI bus clock rate ? */
+    spi_max_clock = (PC302_AHB_CLOCK_FREQ / PC302_MIN_SPI_CLK_DIVIDER);
+    spi_min_clock = (PC302_AHB_CLOCK_FREQ / PC302_MAX_SPI_CLK_DIVIDER);
+
+    if ((max_hz < spi_min_clock) || (max_hz > spi_max_clock))
+    {
+    	/* Oops, we do not support this requested SPI bus clock rate */
+        printf ("Oops, SPI bus 'hz' out of range. "
+                "(Min = %d Hz, Max = %d Hz).\n", spi_min_clock, spi_max_clock);
+	return NULL;
+    }
+
+#ifdef USE_GPIO_AS_CHIP_SELECT
+    /* Have we been passed a valid SPI mode ? */
+    if ((mode < SPI_MODE_0) || (mode > SPI_MODE_3))
+    {
+        /* Oops, we only support spi mode 0 - 3 */
+        printf ("Oops, SPI 'mode' out of range. "
+                "(We only support SPI 'mode' %d to %d).\n",
+                (unsigned int)SPI_MODE_0, (unsigned int)SPI_MODE_3);
+        return NULL;
+    }
+#else
+    /* Have we been passed a valid SPI mode ? */
+    if (mode != SPI_MODE_3)
+    {
+        /* Oops, we only support spi mode 3 */
+        printf ("Oops, SPI 'mode' out of range. "
+                "(We only support SPI 'mode' %d).\n",
+                (unsigned int)SPI_MODE_3);
+        return NULL;
+    }
+#endif
+
+    /* Grab some memory for the SPI data structure */
+    spi_slave = malloc(sizeof(struct pc302_spi_slave));
+    if (!spi_slave)
+    {
+        /* Oops, we have a memory management problem */
+	printf ("Oops, memory allocation error, File: %s, Function: %s,"
+                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
+        return NULL;
+    }
+
+    /* Populate our structure */
+    spi_slave->slave.bus = bus;
+    spi_slave->slave.cs = cs;
+    spi_slave->max_hz = max_hz;
+
+    switch (mode)
+    {
+        case SPI_MODE_0:
+            spi_slave->scpol = 0;
+            spi_slave->scph = 0;
+            break;
+        case SPI_MODE_1:
+            spi_slave->scpol = 0;
+            spi_slave->scph = 1;
+            break;
+        case SPI_MODE_2:
+            spi_slave->scpol = 1;
+            spi_slave->scph = 0;
+            break;
+        case SPI_MODE_3:
+            spi_slave->scpol = 1;
+            spi_slave->scph = 1;
+            break;
+        default:
+            spi_slave->scpol = 0;
+            spi_slave->scph = 0;
+            break;
+    }
+
+#ifdef USE_GPIO_AS_CHIP_SELECT
+    /* Set up ARM gpio #2 for cs driving */
+    /* Negate the 'cs' in the data register */
+    *(unsigned int *)(PC302_GPIO_BASE + GPIO_SW_PORT_A_DR_REG_OFFSET) |=
+                      GPIO_BIT_2;
+
+    /* Set up the gpio as an o/p */
+    *(unsigned int *)(PC302_GPIO_BASE + GPIO_SW_PORT_A_DDR_REG_OFFSET) |=
+                      GPIO_BIT_2;
+#endif
+
+    return &spi_slave->slave;
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+    struct pc302_spi_slave  *spi_slave =
+           container_of(slave, struct pc302_spi_slave, slave);
+
+    /* Free memory acquired to hold the SPI data structure */
+    free (spi_slave);
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+    struct pc302_spi_slave  *spi_slave;
+
+    u16 ctrlr0 = 0;
+    u16 sckdv = 0;
+
+     /* Have we been passed a valid data structure handle ? */
+    if (slave == NULL)
+    {
+        /* Oops, bad handle passed in */
+        printf ("Oops, bad handle passed in, File: %s, Function: %s,"
+                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
+        return -FAILURE;
+    }
+
+    spi_slave = container_of(slave, struct pc302_spi_slave, slave);
+
+    /* Disable SPI operations
+       Note: We can't program up the block registers unless
+             the block is disabled  */
+    SPI_WRITE(PC302_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);
+
+    /* Program up some bits Control Register 0.
+       Note: As TMOD bits set to 00 (Transmit & Receive),
+             we do not need to worry about the ctrlr1 register */
+    ctrlr0 = PC302_SPI_DATA_FRM_8_BIT;
+
+    if (spi_slave->scph)
+    {
+        /* Set the clock phase */
+        ctrlr0 |= PC302_SPI_SCPH;
+    }
+    if (spi_slave->scpol)
+    {
+        /* Set the clock polarity */
+        ctrlr0 |= PC302_SPI_SCPOL;
+    }
+    SPI_WRITE(ctrlr0, SSI_CTRL_REG_0_REG_OFFSET);
+
+    /* Setup the SPI bus clock rate */
+    sckdv = (PC302_AHB_CLOCK_FREQ / spi_slave->max_hz);
+    SPI_WRITE(sckdv, SSI_BAUD_RATE_SEL_REG_OFFSET);
+
+    /* Mask all interrupts from the SPI block */
+    SPI_WRITE(PC302_SPI_MASK_ALL_INTS, SSI_IMR_REG_OFFSET);
+
+    return SUCCESS;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+    /* Have we been passed a valid data structure handle ? */
+    if (slave == NULL)
+    {
+        /* Oops, bad handle passed in */
+        printf ("Oops, bad handle passed in, File: %s, Function: %s,"
+                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
+    }
+
+    /* Disable SPI operations */
+    SPI_WRITE(PC302_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);
+}
+
+int spi_xfer(struct spi_slave *slave,
+             unsigned int bitlen,
+             const void *dout,
+             void *din,
+             unsigned long flags)
+{
+    struct pc302_spi_slave  *spi_slave;
+
+    unsigned int    len_tx;
+    unsigned int    len_rx;
+    unsigned int    byte_count;
+
+    u16		    status;
+
+    const u8	    *txp = dout;
+    u8		    *rxp = din;
+    u8		    value;
+
+
+    spi_debug ("spi_xfer: bitlen = %d, dout = %p, din = %p, flags = %d\n",
+                bitlen, dout, din, flags);
+
+     /* Have we been passed a valid data structure handle ? */
+    if (slave == NULL)
+    {
+        /* Oops, bad handle passed in */
+        printf ("Oops, bad handle passed in, File: %s, Function: %s,"
+                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
+        return -FAILURE;
+    }
+
+    spi_slave = container_of(slave, struct pc302_spi_slave, slave);
+
+    if (bitlen == 0)
+    {
+        /* Finish any previously submitted transfers */
+	goto out;
+    }
+
+    /*
+     * The SPI controller can do non-multiple-of-8 bit
+     * transfers, but this driver currently doesn't support it.
+     */
+    if (bitlen % 8)
+    {
+        /* Errors always terminate an ongoing transfer */
+	flags |= SPI_XFER_END;
+        goto out;
+    }
+
+    /* Number of bytes to transfer */
+    byte_count = bitlen / 8;
+
+#ifdef USE_GPIO_AS_CHIP_SELECT
+    /* Ok, we are using a chip select generated by a gpio signal */
+
+    if (flags & SPI_XFER_BEGIN)
+    {
+        /* Assert the required chip SPI slave chip select */
+        spi_cs_activate(slave);
+
+        /* Enable SPI operations */
+        SPI_WRITE(PC302_SPI_ENABLE, SSI_ENABLE_REG_REG_OFFSET);
+    }
+
+    /* Start the data transfer */
+    for (len_tx = 0, len_rx = 0; len_rx < byte_count; )
+    {
+        status = SPI_READ(SSI_STATUS_REG_OFFSET);
+
+	if (len_tx < byte_count && (status & PC302_SPI_STATUS_TFNF))
+        {
+	    /* We have room in the Tx fifo */
+            if (txp)
+		value = *txp++;
+	    else
+		value = 0;
+
+            SPI_WRITE(value, SSI_DATA_REG_OFFSET);
+            len_tx++;
+	}
+
+        if (status & PC302_SPI_STATUS_RFNE)
+        {
+	    /* We have some data in the receive fifo */
+            value = (u8)SPI_READ(SSI_DATA_REG_OFFSET);
+	    if (rxp)
+	        *rxp++ = value;
+	    len_rx++;
+	}
+    }
+
+out:
+    if (flags & SPI_XFER_END)
+    {
+        /*
+	 * Wait until the transfer is completely done before
+	 * we deactivate CS.
+	 */
+        do
+        {
+	    status = SPI_READ(SSI_STATUS_REG_OFFSET);
+            status &= PC302_SPI_STATUS_BUSY;
+
+	} while (status);
+
+	spi_cs_deactivate(slave);
+    }
+
+    return SUCCESS;
+}
+#else   /* USE_GPIO_AS_CHIP_SELECT */
+
+    /* Using the SPI block to control the chip selects,
+       therefore we need all transactions before we start anything.
+
+       Note: It is imperative that the Tx fifo never empties during operation,
+             if this happens the cs will be negated by the SPI block,
+             the spi flash will 'forget' what it is doing and it will
+             all end in tears ! */
+
+    u8 *dout_copy = NULL;
+    unsigned int byte_count_tx = 0;
+    unsigned int byte_count_rx = 0;
+    unsigned int byte_count_tx_more = 0;
+    unsigned int total_loop_count = 0;
+    unsigned int total_tx_count = 0;
+
+    if (flags & SPI_XFER_BEGIN)
+    {
+        /* If necessary take a copy of the data to transmit */
+        if (txp)
+        {
+            /* Ok, we have some data to Tx */
+
+            /* Grab some memory */
+            dout_copy = malloc(byte_count);
+            if (!dout_copy)
+            {
+                /* Oops, we have a memory management problem */
+	        printf ("Oops, memory allocation error, File: %s,"
+                        " Function: %s, Line: %d\n",
+                        __FILE__, __FUNCTION__, __LINE__);
+                return -FAILURE;
+            }
+
+            /* Lets take a copy of the data */
+            memcpy (dout_copy, dout, byte_count);
+
+            /* Save some useful info for later use */
+            spi_slave->dout_copy = dout_copy;
+            spi_slave->byte_count_tx = byte_count;
+
+            /* We have a copy of the data so can null the
+               tx data pointer */
+            txp = NULL;
+        }
+    }
+
+    if (flags & SPI_XFER_END)
+    {
+        /* Go retrieve the saved data */
+        dout_copy = spi_slave->dout_copy;
+        byte_count_tx = spi_slave->byte_count_tx ;
+
+        if (!dout_copy)
+        {
+            /* Oops, we have a memory management problem */
+	    printf ("Oops, memory allocation error, File: %s,"
+                    " Function: %s, Line: %d\n",
+                    __FILE__, __FUNCTION__, __LINE__);
+            return -FAILURE;
+        }
+
+        /* Have we any more Tx data (spi flash writing) ? */
+        if (txp)
+        {
+            byte_count_tx_more = byte_count;
+        }
+        else
+        {
+            byte_count_tx_more = 0;
+        }
+
+        /* Have we any data to Rx ? */
+        if (rxp)
+        {
+            byte_count_rx = byte_count;
+        }
+        else
+        {
+            byte_count_rx = 0;
+        }
+
+        /* Assert the required chip SPI slave chip select */
+        spi_cs_activate(slave);
+
+        /* Enable SPI block operations */
+        SPI_WRITE(PC302_SPI_ENABLE, SSI_ENABLE_REG_REG_OFFSET);
+
+        /* Set up some variables to avoid calculating them during the loop */
+        total_loop_count = byte_count_rx + byte_count_tx + byte_count_tx_more;
+        total_tx_count = byte_count_tx + byte_count_tx_more;
+
+        spi_debug ("spi_xfer: byte_count_rx = %d\n", byte_count_rx);
+        spi_debug ("spi_xfer: byte_count_tx = %d\n", byte_count_tx);
+        spi_debug ("spi_xfer: byte_count_tx_more = %d\n", byte_count_tx_more);
+        spi_debug ("spi_xfer: total_tx_count = %d\n", total_tx_count);
+        spi_debug ("spi_xfer: total_loop_count = %d\n", total_loop_count);
+
+        for (len_tx = 0, len_rx = 0; len_rx < total_loop_count; )
+        {
+	    status = SPI_READ(SSI_STATUS_REG_OFFSET);
+
+            while (len_tx < byte_count_tx)
+            {
+	        /* The Tx fifo is 16 entries deep, we should never fill
+                   this up sending a 'command' to the flash.  Therefore
+                   we do not check the tx fifo status */
+                SPI_WRITE(*dout_copy++, SSI_DATA_REG_OFFSET);
+                len_tx++;
+            }
+
+            while ((len_tx < total_tx_count) &&
+                   (status & PC302_SPI_STATUS_TFNF))
+            {
+                /* We have more data to Tx, so just keep going */
+                SPI_WRITE(*txp++, SSI_DATA_REG_OFFSET);
+                len_tx++;
+
+                /* We may fill the tx fifo now, so a re-read of
+                   the status register is a good idea */
+                status = SPI_READ(SSI_STATUS_REG_OFFSET);
+            }
+
+            if ((len_tx >= total_tx_count) && (byte_count_rx == 0))
+            {
+                /* We have finished Tx and we are not interested in Rx,
+                  lets get out of here */
+                break;
+            }
+
+            if ((len_tx >= total_tx_count) && (byte_count_rx != 0))
+            {
+                /* Still trying to read some data, so keep the Tx fifo
+                   tickling along, we don't care if the Tx fifo is
+                   full or overflows */
+                SPI_WRITE(0, SSI_DATA_REG_OFFSET);
+            }
+
+            if (status & PC302_SPI_STATUS_RFNE)
+            {
+	        /* We have some data available in the receive fifo */
+                value = (u8)SPI_READ(SSI_DATA_REG_OFFSET);
+
+                /* We do not want this data until it is 'valid',
+                   i.e. we have finished transmitting all the Tx data */
+                if (len_rx < total_tx_count)
+                {
+                    /* Just chuck the read data away */
+                }
+                else
+                {
+	            *rxp++ = value;
+                }
+
+                len_rx++;
+	    }
+        }
+    }
+out:
+    if (flags & SPI_XFER_END)
+    {
+        /*
+	 * If we have finished transmitting and we have no data to receive
+         * wait until the transfer is completely done before we deactivate CS.
+	 */
+        if ((len_tx >= total_tx_count) && (byte_count_rx == 0))
+        {
+            /* Make sure the SPI block has actually started
+               doing something... */
+            udelay (500);
+
+            do
+            {
+	        status = SPI_READ(SSI_STATUS_REG_OFFSET);
+                status &= PC302_SPI_STATUS_BUSY;
+
+	    } while (status);
+        }
+
+	spi_cs_deactivate(slave);
+
+        if (spi_slave->dout_copy)
+        {
+            free(spi_slave->dout_copy);
+            spi_slave->dout_copy = NULL;
+        }
+
+        spi_slave->byte_count_tx = 0;
+    }
+
+    return SUCCESS;
+
+}
+#endif  /* USE_GPIO_AS_CHIP_SELECT */
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+    struct pc302_spi_slave  *spi_slave;
+    u16 chip_select = 0;
+    u32 system_config = 0;
+
+    /* Have we been passed a valid data structure handle ? */
+    if (slave == NULL)
+    {
+        /* Oops, bad handle passed in */
+        printf ("Oops, bad handle passed in, File: %s, Function: %s,"
+                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
+        return;
+    }
+
+    spi_slave = container_of(slave, struct pc302_spi_slave, slave);
+
+    /* Make sure the SPI is disabled */
+    SPI_WRITE(PC302_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);
+
+    /* Obtain the chip select are we using */
+    chip_select =  (u16)spi_slave->slave.cs;
+
+    /* Write to the Slave Enable Register */
+    SPI_WRITE((1 << chip_select), SSI_SLAVE_ENABLE_REG_OFFSET);
+
+    /* Sort out the SPI/EBI chip select muxing.
+       Note: Set all chip select muxing to be SPI */
+    system_config = AXI2CFG_READ(AXI2CFG_SYS_CONFIG_REG_OFFSET);
+    system_config &= ~(AXI2CFG_DECODE_MUX_0 |
+                       AXI2CFG_DECODE_MUX_1 |
+                       AXI2CFG_DECODE_MUX_2 |
+                       AXI2CFG_DECODE_MUX_3);
+
+    AXI2CFG_WRITE(system_config, AXI2CFG_SYS_CONFIG_REG_OFFSET);
+
+#ifdef USE_GPIO_AS_CHIP_SELECT
+    /* Assert the 'cs' */
+    *(unsigned int*)(PC302_GPIO_BASE + GPIO_SW_PORT_A_DR_REG_OFFSET) &=
+                     ~(GPIO_BIT_2);
+#endif
+
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+    struct pc302_spi_slave  *spi_slave;
+    u16 chip_select = 0;
+    u32 system_config = 0;
+
+    /* Have we been passed a valid data structure handle ? */
+    if (slave == NULL)
+    {
+        /* Oops, bad handle passed in */
+        printf ("Oops, bad handle passed in, File: %s, Function: %s,"
+                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
+        return;
+    }
+
+    spi_slave = container_of(slave, struct pc302_spi_slave, slave);
+
+    /* Make sure the SPI is disabled */
+    SPI_WRITE(PC302_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);
+
+    /* Obtain the chip select are we using */
+    chip_select =  (u16)spi_slave->slave.cs;
+
+    /* Write to the Slave Enable Register,
+       Note: Just disable all chip selects for now */
+    SPI_WRITE(PC302_SPI_SLAVES_DISABLE, SSI_SLAVE_ENABLE_REG_OFFSET);
+
+    /* Sort out the SPI/EBI chip select muxing.
+       Note: Set all chip select muxing to be EBI */
+    system_config = AXI2CFG_READ(AXI2CFG_SYS_CONFIG_REG_OFFSET);
+    system_config |= (AXI2CFG_DECODE_MUX_0 |
+                      AXI2CFG_DECODE_MUX_1 |
+                      AXI2CFG_DECODE_MUX_2 |
+                      AXI2CFG_DECODE_MUX_3);
+
+    AXI2CFG_WRITE(system_config, AXI2CFG_SYS_CONFIG_REG_OFFSET);
+
+#ifdef USE_GPIO_AS_CHIP_SELECT
+    /* Negate the 'cs' */
+    *(unsigned int*)(PC302_GPIO_BASE + GPIO_SW_PORT_A_DR_REG_OFFSET) |=
+                     GPIO_BIT_2;
+#endif
+
+}
+
+#endif /* CFG_DW_SPI */
diff --git a/cpu/arm926ejs/pc302/timer.c b/cpu/arm926ejs/pc302/timer.c
new file mode 100644
index 0000000..c9cff17
--- /dev/null
+++ b/cpu/arm926ejs/pc302/timer.c
@@ -0,0 +1,123 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file timer.c
+* \brief Useful functions for timer implementation.
+*
+* Copyright (c) 2006-2008 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/*
+ * (C) Copyright 2003
+ * Texas Instruments <www.ti.com>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * (C) Copyright 2002-2004
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * (C) Copyright 2004
+ * Philippe Robin, ARM Ltd. <philippe.robin@arm.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <arm926ejs.h>
+#include <asm/arch/timer.h>
+
+/*
+ * The timer is a decrementer, it runs at a frequency of CONFIG_SYS_HZ.
+ */
+
+/* We have CONFIG_SYS_HZ timer ticks per second */
+#define TICKS_PER_HZ        (CONFIG_SYS_HZ)
+
+/* The number of clock ticks per 1 uS */
+#define TICKS_PER_US        (TICKS_PER_HZ / (1000 * 1000))
+
+/* The number of clock ticks per 'x' uS */
+#define USEC_TO_COUNT(x)    ((x) * TICKS_PER_US)
+
+/* The time (in seconds) for 'x' timer ticks */
+#define TICKS_TO_HZ(x)	    ((x) / TICKS_PER_HZ)
+
+/* Macro to read the 32 bit timer.
+ * Since the timer decrements, we invert the read value
+ * to give us an incrementing count value.
+ */
+#define READ_TIMER()        ( ~(*(volatile unsigned int *)\
+                                (CFG_TIMERBASE +\
+                                 TIMERNCURRENTVALUEREGOFFSET(0))) )
+
+/* Timer init function */
+int timer_init(void)
+{
+	/* Our timer will have already been started,
+         * therefore we do nothing.
+         */
+
+        return 0;
+}
+
+/* Restart counting from 0 */
+void reset_timer (void)
+{
+        /* Our timer is a free running timer,
+         * we never restart it.
+         */
+}
+
+/* Return how many HZ passed since "base" */
+ulong get_timer (ulong base)
+{
+	return  TICKS_TO_HZ(READ_TIMER()) - base;
+}
+
+/* Delay 'usec' micro seconds */
+void udelay (unsigned long usec)
+{
+	ulong current, end;
+
+	/* Read the current timer value */
+        current = READ_TIMER();
+
+        /* Work out what the final timer value needs to be */
+	end = current + USEC_TO_COUNT(usec);
+
+        while ((signed)(end - READ_TIMER()) > 0)
+        {
+            /* Wait while counting... */
+	    continue;
+        }
+}
diff --git a/cpu/arm926ejs/pc302/utilities.c b/cpu/arm926ejs/pc302/utilities.c
new file mode 100644
index 0000000..4d5fac0
--- /dev/null
+++ b/cpu/arm926ejs/pc302/utilities.c
@@ -0,0 +1,229 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file utilities.c
+* \brief Various useful functions for PC302
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+#include <asm/errno.h>
+#include <asm/arch/pc302.h>
+#include <asm/arch/axi2cfg.h>
+#include <asm/arch/fuse.h>
+#include <asm/arch/utilities.h>
+
+/* Macros ------------------------------------------------------------------ */
+/*!
+ * Bit mask used to obtain the least significant 16 bits
+ */
+#define SIXTEEN_BIT_MASK        (0xFFFF)
+
+/*!
+ * Bit mask used to obtain the device ID
+ */
+#define DEVICE_ID_MASK          (0x000F)
+
+/* Configuration port write bit positions. */
+#define CAEID_BIT_MASK     ( 1 << 19 )    /*!< Bit 19 - AE ID signal. */
+#define CADDR_BIT_MASK     ( 1 << 18 )    /*!< Bit 18 - AE ADDR signal. */
+#define CREAD_BIT_MASK     ( 1 << 17 )    /*!< Bit 17 - READ data signal. */
+#define CWRITE_BIT_MASK    ( 1 << 16 )    /*!< Bit 16 - WRITE data signal. */
+
+#define RB_FAIL_MASK       ( 1 << 17 )    /*!< Bit 17 - readback failed. */
+#define RB_VALID_MASK      ( 1 << 16 )    /*!< Bit 16 - readback valid. */
+
+#define RETRIES ( 10 )                  /*!< The number of retries for an \
+                                         *   AXI2Cfg config read. */
+
+/*! Register offset for the config bus write port (from the axi2cfg2 base
+ *  address). */
+#define AXI2CFG_REG_CFG_WR ( 0x0100 )
+
+/*! Register offset for the config bus read port (from the axi2cfg2 base
+ *  address). */
+#define AXI2CFG_REG_CFG_RD ( 0x0200 )
+
+/* Constants --------------------------------------------------------------- */
+
+/* Types ------------------------------------------------------------------- */
+
+/* Prototypes--------------------------------------------------------------- */
+
+/* Functions --------------------------------------------------------------- */
+__inline unsigned int pc302_read_from_register (const unsigned int address)
+{
+    /* Read an integer (32 bit) value from a register */
+
+    return(*(volatile unsigned int *)address);
+}
+
+__inline void pc302_write_to_register (const unsigned int address,
+                                       const unsigned int value)
+{
+    /* Write an integer value to a register */
+
+    *(volatile unsigned int *)address = value;
+}
+
+unsigned int pc302_read_device_id (void)
+{
+    unsigned int device_id;
+
+    device_id = pc302_read_from_register (PC302_AXI2CFG_BASE +
+                                          AXI2CFG_DEVICE_ID_REG_OFFSET);
+    device_id &= DEVICE_ID_MASK;
+
+    return device_id;
+}
+
+unsigned int pc302_read_device_revision (void)
+{
+    unsigned int revision_code;
+
+    revision_code = pc302_read_from_register (PC302_AXI2CFG_BASE +
+                                              AXI2CFG_REVISION_ID_REG_OFFSET);
+    revision_code &= SIXTEEN_BIT_MASK;
+
+    return revision_code;
+}
+
+void pc302_read_die_id_number (unsigned int * die_number)
+{
+    /* Read the 128 bit manufacturing id from the fuses and store
+       in the provided array */
+
+    unsigned int i;
+
+    for (i = 0; i < 4; i++)
+    {
+        *die_number++ = pc302_read_from_register(PC302_FUSE_BASE +
+                                                 FUSE_MAP_24_REG_OFFSET +
+                                                 (i * sizeof (unsigned int)));
+    }
+}
+
+unsigned int pc302_get_rmii_enabled (void)
+{
+    unsigned int rmii_enabled;
+
+    rmii_enabled = pc302_read_from_register (PC302_AXI2CFG_BASE +
+                                             AXI2CFG_SYS_CONFIG_REG_OFFSET);
+    rmii_enabled &= AXI2CFG_RMII_EN;
+
+    return !!rmii_enabled;
+}
+
+
+/*!
+ * Read a number of 16 bit words from the PC302 axi2cfg.
+ *
+ * @param pa The device to read from.
+ * @param caeid The CAEID of the AE to read from.
+ * @param address The start address in the AE to begin reading from.
+ * @param count The number of 16 bit words to read.
+ * @param[out] data The buffer to store the data in.
+ * @return Returns the number of words read on success, negative on failure.
+ */
+int
+pc302_config_read( u16 caeid,
+                   u16 address,
+                   u16 count,
+                   u16 *data )
+{
+    u32 val;
+    unsigned int write_p = PC302_AXI2CFG_BASE + AXI2CFG_REG_CFG_WR;
+    unsigned int read_p = PC302_AXI2CFG_BASE + AXI2CFG_REG_CFG_RD;
+    u16 to_read = count;
+    u16 rc;
+    unsigned i;
+    unsigned retries;
+
+    val = caeid | CAEID_BIT_MASK;
+    pc302_write_to_register( write_p, val );
+
+    while ( to_read )
+    {
+        /* Output the address to read from. */
+        val = ( address + ( count - to_read ) ) | CADDR_BIT_MASK;
+        pc302_write_to_register( write_p, val );
+
+        /* Dispatch the read requests. */
+        rc = ( to_read > 64 ) ? 64 : to_read;
+        val = CREAD_BIT_MASK | rc;
+        pc302_write_to_register( write_p, val );
+
+        /* Now read the values. */
+        for ( i = 0; i < rc; ++i )
+        {
+            retries = RETRIES;
+            while ( retries )
+            {
+                val = pc302_read_from_register( read_p );
+                if ( val & ( RB_VALID_MASK | RB_FAIL_MASK ) )
+                    break;
+                --retries;
+            }
+
+            if ( !retries || ( val & RB_FAIL_MASK ) )
+            {
+                break;
+            }
+            else
+                data[ ( count - to_read ) + i ] = val & 0xFFFF;
+        }
+
+        if ( val & RB_FAIL_MASK )
+            break;
+
+        to_read -= rc;
+    }
+
+    return !( val & RB_FAIL_MASK ) ? count : -EIO;
+}
+
+/*!
+ * Write a number of 16 bit words to the PC302 axi2cfg.
+ *
+ * @param caeid The CAEID of the AE to write to.
+ * @param address The start address in the AE to begin writing to.
+ * @param count The number of 16 bit words to write.
+ * @param[in] data The buffer to write from.
+ * @return Returns the number of words written on success, negative on failure.
+ */
+int
+pc302_config_write( u16 caeid,
+                    u16 address,
+                    u16 count,
+                    u16 *data )
+{
+    u32 val;
+    unsigned int write_p = PC302_AXI2CFG_BASE + AXI2CFG_REG_CFG_WR;
+    unsigned i;
+
+    val = caeid | CAEID_BIT_MASK;
+    pc302_write_to_register( write_p, val );
+
+    /* Output the address to write to */
+    val = address | CADDR_BIT_MASK;
+    pc302_write_to_register( write_p, val );
+
+    /* Now write the values. */
+    for ( i = 0; i < count; ++i )
+    {
+        val = data[ i ] | CWRITE_BIT_MASK;
+        pc302_write_to_register( write_p, val );
+    }
+
+    return i;
+}
diff --git a/cpu/arm926ejs/start.S b/cpu/arm926ejs/start.S
index a61fa18..220b873 100644
--- a/cpu/arm926ejs/start.S
+++ b/cpu/arm926ejs/start.S
@@ -141,7 +141,16 @@ reset:
 	 */
 #ifndef CONFIG_SKIP_LOWLEVEL_INIT
 	bl	cpu_init_crit
-#endif
+
+#if defined (CONFIG_PICOCHIP_PC20X) || defined (CONFIG_PICOCHIP_PC302)
+        bl      remap_flash
+#endif     
+
+#if defined (CONFIG_PICOCHIP_PC20X)
+        bl      ddr2_dummy_access
+#endif        
+
+#endif /* CONFIG_SKIP_LOWLEVEL_INIT */
 
 #ifndef CONFIG_SKIP_RELOCATE_UBOOT
 relocate:				/* relocate U-Boot to RAM	    */
@@ -160,6 +169,47 @@ copy_loop:
 	stmia	r1!, {r3-r10}		/* copy to   target address [r1]    */
 	cmp	r0, r2			/* until source end addreee [r2]    */
 	ble	copy_loop
+
+#ifndef CONFIG_SKIP_VERIFY_RELOCATE_UBOOT
+        /* verify the copy worked */
+        adr	r0, _start
+	ldr	r1, _TEXT_BASE	
+	ldr	r2, _armboot_start
+	ldr	r3, _bss_start
+        sub	r2, r3, r2
+        add	r2, r0, r2
+
+verify_loop:
+	ldmia	r0!, {r3-r6}		
+	ldmia	r1!, {r7-r10} 
+        cmp     r3,r7
+        bne     verify_error		
+        cmp     r4,r8
+        bne     verify_error		
+        cmp     r5,r9
+        bne     verify_error		
+        cmp     r6,r10
+        bne     verify_error		
+	cmp	r0,r2			
+	ble	verify_loop
+        
+#endif  /* CONFIG_SKIP_VERIFY_RELOCATE_UBOOT */
+
+        /* If we've got here the verify has worked so jump over the error loop */
+                      
+        b       stack_setup 
+
+#ifndef CONFIG_SKIP_VERIFY_RELOCATE_UBOOT
+verify_error:   
+        /* Oops, we've had a verify error... */        
+        bl assertBootError
+        
+verify_error_loop:
+        /* No recovery from this... */
+        b      verify_error_loop  
+
+#endif  /* CONFIG_SKIP_VERIFY_RELOCATE_UBOOT */
+                                     
 #endif	/* CONFIG_SKIP_RELOCATE_UBOOT */
 
 	/* Set up the stack						    */
@@ -214,10 +264,12 @@ cpu_init_crit:
 	 * disable MMU stuff and caches
 	 */
 	mrc	p15, 0, r0, c1, c0, 0
-	bic	r0, r0, #0x00002300	/* clear bits 13, 9:8 (--V- --RS) */
+	/* bic	r0, r0, #0x00002300	 *//* clear bits 13, 9:8 (--V- --RS) */
+        bic	r0, r0, #0x00000300     /* Leave vectors high, for now */
 	bic	r0, r0, #0x00000087	/* clear bits 7, 2:0 (B--- -CAM) */
 	orr	r0, r0, #0x00000002	/* set bit 2 (A) Align */
-	orr	r0, r0, #0x00001000	/* set bit 12 (I) I-Cache */
+	/*orr	r0, r0, #0x00001000*/     /* set bit 12 (I) I-Cache enable */
+	bic	r0, r0, #0x00001000     /* clear bit 12 (I) I-Cache disable */
 	mcr	p15, 0, r0, c1, c0, 0
 
 	/*
diff --git a/cpu/mpc85xx/Makefile b/cpu/mpc85xx/Makefile
index adbc585..1f98fa4 100644
--- a/cpu/mpc85xx/Makefile
+++ b/cpu/mpc85xx/Makefile
@@ -35,7 +35,7 @@ COBJS-$(CONFIG_MP) += mp.o
 COBJS-$(CONFIG_OF_LIBFDT) += fdt.o
 COBJS	= traps.o cpu.o cpu_init.o speed.o interrupts.o tlb.o \
 	  pci.o serial_scc.o commproc.o ether_fcc.o spd_sdram.o qe_io.o \
-	  $(COBJS-y)
+	  cpm_i2c.o $(COBJS-y)
 
 SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
diff --git a/cpu/mpc85xx/cpm_i2c.c b/cpu/mpc85xx/cpm_i2c.c
new file mode 100644
index 0000000..c23de28
--- /dev/null
+++ b/cpu/mpc85xx/cpm_i2c.c
@@ -0,0 +1,813 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Converted from MPC8260 to MPC8560 by david.warman@zetetica.co.uk
+ *
+ * (C) Copyright 2000
+ * Paolo Scaffardi, AIRVENT SAM s.p.a - RIMINI(ITALY), arsenio@tin.it
+ *
+ * (C) Copyright 2000 Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* Note: When using this driver to read the DDR SPD EEPROM, the DDR
+ * is (necessarily) not available.  It seems that using the L1 cache
+ * as a buffer does not work even with global snooping enabled, although
+ * it does work into cached DDR.  So this driver has a local buffer
+ * allocated in dual-port memory, and copies the result back to the
+ * user supplied buffer.  This could be removed if DDR SPD is not needed
+ * and dual-port RAM is in short supply.
+ */
+
+#include <common.h>
+
+#if defined(CONFIG_HARD_I2C) && defined(CONFIG_I2C_ON_CPM)
+
+
+
+#include <asm/cpm_85xx.h>
+#include <i2c.h>
+
+/* define to enable debug messages */
+#undef  DEBUG_I2C
+
+/* uSec to wait between polls of the i2c */
+#define DELAY_US	100
+/* uSec to wait for the CPM to start processing the buffer */
+#define START_DELAY_US	1000
+
+/*
+ * tx/rx per-byte timeout: we delay DELAY_US uSec between polls so the
+ * timeout will be (tx_length + rx_length) * DELAY_US * TOUT_LOOP
+ */
+#define TOUT_LOOP 5
+
+/*-----------------------------------------------------------------------
+ * Set default values
+ */
+#ifndef	CFG_I2C_SPEED
+#define	CFG_I2C_SPEED	50000
+#endif
+
+#ifndef	CFG_I2C_SLAVE
+#define	CFG_I2C_SLAVE	0xFE
+#endif
+/*-----------------------------------------------------------------------
+ */
+
+typedef void (*i2c_ecb_t)(int, int, void *);    /* error callback function */
+
+/* This structure keeps track of the bd and buffer space usage. */
+typedef struct i2c_state {
+	int		rx_idx;		/* index   to next free Rx BD */
+	int		tx_idx;		/* index   to next free Tx BD */
+	void		*rxbd;		/* pointer to next free Rx BD */
+	void		*txbd;		/* pointer to next free Tx BD */
+	int		tx_space;	/* number  of Tx bytes left   */
+	unsigned char	*tx_buf;	/* pointer to free Tx area    */
+	i2c_ecb_t	err_cb;		/* error callback function    */
+	void		*cb_data;	/* private data to be passed  */
+	void		*rx_buf;	/* Rx buffer - non-cached RAM */
+	void		*rx_data;	/* Rx target data - copy here */
+} i2c_state_t;
+
+/* flags for i2c_send() and i2c_receive() */
+#define	I2CF_ENABLE_SECONDARY	0x01	/* secondary_address is valid	*/
+#define	I2CF_START_COND		0x02	/* tx: generate start condition	*/
+#define I2CF_STOP_COND		0x04	/* tx: generate stop  condition	*/
+
+/* return codes */
+#define I2CERR_NO_BUFFERS	1	/* no more BDs or buffer space	*/
+#define I2CERR_MSG_TOO_LONG	2	/* tried to send/receive to much data   */
+#define I2CERR_TIMEOUT		3	/* timeout in i2c_doio()	*/
+#define I2CERR_QUEUE_EMPTY	4	/* i2c_doio called without send/receive */
+#define I2CERR_IO_ERROR		5	/* had an error during comms	*/
+
+/* error callback flags */
+#define I2CECB_RX_ERR		0x10	/* this is a receive error	*/
+#define     I2CECB_RX_OV	0x02	/* receive overrun error	*/
+#define     I2CECB_RX_MASK	0x0f	/* mask for error bits		*/
+#define I2CECB_TX_ERR		0x20	/* this is a transmit error	*/
+#define     I2CECB_TX_CL	0x01	/* transmit collision error	*/
+#define     I2CECB_TX_UN	0x02	/* transmit underflow error	*/
+#define     I2CECB_TX_NAK	0x04	/* transmit no ack error	*/
+#define     I2CECB_TX_MASK	0x0f	/* mask for error bits		*/
+#define I2CECB_TIMEOUT		0x40	/* this is a timeout error	*/
+
+#define ERROR_I2C_NONE		0
+#define ERROR_I2C_LENGTH	1
+
+#define I2C_WRITE_BIT		0x00
+#define I2C_READ_BIT		0x01
+
+#define I2C_RXTX_LEN	128	/* maximum tx/rx buffer length */
+
+
+#define NUM_RX_BDS 4
+#define NUM_TX_BDS 4
+#define MAX_TX_SPACE 256
+
+typedef struct I2C_BD
+{
+  unsigned short status;
+  unsigned short length;
+  unsigned char *addr;
+} I2C_BD;
+#define BD_I2C_TX_START 0x0400  /* special status for i2c: Start condition */
+
+#define BD_I2C_TX_CL	0x0001	/* collision error */
+#define BD_I2C_TX_UN	0x0002	/* underflow error */
+#define BD_I2C_TX_NAK	0x0004	/* no acknowledge error */
+#define BD_I2C_TX_ERR	(BD_I2C_TX_NAK|BD_I2C_TX_UN|BD_I2C_TX_CL)
+
+#define BD_I2C_RX_ERR	BD_SC_OV
+
+#ifdef DEBUG_I2C
+#define PRINTD(x) printf x
+#else
+#define PRINTD(x)
+#endif
+
+/*
+ * Returns the best value of I2BRG to meet desired clock speed of I2C with
+ * input parameters (clock speed, filter, and predivider value).
+ * It returns computer speed value and the difference between it and desired
+ * speed.
+ */
+static inline int
+i2c_roundrate(int hz, int speed, int filter, int modval,
+		int *brgval, int *totspeed)
+{
+    int moddiv = 1 << (5-(modval & 3)), brgdiv, div;
+
+    PRINTD(("\t[I2C] trying hz=%d, speed=%d, filter=%d, modval=%d\n",
+	hz, speed, filter, modval));
+
+    div = moddiv * speed;
+    brgdiv = (hz + div - 1) / div;
+
+    PRINTD(("\t\tmoddiv=%d, brgdiv=%d\n", moddiv, brgdiv));
+
+    *brgval = ((brgdiv + 1) / 2) - 3 - (2*filter);
+
+    if ((*brgval < 0) || (*brgval > 255)) {
+	  PRINTD(("\t\trejected brgval=%d\n", *brgval));
+	  return -1;
+    }
+
+    brgdiv = 2 * (*brgval + 3 + (2 * filter));
+    div = moddiv * brgdiv ;
+    *totspeed = hz / div;
+
+    PRINTD(("\t\taccepted brgval=%d, totspeed=%d\n", *brgval, *totspeed));
+
+    return  0;
+}
+
+/*
+ * Sets the I2C clock predivider and divider to meet required clock speed.
+ */
+static int i2c_setrate(int hz, int speed)
+{
+    volatile ccsr_cpm_t *cpm = (ccsr_cpm_t *)CFG_MPC85xx_CPM_ADDR;
+    volatile ccsr_cpm_i2c_t *i2c = &(cpm->im_cpm_i2c);
+    int brgval,
+	  modval,	/* 0-3 */
+	  bestspeed_diff = speed,
+	  bestspeed_brgval=0,
+	  bestspeed_modval=0,
+	  bestspeed_filter=0,
+	  totspeed,
+	  filter = 0; /* Use this fixed value */
+
+	for (modval = 0; modval < 4; modval++)
+	{
+		if (i2c_roundrate (hz, speed, filter, modval, &brgval, &totspeed) == 0)
+		{
+			int diff = speed - totspeed ;
+
+			if ((diff >= 0) && (diff < bestspeed_diff))
+			{
+				bestspeed_diff 	= diff ;
+				bestspeed_modval 	= modval;
+				bestspeed_brgval 	= brgval;
+				bestspeed_filter 	= filter;
+			}
+		}
+	}
+
+    PRINTD(("[I2C] Best is:\n"));
+    PRINTD(("[I2C] CPU=%dhz RATE=%d F=%d I2MOD=%08x I2BRG=%08x DIFF=%dhz\n",
+		   hz, speed,
+		   bestspeed_filter, bestspeed_modval, bestspeed_brgval,
+		   bestspeed_diff));
+
+    i2c->i2mod |= ((bestspeed_modval & 3) << 1) | (bestspeed_filter << 3);
+    i2c->i2brg = bestspeed_brgval & 0xff;
+
+    PRINTD(("[I2C] i2mod=%08x i2brg=%08x\n", i2c->i2mod, i2c->i2brg));
+
+    return 1 ;
+}
+
+void i2c_init(int speed, int slaveadd)
+{
+        DECLARE_GLOBAL_DATA_PTR;
+        
+ 	volatile ccsr_cpm_t *cpm = (ccsr_cpm_t *)CFG_MPC85xx_CPM_ADDR;
+        volatile ccsr_cpm_cp_t *cp = &(cpm->im_cpm_cp);
+	volatile ccsr_cpm_i2c_t *i2c = &(cpm->im_cpm_i2c);
+	volatile iic_t *iip;
+	ulong rbase, tbase;
+	volatile I2C_BD *rxbd, *txbd;
+	uint dpaddr;
+
+#ifdef CFG_I2C_INIT_BOARD
+	/* call board specific i2c bus reset routine before accessing the   */
+	/* environment, which might be in a chip on that bus. For details   */
+	/* about this problem see doc/I2C_Edge_Conditions.                  */
+	i2c_init_board();
+#endif
+
+	PRINTD(("[I2C] CPM Base %08X DPRAM %08X\n", (unsigned int)cpm,
+		(unsigned int)&(cpm->im_dprambase[PROFF_I2C_BASE])));
+	dpaddr = *((unsigned short*)(&(cpm->im_dprambase[PROFF_I2C_BASE])));
+        /* if (dpaddr == 0) { ** This is different from u-boot 1.1.6, wonder why ? ** */
+	    /* need to allocate dual port ram */
+	    dpaddr = m8560_cpm_dpalloc(64 +
+		(NUM_RX_BDS * sizeof(I2C_BD)) + (NUM_TX_BDS * sizeof(I2C_BD)) +
+		MAX_TX_SPACE + I2C_RXTX_LEN, 64);
+	    *((unsigned short*)&(cpm->im_dprambase[PROFF_I2C_BASE])) = dpaddr;
+	/*}*/
+
+	if (dpaddr == 0) {
+		PRINTD(("[I2C] Dual port allocation failed\n"));
+	} else {
+		PRINTD(("[I2C] Dual port at %08X\n", (unsigned int)dpaddr));
+	}
+	/*
+	 * initialise data in dual port ram:
+	 *
+	 * 	  dpaddr -> parameter ram (64 bytes)
+	 *         rbase -> rx BD         (NUM_RX_BDS * sizeof(I2C_BD) bytes)
+	 *         tbase -> tx BD         (NUM_TX_BDS * sizeof(I2C_BD) bytes)
+	 *                  tx buffer     (MAX_TX_SPACE bytes)
+	 */
+
+	iip = (iic_t *)&(cpm->im_dprambase[dpaddr]);
+	memset((void*)iip, 0, sizeof(iic_t));
+
+	PRINTD(("[I2C] Dual port RAM at %08X\n", (unsigned int)iip));
+	rbase = dpaddr + 64;
+	tbase = rbase + NUM_RX_BDS * sizeof(I2C_BD);
+
+	/* Disable interrupts */
+	i2c->i2mod = 0x00;
+	i2c->i2cmr = 0x00;
+	i2c->i2cer = 0xff;
+	i2c->i2add = slaveadd;
+
+	/*
+	 * Set the I2C BRG Clock division factor from desired i2c rate
+	 * and current CPU rate (we assume sccr dfbgr field is 0;
+	 * divide BRGCLK by 1)
+	 */
+	PRINTD(("[I2C] Setting rate...\n"));
+	i2c_setrate (gd->brg_clk, CFG_I2C_SPEED) ;
+
+	/* Set I2C controller in master mode */
+	i2c->i2com = 0x01;
+
+	/* Initialize Tx/Rx parameters */
+	iip->iic_rbase = rbase;
+	iip->iic_tbase = tbase;
+	rxbd = (I2C_BD *)((unsigned char *)&(cpm->im_dprambase[iip->iic_rbase]));
+	txbd = (I2C_BD *)((unsigned char *)&(cpm->im_dprambase[iip->iic_tbase]));
+
+	PRINTD(("[I2C] rbase = %04x\n", iip->iic_rbase));
+	PRINTD(("[I2C] tbase = %04x\n", iip->iic_tbase));
+	PRINTD(("[I2C] rxbd = %08x\n", (int)rxbd));
+	PRINTD(("[I2C] txbd = %08x\n", (int)txbd));
+
+	/* Set big endian byte order, global snoop enable */
+	/* Global snoop is _essential_ when the data cache is enabled */
+	iip->iic_tfcr = 0x30;
+	iip->iic_rfcr = 0x30;
+
+	/* Set maximum receive size. */
+	iip->iic_mrblr = I2C_RXTX_LEN;
+
+	cp->cpcr = mk_cr_cmd(CPM_CR_I2C_PAGE,
+				CPM_CR_I2C_SBLOCK,
+				0x00,
+				CPM_CR_INIT_TRX) | CPM_CR_FLG;
+    	do {
+		__asm__ __volatile__ ("eieio");
+    	} while (cp->cpcr & CPM_CR_FLG);
+
+	/* Clear events and interrupts */
+	i2c->i2cer = 0xff;
+	i2c->i2cmr = 0x00;
+}
+
+static
+void i2c_newio(i2c_state_t *state)
+{
+	volatile ccsr_cpm_t *cpm = (ccsr_cpm_t *)CFG_MPC85xx_CPM_ADDR;
+        volatile iic_t *iip;
+	uint dpaddr;
+
+	PRINTD(("[I2C] i2c_newio\n"));
+
+	dpaddr = *((unsigned short*)&(cpm->im_dprambase[PROFF_I2C_BASE]));
+	iip = (iic_t *)&(cpm->im_dprambase[dpaddr]);
+	state->rx_idx = 0;
+	state->tx_idx = 0;
+	state->rxbd = (void*)&(cpm->im_dprambase[iip->iic_rbase]);
+	state->txbd = (void*)&(cpm->im_dprambase[iip->iic_tbase]);
+	state->tx_space = MAX_TX_SPACE;
+	state->tx_buf = (uchar*)state->txbd + NUM_TX_BDS * sizeof(I2C_BD);
+	state->rx_buf = (uchar*)state->tx_buf + MAX_TX_SPACE;
+	state->err_cb = NULL;
+	state->cb_data = NULL;
+
+	PRINTD(("[I2C] rxbd = %08x\n", (int)state->rxbd));
+	PRINTD(("[I2C] txbd = %08x\n", (int)state->txbd));
+	PRINTD(("[I2C] tx_buf = %08x\n", (int)state->tx_buf));
+	PRINTD(("[I2C] rx_buf = %08x\n", (int)state->rx_buf));
+
+	/* clear the buffer memory */
+	memset((char *)state->tx_buf, 0, MAX_TX_SPACE);
+}
+
+static
+int i2c_send(i2c_state_t *state,
+			 unsigned char address,
+			 unsigned char secondary_address,
+			 unsigned int flags,
+			 unsigned short size,
+			 unsigned char *dataout)
+{
+	volatile I2C_BD *txbd;
+	int i,j;
+
+	PRINTD(("[I2C] i2c_send add=%02d sec=%02d flag=%02d size=%d\n",
+			address, secondary_address, flags, size));
+
+	/* trying to send message larger than BD */
+	if (size > I2C_RXTX_LEN)
+	  return I2CERR_MSG_TOO_LONG;
+
+	/* no more free bds */
+	if (state->tx_idx >= NUM_TX_BDS || state->tx_space < (2 + size))
+	  return I2CERR_NO_BUFFERS;
+
+	txbd = (I2C_BD *)state->txbd;
+	txbd->addr = state->tx_buf;
+
+	PRINTD(("[I2C] txbd = %08x\n", (int)txbd));
+
+    if (flags & I2CF_START_COND)
+    {
+	PRINTD(("[I2C] Formatting addresses...\n"));
+	if (flags & I2CF_ENABLE_SECONDARY)
+	{
+		txbd->length = size + 2;  /* Length of message plus dest addresses */
+		txbd->addr[0] = address << 1;
+		txbd->addr[1] = secondary_address;
+		i = 2;
+	}
+	else
+	{
+		txbd->length = size + 1;  /* Length of message plus dest address */
+		txbd->addr[0] = address << 1;  /* Write destination address to BD */
+		i = 1;
+	}
+    }
+    else
+    {
+	txbd->length = size;  /* Length of message */
+	i = 0;
+    }
+
+	/* set up txbd */
+	txbd->status = BD_SC_READY;
+	if (flags & I2CF_START_COND)
+	  txbd->status |= BD_I2C_TX_START;
+	if (flags & I2CF_STOP_COND)
+	  txbd->status |= BD_SC_LAST | BD_SC_WRAP;
+
+	/* Copy data to send into buffer */
+	PRINTD(("[I2C] copy data...\n"));
+	for(j = 0; j < size; i++, j++)
+	  txbd->addr[i] = dataout[j];
+
+	PRINTD(("[I2C] txbd: length=0x%04x status=0x%04x addr[0]=0x%02x addr[1]=0x%02x\n",
+		   txbd->length,
+		   txbd->status,
+		   txbd->addr[0],
+		   txbd->addr[1]));
+
+	/* advance state */
+	state->tx_buf += txbd->length;
+	state->tx_space -= txbd->length;
+	state->tx_idx++;
+	state->txbd = (void*)(txbd + 1);
+
+	return 0;
+}
+
+static
+int i2c_receive(i2c_state_t *state,
+				unsigned char address,
+				unsigned char secondary_address,
+				unsigned int flags,
+				unsigned short size_to_expect,
+				unsigned char *datain)
+{
+	volatile I2C_BD *rxbd, *txbd;
+
+	PRINTD(("[I2C] i2c_receive %02d %02d %02d\n", address, secondary_address, flags));
+
+	/* Expected to receive too much */
+	if (size_to_expect > I2C_RXTX_LEN)
+	  return I2CERR_MSG_TOO_LONG;
+
+	/* no more free bds */
+	if (state->tx_idx >= NUM_TX_BDS || state->rx_idx >= NUM_RX_BDS
+		 || state->tx_space < 2)
+	  return I2CERR_NO_BUFFERS;
+
+	rxbd = (I2C_BD *)state->rxbd;
+	txbd = (I2C_BD *)state->txbd;
+
+	PRINTD(("[I2C] rxbd = %08x\n", (int)rxbd));
+	PRINTD(("[I2C] txbd = %08x\n", (int)txbd));
+
+	txbd->addr = state->tx_buf;
+
+	/* set up TXBD for destination address */
+	if (flags & I2CF_ENABLE_SECONDARY)
+	{
+		/* Was as below, changed but not tested yet! FIXME */
+		/* txbd->length = 2; */
+		txbd->length = 2 + size_to_expect;
+		txbd->addr[0] = address << 1;   /* Write data */
+		txbd->addr[1] = secondary_address;  /* Internal address */
+		txbd->status = BD_SC_READY;
+	}
+	else
+	{
+		txbd->length = 1 + size_to_expect;
+		txbd->addr[0] = (address << 1) | 0x01;
+		txbd->status = BD_SC_READY;
+		memset(&txbd->addr[1], 0, txbd->length);
+	}
+
+	/* set up rxbd for reception */
+	rxbd->status = BD_SC_EMPTY;
+	rxbd->length = size_to_expect;
+	rxbd->addr = state->rx_buf;
+	state->rx_data = datain;
+
+	txbd->status |= BD_I2C_TX_START;
+	if (flags & I2CF_STOP_COND)
+	{
+		txbd->status |= BD_SC_LAST | BD_SC_WRAP;
+		rxbd->status |= BD_SC_WRAP;
+	}
+
+	PRINTD(("[I2C] txbd: length=0x%04x status=0x%04x addr[0]=0x%02x addr[1]=0x%02x\n",
+		   txbd->length,
+		   txbd->status,
+		   txbd->addr[0],
+		   txbd->addr[1]));
+	PRINTD(("[I2C] rxbd: length=0x%04x status=0x%04x addr[0]=0x%02x addr[1]=0x%02x\n",
+		   rxbd->length,
+		   rxbd->status,
+		   rxbd->addr[0],
+		   rxbd->addr[1]));
+
+	/* advance state */
+	state->tx_buf += txbd->length;
+	state->tx_space -= txbd->length;
+	state->tx_idx++;
+	state->txbd = (void*)(txbd + 1);
+	state->rx_idx++;
+	state->rxbd = (void*)(rxbd + 1);
+
+	return 0;
+}
+
+
+static
+int i2c_doio(i2c_state_t *state)
+{
+	volatile ccsr_cpm_t *cpm = (ccsr_cpm_t *)CFG_MPC85xx_CPM_ADDR;
+        volatile iic_t *iip;         
+	volatile ccsr_cpm_i2c_t *i2c = &(cpm->im_cpm_i2c);
+	volatile I2C_BD *txbd, *rxbd;
+	int  n, i, b, rxcnt = 0, rxtimeo = 0, txcnt = 0, txtimeo = 0, rc = 0;
+	uint dpaddr;
+
+	PRINTD(("[I2C] i2c_doio\n"));
+
+	if (state->tx_idx <= 0 && state->rx_idx <= 0) {
+		PRINTD(("[I2C] No I/O is queued\n"));
+		return I2CERR_QUEUE_EMPTY;
+	}
+
+	dpaddr = *((unsigned short*)&(cpm->im_dprambase[PROFF_I2C_BASE]));
+	iip = (iic_t *)&(cpm->im_dprambase[dpaddr]);
+	iip->iic_rbptr = iip->iic_rbase;
+	iip->iic_tbptr = iip->iic_tbase;
+
+	/* Enable I2C */
+	PRINTD(("[I2C] Enabling I2C...\n"));
+	i2c->i2mod |= 0x01;
+
+	/* Begin transmission */
+	i2c->i2com |= 0x80;
+
+	/* Loop until transmit & receive completed */
+
+	if ((n = state->tx_idx) > 0) {
+
+		txbd = ((I2C_BD*)state->txbd) - n;
+		for (i = 0; i < n; i++) {
+			txtimeo += TOUT_LOOP * txbd->length;
+			txbd++;
+		}
+
+		txbd--; /* wait until last in list is done */
+
+		PRINTD(("[I2C] Transmitting...(txbd=0x%08lx)\n", (ulong)txbd));
+
+		udelay(START_DELAY_US);	/* give it time to start */
+		while((txbd->status & BD_SC_READY) && (++txcnt < txtimeo)) {
+			udelay(DELAY_US);
+			if (ctrlc())
+				return (-1);
+			__asm__ __volatile__ ("eieio");
+		}
+	}
+        
+	if (txcnt < txtimeo && (n = state->rx_idx) > 0) {
+
+		rxbd = ((I2C_BD*)state->rxbd) - n;
+		for (i = 0; i < n; i++) {
+			rxtimeo += TOUT_LOOP * rxbd->length;
+			rxbd++;
+		}
+
+		rxbd--; /* wait until last in list is done */
+
+		PRINTD(("[I2C] Receiving...(rxbd=0x%08lx)\n", (ulong)rxbd));
+
+		udelay(START_DELAY_US);	/* give it time to start */
+		while((rxbd->status & BD_SC_EMPTY) && (++rxcnt < rxtimeo)) {
+			udelay(DELAY_US);
+			if (ctrlc())
+				return (-1);
+			__asm__ __volatile__ ("eieio");
+		}
+		/* Copy result to final target */
+		memcpy(state->rx_data, rxbd->addr, rxbd->length);
+	}
+
+	/* Turn off I2C */
+	i2c->i2mod &= ~0x01;
+
+	if ((n = state->tx_idx) > 0) {
+		for (i = 0; i < n; i++) {
+			txbd = ((I2C_BD*)state->txbd) - (n - i);
+			if ((b = txbd->status & BD_I2C_TX_ERR) != 0) {
+				if (state->err_cb != NULL)
+					(*state->err_cb)(I2CECB_TX_ERR|b, i,
+						state->cb_data);
+				if (rc == 0)
+					rc = I2CERR_IO_ERROR;
+			}
+		}
+	}
+
+	if ((n = state->rx_idx) > 0) {
+		for (i = 0; i < n; i++) {
+			rxbd = ((I2C_BD*)state->rxbd) - (n - i);
+			if ((b = rxbd->status & BD_I2C_RX_ERR) != 0) {
+				if (state->err_cb != NULL)
+					(*state->err_cb)(I2CECB_RX_ERR|b, i,
+						state->cb_data);
+				if (rc == 0)
+					rc = I2CERR_IO_ERROR;
+			}
+		}
+	}
+
+	if ((txtimeo > 0 && txcnt >= txtimeo) || \
+	    (rxtimeo > 0 && rxcnt >= rxtimeo)) {
+		if (state->err_cb != NULL)
+			(*state->err_cb)(I2CECB_TIMEOUT, -1, state->cb_data);
+		if (rc == 0)
+			rc = I2CERR_TIMEOUT;
+	}
+
+	return (rc);
+}
+
+static void
+i2c_probe_callback(int flags, int xnum, void *data)
+{
+	/*
+	 * the only acceptable errors are a transmit NAK or a receive
+	 * overrun - tx NAK means the device does not exist, rx OV
+	 * means the device must have responded to the slave address
+	 * even though the transfer failed
+	 */
+	if (flags == (I2CECB_TX_ERR|I2CECB_TX_NAK))
+		*(int *)data |= 1;
+	if (flags == (I2CECB_RX_ERR|I2CECB_RX_OV))
+		*(int *)data |= 2;
+}
+
+int
+i2c_probe(uchar chip)
+{
+	i2c_state_t state;
+	int rc, err_flag;
+	uchar buf[1];
+
+	i2c_newio(&state);
+
+	state.err_cb = i2c_probe_callback;
+	state.cb_data = (void *) &err_flag;
+	err_flag = 0;
+
+	rc = i2c_receive(&state, chip, 0, I2CF_START_COND|I2CF_STOP_COND, 1, buf);
+
+	if (rc != 0)
+		return (rc);	/* probe failed */
+
+	rc = i2c_doio(&state);
+
+	if (rc == 0)
+		return (0);	/* device exists - read succeeded */
+
+	if (rc == I2CERR_TIMEOUT)
+		return (-1);	/* device does not exist - timeout */
+
+	if (rc != I2CERR_IO_ERROR || err_flag == 0)
+		return (rc);	/* probe failed */
+
+	if (err_flag & 1)
+		return (-1);	/* device does not exist - had transmit NAK */
+
+	return (0);	/* device exists - had receive overrun */
+}
+
+
+int
+i2c_read(uchar chip, uint addr, int alen, uchar *buffer, int len)
+{
+	i2c_state_t state;
+	uchar xaddr[4];
+	int rc;
+
+	xaddr[0] = (addr >> 24) & 0xFF;
+	xaddr[1] = (addr >> 16) & 0xFF;
+	xaddr[2] = (addr >>  8) & 0xFF;
+	xaddr[3] =  addr        & 0xFF;
+
+#ifdef CFG_I2C_EEPROM_ADDR_OVERFLOW
+	 /*
+	  * EEPROM chips that implement "address overflow" are ones
+	  * like Catalyst 24WC04/08/16 which has 9/10/11 bits of address
+	  * and the extra bits end up in the "chip address" bit slots.
+	  * This makes a 24WC08 (1Kbyte) chip look like four 256 byte
+	  * chips.
+	  *
+	  * Note that we consider the length of the address field to still
+	  * be one byte because the extra address bits are hidden in the
+	  * chip address.
+	  */
+	chip |= ((addr >> (alen * 8)) & CFG_I2C_EEPROM_ADDR_OVERFLOW);
+#endif
+
+	i2c_newio(&state);
+
+	rc = i2c_send(&state, chip, 0, I2CF_START_COND, alen, &xaddr[4-alen]);
+	if (rc != 0) {
+		printf("i2c_read: i2c_send failed (%d)\n", rc);
+		return 1;
+	}
+
+	rc = i2c_receive(&state, chip, 0, I2CF_STOP_COND, len, buffer);
+	if (rc != 0) {
+		printf("i2c_read: i2c_receive failed (%d)\n", rc);
+		return 1;
+	}
+
+	rc = i2c_doio(&state);
+	if (rc != 0) {
+		printf("i2c_read: i2c_doio failed (%d)\n", rc);
+		return 1;
+	}
+	return 0;
+}
+
+int
+i2c_write(uchar chip, uint addr, int alen, uchar *buffer, int len)
+{
+	i2c_state_t state;
+	uchar xaddr[4];
+	int rc;
+
+	xaddr[0] = (addr >> 24) & 0xFF;
+	xaddr[1] = (addr >> 16) & 0xFF;
+	xaddr[2] = (addr >>  8) & 0xFF;
+	xaddr[3] =  addr        & 0xFF;
+
+#ifdef CFG_I2C_EEPROM_ADDR_OVERFLOW
+	 /*
+	  * EEPROM chips that implement "address overflow" are ones
+	  * like Catalyst 24WC04/08/16 which has 9/10/11 bits of address
+	  * and the extra bits end up in the "chip address" bit slots.
+	  * This makes a 24WC08 (1Kbyte) chip look like four 256 byte
+	  * chips.
+	  *
+	  * Note that we consider the length of the address field to still
+	  * be one byte because the extra address bits are hidden in the
+	  * chip address.
+	  */
+	chip |= ((addr >> (alen * 8)) & CFG_I2C_EEPROM_ADDR_OVERFLOW);
+#endif
+
+	i2c_newio(&state);
+
+	rc = i2c_send(&state, chip, 0, I2CF_START_COND, alen, &xaddr[4-alen]);
+	if (rc != 0) {
+		printf("i2c_write: first i2c_send failed (%d)\n", rc);
+		return 1;
+	}
+
+	rc = i2c_send(&state, 0, 0, I2CF_STOP_COND, len, buffer);
+	if (rc != 0) {
+		printf("i2c_write: second i2c_send failed (%d)\n", rc);
+		return 1;
+	}
+
+	rc = i2c_doio(&state);
+	if (rc != 0) {
+		printf("i2c_write: i2c_doio failed (%d)\n", rc);
+		return 1;
+	}
+	return 0;
+}
+
+uchar
+i2c_reg_read(uchar chip, uchar reg)
+{
+	uchar buf;
+
+	i2c_read(chip, reg, 1, &buf, 1);
+
+	return (buf);
+}
+
+void
+i2c_reg_write(uchar chip, uchar reg, uchar val)
+{
+	i2c_write(chip, reg, 1, &val, 1);
+}
+
+unsigned int i2c_get_bus_speed(void)
+{
+        return CFG_I2C_SPEED;
+}
+
+int i2c_set_bus_speed(unsigned int speed)
+{
+        /* Function not currently implemented */
+        return 0;
+}
+
+
+#endif	/* CONFIG_HARD_I2C */
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 7bd22a0..471cd6b 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -25,14 +25,26 @@ include $(TOPDIR)/config.mk
 
 LIB	:= $(obj)libnand.a
 
+ifdef CONFIG_CMD_NAND
+ifndef CONFIG_NAND_LEGACY
 COBJS-y += nand.o
 COBJS-y += nand_base.o
-COBJS-y += nand_ids.o
-COBJS-y += nand_ecc.o
 COBJS-y += nand_bbt.o
+COBJS-y += nand_ecc.o
+COBJS-y += nand_ids.o
 COBJS-y += nand_util.o
+endif
 
-COBJS-y += fsl_upm.o
+COBJS-$(CONFIG_NAND_ATMEL) += atmel_nand.o
+COBJS-$(CONFIG_DRIVER_NAND_BFIN) += bfin_nand.o
+COBJS-$(CONFIG_NAND_DAVINCI) += davinci_nand.o
+COBJS-$(CONFIG_NAND_FSL_ELBC) += fsl_elbc_nand.o
+COBJS-$(CONFIG_NAND_FSL_UPM) += fsl_upm.o
+COBJS-$(CONFIG_NAND_NOMADIK) += nomadik.o
+COBJS-$(CONFIG_NAND_S3C2410) += s3c2410_nand.c
+COBJS-$(CONFIG_NAND_S3C64XX) += s3c64xx.o
+COBJS-$(CONFIG_NAND_OMAP_GPMC) += omap_gpmc.o
+endif
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
diff --git a/drivers/mtd/nand/atmel_nand.c b/drivers/mtd/nand/atmel_nand.c
new file mode 100644
index 0000000..40002be
--- /dev/null
+++ b/drivers/mtd/nand/atmel_nand.c
@@ -0,0 +1,78 @@
+/*
+ * (C) Copyright 2007-2008
+ * Stelian Pop <stelian.pop@leadtechdesign.com>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * (C) Copyright 2006 ATMEL Rousset, Lacressonniere Nicolas
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/at91_pio.h>
+
+#include <nand.h>
+
+static void at91_nand_hwcontrol(struct mtd_info *mtd,
+					 int cmd, unsigned int ctrl)
+{
+	struct nand_chip *this = mtd->priv;
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		ulong IO_ADDR_W = (ulong) this->IO_ADDR_W;
+		IO_ADDR_W &= ~(CONFIG_SYS_NAND_MASK_ALE
+			     | CONFIG_SYS_NAND_MASK_CLE);
+
+		if (ctrl & NAND_CLE)
+			IO_ADDR_W |= CONFIG_SYS_NAND_MASK_CLE;
+		if (ctrl & NAND_ALE)
+			IO_ADDR_W |= CONFIG_SYS_NAND_MASK_ALE;
+
+		at91_set_gpio_value(CONFIG_SYS_NAND_ENABLE_PIN,
+				    !(ctrl & NAND_NCE));
+		this->IO_ADDR_W = (void *) IO_ADDR_W;
+	}
+
+	if (cmd != NAND_CMD_NONE)
+		writeb(cmd, this->IO_ADDR_W);
+}
+
+#ifdef CONFIG_SYS_NAND_READY_PIN
+static int at91_nand_ready(struct mtd_info *mtd)
+{
+	return at91_get_gpio_value(CONFIG_SYS_NAND_READY_PIN);
+}
+#endif
+
+int board_nand_init(struct nand_chip *nand)
+{
+	nand->ecc.mode = NAND_ECC_SOFT;
+#ifdef CONFIG_SYS_NAND_DBW_16
+	nand->options = NAND_BUSWIDTH_16;
+#endif
+	nand->cmd_ctrl = at91_nand_hwcontrol;
+#ifdef CONFIG_SYS_NAND_READY_PIN
+	nand->dev_ready = at91_nand_ready;
+#endif
+	nand->chip_delay = 20;
+
+	return 0;
+}
diff --git a/drivers/mtd/nand/bfin_nand.c b/drivers/mtd/nand/bfin_nand.c
new file mode 100644
index 0000000..f134ef1
--- /dev/null
+++ b/drivers/mtd/nand/bfin_nand.c
@@ -0,0 +1,386 @@
+/*
+ * Driver for Blackfin on-chip NAND controller.
+ *
+ * Enter bugs at http://blackfin.uclinux.org/
+ *
+ * Copyright (c) 2007-2008 Analog Devices Inc.
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+/* TODO:
+ * - move bit defines into mach-common/bits/nand.h
+ * - try and replace all IRQSTAT usage with STAT polling
+ * - have software ecc mode use same algo as hw ecc ?
+ */
+
+#include <common.h>
+#include <asm/io.h>
+
+#ifdef DEBUG
+# define pr_stamp() printf("%s:%s:%i: here i am\n", __FILE__, __func__, __LINE__)
+#else
+# define pr_stamp()
+#endif
+
+#include <nand.h>
+
+#include <asm/blackfin.h>
+
+/* Bit masks for NFC_CTL */
+
+#define                    WR_DLY  0xf        /* Write Strobe Delay */
+#define                    RD_DLY  0xf0       /* Read Strobe Delay */
+#define                    NWIDTH  0x100      /* NAND Data Width */
+#define                   PG_SIZE  0x200      /* Page Size */
+
+/* Bit masks for NFC_STAT */
+
+#define                     NBUSY  0x1        /* Not Busy */
+#define                   WB_FULL  0x2        /* Write Buffer Full */
+#define                PG_WR_STAT  0x4        /* Page Write Pending */
+#define                PG_RD_STAT  0x8        /* Page Read Pending */
+#define                  WB_EMPTY  0x10       /* Write Buffer Empty */
+
+/* Bit masks for NFC_IRQSTAT */
+
+#define                  NBUSYIRQ  0x1        /* Not Busy IRQ */
+#define                    WB_OVF  0x2        /* Write Buffer Overflow */
+#define                   WB_EDGE  0x4        /* Write Buffer Edge Detect */
+#define                    RD_RDY  0x8        /* Read Data Ready */
+#define                   WR_DONE  0x10       /* Page Write Done */
+
+#define NAND_IS_512() (CONFIG_BFIN_NFC_CTL_VAL & 0x200)
+
+/*
+ * hardware specific access to control-lines
+ */
+static void bfin_nfc_cmd_ctrl(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+{
+	pr_stamp();
+
+	if (cmd == NAND_CMD_NONE)
+		return;
+
+	while (bfin_read_NFC_STAT() & WB_FULL)
+		continue;
+
+	if (ctrl & NAND_CLE)
+		bfin_write_NFC_CMD(cmd);
+	else
+		bfin_write_NFC_ADDR(cmd);
+	SSYNC();
+}
+
+int bfin_nfc_devready(struct mtd_info *mtd)
+{
+	pr_stamp();
+	return (bfin_read_NFC_STAT() & NBUSY ? 1 : 0);
+}
+
+/*
+ * PIO mode for buffer writing and reading
+ */
+static void bfin_nfc_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	pr_stamp();
+
+	int i;
+
+	/*
+	 * Data reads are requested by first writing to NFC_DATA_RD
+	* and then reading back from NFC_READ.
+	*/
+	for (i = 0; i < len; ++i) {
+		while (bfin_read_NFC_STAT() & WB_FULL)
+			if (ctrlc())
+				return;
+
+		/* Contents do not matter */
+		bfin_write_NFC_DATA_RD(0x0000);
+		SSYNC();
+
+		while (!(bfin_read_NFC_IRQSTAT() & RD_RDY))
+			if (ctrlc())
+				return;
+
+		buf[i] = bfin_read_NFC_READ();
+
+		bfin_write_NFC_IRQSTAT(RD_RDY);
+	}
+}
+
+static uint8_t bfin_nfc_read_byte(struct mtd_info *mtd)
+{
+	pr_stamp();
+
+	uint8_t val;
+	bfin_nfc_read_buf(mtd, &val, 1);
+	return val;
+}
+
+static void bfin_nfc_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
+{
+	pr_stamp();
+
+	int i;
+
+	for (i = 0; i < len; ++i) {
+		while (bfin_read_NFC_STAT() & WB_FULL)
+			if (ctrlc())
+				return;
+
+		bfin_write_NFC_DATA_WR(buf[i]);
+	}
+}
+
+/*
+ * ECC functions
+ * These allow the bfin to use the controller's ECC
+ * generator block to ECC the data as it passes through
+ */
+
+/*
+ * ECC error correction function
+ */
+static int bfin_nfc_correct_data_256(struct mtd_info *mtd, u_char *dat,
+					u_char *read_ecc, u_char *calc_ecc)
+{
+	u32 syndrome[5];
+	u32 calced, stored;
+	unsigned short failing_bit, failing_byte;
+	u_char data;
+
+	pr_stamp();
+
+	calced = calc_ecc[0] | (calc_ecc[1] << 8) | (calc_ecc[2] << 16);
+	stored = read_ecc[0] | (read_ecc[1] << 8) | (read_ecc[2] << 16);
+
+	syndrome[0] = (calced ^ stored);
+
+	/*
+	 * syndrome 0: all zero
+	 * No error in data
+	 * No action
+	 */
+	if (!syndrome[0] || !calced || !stored)
+		return 0;
+
+	/*
+	 * sysdrome 0: only one bit is one
+	 * ECC data was incorrect
+	 * No action
+	 */
+	if (hweight32(syndrome[0]) == 1)
+		return 1;
+
+	syndrome[1] = (calced & 0x7FF) ^ (stored & 0x7FF);
+	syndrome[2] = (calced & 0x7FF) ^ ((calced >> 11) & 0x7FF);
+	syndrome[3] = (stored & 0x7FF) ^ ((stored >> 11) & 0x7FF);
+	syndrome[4] = syndrome[2] ^ syndrome[3];
+
+	/*
+	 * sysdrome 0: exactly 11 bits are one, each parity
+	 * and parity' pair is 1 & 0 or 0 & 1.
+	 * 1-bit correctable error
+	 * Correct the error
+	 */
+	if (hweight32(syndrome[0]) == 11 && syndrome[4] == 0x7FF) {
+		failing_bit = syndrome[1] & 0x7;
+		failing_byte = syndrome[1] >> 0x3;
+		data = *(dat + failing_byte);
+		data = data ^ (0x1 << failing_bit);
+		*(dat + failing_byte) = data;
+
+		return 0;
+	}
+
+	/*
+	 * sysdrome 0: random data
+	 * More than 1-bit error, non-correctable error
+	 * Discard data, mark bad block
+	 */
+
+	return 1;
+}
+
+static int bfin_nfc_correct_data(struct mtd_info *mtd, u_char *dat,
+					u_char *read_ecc, u_char *calc_ecc)
+{
+	int ret;
+
+	pr_stamp();
+
+	ret = bfin_nfc_correct_data_256(mtd, dat, read_ecc, calc_ecc);
+
+	/* If page size is 512, correct second 256 bytes */
+	if (NAND_IS_512()) {
+		dat += 256;
+		read_ecc += 8;
+		calc_ecc += 8;
+		ret |= bfin_nfc_correct_data_256(mtd, dat, read_ecc, calc_ecc);
+	}
+
+	return ret;
+}
+
+static void reset_ecc(void)
+{
+	bfin_write_NFC_RST(0x1);
+	while (bfin_read_NFC_RST() & 1)
+		continue;
+}
+
+static void bfin_nfc_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	reset_ecc();
+}
+
+static int bfin_nfc_calculate_ecc(struct mtd_info *mtd,
+		const u_char *dat, u_char *ecc_code)
+{
+	u16 ecc0, ecc1;
+	u32 code[2];
+	u8 *p;
+
+	pr_stamp();
+
+	/* first 4 bytes ECC code for 256 page size */
+	ecc0 = bfin_read_NFC_ECC0();
+	ecc1 = bfin_read_NFC_ECC1();
+
+	code[0] = (ecc0 & 0x7FF) | ((ecc1 & 0x7FF) << 11);
+
+	/* first 3 bytes in ecc_code for 256 page size */
+	p = (u8 *) code;
+	memcpy(ecc_code, p, 3);
+
+	/* second 4 bytes ECC code for 512 page size */
+	if (NAND_IS_512()) {
+		ecc0 = bfin_read_NFC_ECC2();
+		ecc1 = bfin_read_NFC_ECC3();
+		code[1] = (ecc0 & 0x7FF) | ((ecc1 & 0x7FF) << 11);
+
+		/* second 3 bytes in ecc_code for second 256
+		 * bytes of 512 page size
+		 */
+		p = (u8 *) (code + 1);
+		memcpy((ecc_code + 3), p, 3);
+	}
+
+	reset_ecc();
+
+	return 0;
+}
+
+#ifdef CONFIG_BFIN_NFC_BOOTROM_ECC
+# define BOOTROM_ECC 1
+#else
+# define BOOTROM_ECC 0
+#endif
+
+static uint8_t bbt_pattern[] = { 0xff };
+
+static struct nand_bbt_descr bootrom_bbt = {
+	.options = 0,
+	.offs = 63,
+	.len = 1,
+	.pattern = bbt_pattern,
+};
+
+static struct nand_ecclayout bootrom_ecclayout = {
+	.eccbytes = 24,
+	.eccpos = {
+		0x8 * 0, 0x8 * 0 + 1, 0x8 * 0 + 2,
+		0x8 * 1, 0x8 * 1 + 1, 0x8 * 1 + 2,
+		0x8 * 2, 0x8 * 2 + 1, 0x8 * 2 + 2,
+		0x8 * 3, 0x8 * 3 + 1, 0x8 * 3 + 2,
+		0x8 * 4, 0x8 * 4 + 1, 0x8 * 4 + 2,
+		0x8 * 5, 0x8 * 5 + 1, 0x8 * 5 + 2,
+		0x8 * 6, 0x8 * 6 + 1, 0x8 * 6 + 2,
+		0x8 * 7, 0x8 * 7 + 1, 0x8 * 7 + 2
+	},
+	.oobfree = {
+		{ 0x8 * 0 + 3, 5 },
+		{ 0x8 * 1 + 3, 5 },
+		{ 0x8 * 2 + 3, 5 },
+		{ 0x8 * 3 + 3, 5 },
+		{ 0x8 * 4 + 3, 5 },
+		{ 0x8 * 5 + 3, 5 },
+		{ 0x8 * 6 + 3, 5 },
+		{ 0x8 * 7 + 3, 5 },
+	}
+};
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - cmd_ctrl: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - ecc.mode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+int board_nand_init(struct nand_chip *chip)
+{
+	pr_stamp();
+
+	/* set width/ecc/timings/etc... */
+	bfin_write_NFC_CTL(CONFIG_BFIN_NFC_CTL_VAL);
+
+	/* clear interrupt status */
+	bfin_write_NFC_IRQMASK(0x0);
+	bfin_write_NFC_IRQSTAT(0xffff);
+
+	/* enable GPIO function enable register */
+#ifdef __ADSPBF54x__
+	bfin_write_PORTJ_FER(bfin_read_PORTJ_FER() | 6);
+#elif defined(__ADSPBF52x__)
+	bfin_write_PORTH_FER(bfin_read_PORTH_FER() | 0xFCFF);
+	bfin_write_PORTH_MUX(0);
+#else
+# error no support for this variant
+#endif
+
+	chip->cmd_ctrl = bfin_nfc_cmd_ctrl;
+	chip->read_buf = bfin_nfc_read_buf;
+	chip->write_buf = bfin_nfc_write_buf;
+	chip->read_byte = bfin_nfc_read_byte;
+
+#ifdef CONFIG_BFIN_NFC_NO_HW_ECC
+# define ECC_HW 0
+#else
+# define ECC_HW 1
+#endif
+	if (ECC_HW) {
+		if (BOOTROM_ECC) {
+			chip->badblock_pattern = &bootrom_bbt;
+			chip->ecc.layout = &bootrom_ecclayout;
+		}
+		if (!NAND_IS_512()) {
+			chip->ecc.bytes = 3;
+			chip->ecc.size = 256;
+		} else {
+			chip->ecc.bytes = 6;
+			chip->ecc.size = 512;
+		}
+		chip->ecc.mode = NAND_ECC_HW;
+		chip->ecc.calculate = bfin_nfc_calculate_ecc;
+		chip->ecc.correct   = bfin_nfc_correct_data;
+		chip->ecc.hwctl     = bfin_nfc_enable_hwecc;
+	} else
+		chip->ecc.mode = NAND_ECC_SOFT;
+	chip->dev_ready = bfin_nfc_devready;
+	chip->chip_delay = 0;
+
+	return 0;
+}
diff --git a/drivers/mtd/nand/davinci_nand.c b/drivers/mtd/nand/davinci_nand.c
new file mode 100644
index 0000000..a974667
--- /dev/null
+++ b/drivers/mtd/nand/davinci_nand.c
@@ -0,0 +1,466 @@
+/*
+ * NAND driver for TI DaVinci based boards.
+ *
+ * Copyright (C) 2007 Sergey Kubushyn <ksi@koi8.net>
+ *
+ * Based on Linux DaVinci NAND driver by TI. Original copyright follows:
+ */
+
+/*
+ *
+ * linux/drivers/mtd/nand/nand_davinci.c
+ *
+ * NAND Flash Driver
+ *
+ * Copyright (C) 2006 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ *
+ *  Overview:
+ *   This is a device driver for the NAND flash device found on the
+ *   DaVinci board which utilizes the Samsung k9k2g08 part.
+ *
+ Modifications:
+ ver. 1.0: Feb 2005, Vinod/Sudhakar
+ -
+ *
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <nand.h>
+#include <asm/arch/nand_defs.h>
+#include <asm/arch/emif_defs.h>
+
+extern struct nand_chip nand_dev_desc[CONFIG_SYS_MAX_NAND_DEVICE];
+
+static void nand_davinci_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+{
+	struct		nand_chip *this = mtd->priv;
+	u_int32_t	IO_ADDR_W = (u_int32_t)this->IO_ADDR_W;
+
+	IO_ADDR_W &= ~(MASK_ALE|MASK_CLE);
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		if ( ctrl & NAND_CLE )
+			IO_ADDR_W |= MASK_CLE;
+		if ( ctrl & NAND_ALE )
+			IO_ADDR_W |= MASK_ALE;
+		this->IO_ADDR_W = (void __iomem *) IO_ADDR_W;
+	}
+
+	if (cmd != NAND_CMD_NONE)
+		writeb(cmd, this->IO_ADDR_W);
+}
+
+/* Set WP on deselect, write enable on select */
+static void nand_davinci_select_chip(struct mtd_info *mtd, int chip)
+{
+#define GPIO_SET_DATA01	0x01c67018
+#define GPIO_CLR_DATA01	0x01c6701c
+#define GPIO_NAND_WP	(1 << 4)
+#ifdef SONATA_BOARD_GPIOWP
+	if (chip < 0) {
+		REG(GPIO_CLR_DATA01) |= GPIO_NAND_WP;
+	} else {
+		REG(GPIO_SET_DATA01) |= GPIO_NAND_WP;
+	}
+#endif
+}
+
+#ifdef CONFIG_SYS_NAND_HW_ECC
+#ifdef CONFIG_SYS_DAVINCI_BROKEN_ECC
+/* Linux-compatible ECC uses MTD defaults. */
+/* These layouts are not compatible with Linux or RBL/UBL. */
+#ifdef CONFIG_SYS_NAND_LARGEPAGE
+static struct nand_ecclayout davinci_nand_ecclayout = {
+	.eccbytes = 12,
+	.eccpos = {8, 9, 10, 24, 25, 26, 40, 41, 42, 56, 57, 58},
+	.oobfree = {
+		{.offset = 2, .length = 6},
+		{.offset = 12, .length = 12},
+		{.offset = 28, .length = 12},
+		{.offset = 44, .length = 12},
+		{.offset = 60, .length = 4}
+	}
+};
+#elif defined(CONFIG_SYS_NAND_SMALLPAGE)
+static struct nand_ecclayout davinci_nand_ecclayout = {
+	.eccbytes = 3,
+	.eccpos = {0, 1, 2},
+	.oobfree = {
+		{.offset = 6, .length = 2},
+		{.offset = 8, .length = 8}
+	}
+};
+#else
+#error "Either CONFIG_SYS_NAND_LARGEPAGE or CONFIG_SYS_NAND_SMALLPAGE must be defined!"
+#endif
+#endif /* CONFIG_SYS_DAVINCI_BROKEN_ECC */
+
+static void nand_davinci_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	emifregs	emif_addr;
+	int		dummy;
+
+	emif_addr = (emifregs)DAVINCI_ASYNC_EMIF_CNTRL_BASE;
+
+	dummy = emif_addr->NANDF1ECC;
+	dummy = emif_addr->NANDF2ECC;
+	dummy = emif_addr->NANDF3ECC;
+	dummy = emif_addr->NANDF4ECC;
+
+	emif_addr->NANDFCR |= (1 << 8);
+}
+
+static u_int32_t nand_davinci_readecc(struct mtd_info *mtd, u_int32_t region)
+{
+	u_int32_t	ecc = 0;
+	emifregs	emif_base_addr;
+
+	emif_base_addr = (emifregs)DAVINCI_ASYNC_EMIF_CNTRL_BASE;
+
+	if (region == 1)
+		ecc = emif_base_addr->NANDF1ECC;
+	else if (region == 2)
+		ecc = emif_base_addr->NANDF2ECC;
+	else if (region == 3)
+		ecc = emif_base_addr->NANDF3ECC;
+	else if (region == 4)
+		ecc = emif_base_addr->NANDF4ECC;
+
+	return(ecc);
+}
+
+static int nand_davinci_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)
+{
+	u_int32_t		tmp;
+#ifdef CONFIG_SYS_DAVINCI_BROKEN_ECC
+	/*
+	 * This is not how you should read ECCs on large page Davinci devices.
+	 * The region parameter gets you ECCs for flash chips on different chip
+	 * selects, not the 4x512 byte pages in a 2048 byte page.
+	 *
+	 * Preserved for backwards compatibility though.
+	 */
+
+	int			region, n;
+	struct nand_chip	*this = mtd->priv;
+
+	n = (this->ecc.size/512);
+
+	region = 1;
+	while (n--) {
+		tmp = nand_davinci_readecc(mtd, region);
+		*ecc_code++ = tmp;
+		*ecc_code++ = tmp >> 16;
+		*ecc_code++ = ((tmp >> 8) & 0x0f) | ((tmp >> 20) & 0xf0);
+		region++;
+	}
+#else
+	const int region = 1;
+
+	tmp = nand_davinci_readecc(mtd, region);
+
+	/* Squeeze 4 bytes ECC into 3 bytes by removing RESERVED bits
+	 * and shifting. RESERVED bits are 31 to 28 and 15 to 12. */
+	tmp = (tmp & 0x00000fff) | ((tmp & 0x0fff0000) >> 4);
+
+	/* Invert so that erased block ECC is correct */
+	tmp = ~tmp;
+
+	*ecc_code++ = tmp;
+	*ecc_code++ = tmp >>  8;
+	*ecc_code++ = tmp >> 16;
+#endif /* CONFIG_SYS_DAVINCI_BROKEN_ECC */
+	return(0);
+}
+
+#ifdef CONFIG_SYS_DAVINCI_BROKEN_ECC
+static void nand_davinci_gen_true_ecc(u_int8_t *ecc_buf)
+{
+	u_int32_t	tmp = ecc_buf[0] | (ecc_buf[1] << 16) | ((ecc_buf[2] & 0xf0) << 20) | ((ecc_buf[2] & 0x0f) << 8);
+
+	ecc_buf[0] = ~(P64o(tmp) | P64e(tmp) | P32o(tmp) | P32e(tmp) | P16o(tmp) | P16e(tmp) | P8o(tmp) | P8e(tmp));
+	ecc_buf[1] = ~(P1024o(tmp) | P1024e(tmp) | P512o(tmp) | P512e(tmp) | P256o(tmp) | P256e(tmp) | P128o(tmp) | P128e(tmp));
+	ecc_buf[2] = ~( P4o(tmp) | P4e(tmp) | P2o(tmp) | P2e(tmp) | P1o(tmp) | P1e(tmp) | P2048o(tmp) | P2048e(tmp));
+}
+
+static int nand_davinci_compare_ecc(u_int8_t *ecc_nand, u_int8_t *ecc_calc, u_int8_t *page_data)
+{
+	u_int32_t	i;
+	u_int8_t	tmp0_bit[8], tmp1_bit[8], tmp2_bit[8];
+	u_int8_t	comp0_bit[8], comp1_bit[8], comp2_bit[8];
+	u_int8_t	ecc_bit[24];
+	u_int8_t	ecc_sum = 0;
+	u_int8_t	find_bit = 0;
+	u_int32_t	find_byte = 0;
+	int		is_ecc_ff;
+
+	is_ecc_ff = ((*ecc_nand == 0xff) && (*(ecc_nand + 1) == 0xff) && (*(ecc_nand + 2) == 0xff));
+
+	nand_davinci_gen_true_ecc(ecc_nand);
+	nand_davinci_gen_true_ecc(ecc_calc);
+
+	for (i = 0; i <= 2; i++) {
+		*(ecc_nand + i) = ~(*(ecc_nand + i));
+		*(ecc_calc + i) = ~(*(ecc_calc + i));
+	}
+
+	for (i = 0; i < 8; i++) {
+		tmp0_bit[i] = *ecc_nand % 2;
+		*ecc_nand = *ecc_nand / 2;
+	}
+
+	for (i = 0; i < 8; i++) {
+		tmp1_bit[i] = *(ecc_nand + 1) % 2;
+		*(ecc_nand + 1) = *(ecc_nand + 1) / 2;
+	}
+
+	for (i = 0; i < 8; i++) {
+		tmp2_bit[i] = *(ecc_nand + 2) % 2;
+		*(ecc_nand + 2) = *(ecc_nand + 2) / 2;
+	}
+
+	for (i = 0; i < 8; i++) {
+		comp0_bit[i] = *ecc_calc % 2;
+		*ecc_calc = *ecc_calc / 2;
+	}
+
+	for (i = 0; i < 8; i++) {
+		comp1_bit[i] = *(ecc_calc + 1) % 2;
+		*(ecc_calc + 1) = *(ecc_calc + 1) / 2;
+	}
+
+	for (i = 0; i < 8; i++) {
+		comp2_bit[i] = *(ecc_calc + 2) % 2;
+		*(ecc_calc + 2) = *(ecc_calc + 2) / 2;
+	}
+
+	for (i = 0; i< 6; i++)
+		ecc_bit[i] = tmp2_bit[i + 2] ^ comp2_bit[i + 2];
+
+	for (i = 0; i < 8; i++)
+		ecc_bit[i + 6] = tmp0_bit[i] ^ comp0_bit[i];
+
+	for (i = 0; i < 8; i++)
+		ecc_bit[i + 14] = tmp1_bit[i] ^ comp1_bit[i];
+
+	ecc_bit[22] = tmp2_bit[0] ^ comp2_bit[0];
+	ecc_bit[23] = tmp2_bit[1] ^ comp2_bit[1];
+
+	for (i = 0; i < 24; i++)
+		ecc_sum += ecc_bit[i];
+
+	switch (ecc_sum) {
+		case 0:
+			/* Not reached because this function is not called if
+			   ECC values are equal */
+			return 0;
+		case 1:
+			/* Uncorrectable error */
+			MTDDEBUG (MTD_DEBUG_LEVEL0,
+			          "ECC UNCORRECTED_ERROR 1\n");
+			return(-1);
+		case 12:
+			/* Correctable error */
+			find_byte = (ecc_bit[23] << 8) +
+				(ecc_bit[21] << 7) +
+				(ecc_bit[19] << 6) +
+				(ecc_bit[17] << 5) +
+				(ecc_bit[15] << 4) +
+				(ecc_bit[13] << 3) +
+				(ecc_bit[11] << 2) +
+				(ecc_bit[9]  << 1) +
+				ecc_bit[7];
+
+			find_bit = (ecc_bit[5] << 2) + (ecc_bit[3] << 1) + ecc_bit[1];
+
+			MTDDEBUG (MTD_DEBUG_LEVEL0, "Correcting single bit ECC "
+			          "error at offset: %d, bit: %d\n",
+			          find_byte, find_bit);
+
+			page_data[find_byte] ^= (1 << find_bit);
+
+			return(0);
+		default:
+			if (is_ecc_ff) {
+				if (ecc_calc[0] == 0 && ecc_calc[1] == 0 && ecc_calc[2] == 0)
+					return(0);
+			}
+			MTDDEBUG (MTD_DEBUG_LEVEL0,
+			          "UNCORRECTED_ERROR default\n");
+			return(-1);
+	}
+}
+#endif /* CONFIG_SYS_DAVINCI_BROKEN_ECC */
+
+static int nand_davinci_correct_data(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc)
+{
+	struct nand_chip *this = mtd->priv;
+#ifdef CONFIG_SYS_DAVINCI_BROKEN_ECC
+	int			block_count = 0, i, rc;
+
+	block_count = (this->ecc.size/512);
+	for (i = 0; i < block_count; i++) {
+		if (memcmp(read_ecc, calc_ecc, 3) != 0) {
+			rc = nand_davinci_compare_ecc(read_ecc, calc_ecc, dat);
+			if (rc < 0) {
+				return(rc);
+			}
+		}
+		read_ecc += 3;
+		calc_ecc += 3;
+		dat += 512;
+	}
+#else
+	u_int32_t ecc_nand = read_ecc[0] | (read_ecc[1] << 8) |
+					  (read_ecc[2] << 16);
+	u_int32_t ecc_calc = calc_ecc[0] | (calc_ecc[1] << 8) |
+					  (calc_ecc[2] << 16);
+	u_int32_t diff = ecc_calc ^ ecc_nand;
+
+	if (diff) {
+		if ((((diff >> 12) ^ diff) & 0xfff) == 0xfff) {
+			/* Correctable error */
+			if ((diff >> (12 + 3)) < this->ecc.size) {
+				uint8_t find_bit = 1 << ((diff >> 12) & 7);
+				uint32_t find_byte = diff >> (12 + 3);
+
+				dat[find_byte] ^= find_bit;
+				MTDDEBUG(MTD_DEBUG_LEVEL0, "Correcting single "
+					 "bit ECC error at offset: %d, bit: "
+					 "%d\n", find_byte, find_bit);
+				return 1;
+			} else {
+				return -1;
+			}
+		} else if (!(diff & (diff - 1))) {
+			/* Single bit ECC error in the ECC itself,
+			   nothing to fix */
+			MTDDEBUG(MTD_DEBUG_LEVEL0, "Single bit ECC error in "
+				 "ECC.\n");
+			return 1;
+		} else {
+			/* Uncorrectable error */
+			MTDDEBUG(MTD_DEBUG_LEVEL0, "ECC UNCORRECTED_ERROR 1\n");
+			return -1;
+		}
+	}
+#endif /* CONFIG_SYS_DAVINCI_BROKEN_ECC */
+	return(0);
+}
+#endif /* CONFIG_SYS_NAND_HW_ECC */
+
+static int nand_davinci_dev_ready(struct mtd_info *mtd)
+{
+	emifregs	emif_addr;
+
+	emif_addr = (emifregs)DAVINCI_ASYNC_EMIF_CNTRL_BASE;
+
+	return(emif_addr->NANDFSR & 0x1);
+}
+
+static int nand_davinci_waitfunc(struct mtd_info *mtd, struct nand_chip *this)
+{
+	while(!nand_davinci_dev_ready(mtd)) {;}
+	*NAND_CE0CLE = NAND_STATUS;
+	return(*NAND_CE0DATA);
+}
+
+static void nand_flash_init(void)
+{
+	u_int32_t	acfg1 = 0x3ffffffc;
+	u_int32_t	acfg2 = 0x3ffffffc;
+	u_int32_t	acfg3 = 0x3ffffffc;
+	u_int32_t	acfg4 = 0x3ffffffc;
+	emifregs	emif_regs;
+
+	/*------------------------------------------------------------------*
+	 *  NAND FLASH CHIP TIMEOUT @ 459 MHz                               *
+	 *                                                                  *
+	 *  AEMIF.CLK freq   = PLL1/6 = 459/6 = 76.5 MHz                    *
+	 *  AEMIF.CLK period = 1/76.5 MHz = 13.1 ns                         *
+	 *                                                                  *
+	 *------------------------------------------------------------------*/
+	 acfg1 = 0
+		| (0 << 31 )	/* selectStrobe */
+		| (0 << 30 )	/* extWait */
+		| (1 << 26 )	/* writeSetup	10 ns */
+		| (3 << 20 )	/* writeStrobe	40 ns */
+		| (1 << 17 )	/* writeHold	10 ns */
+		| (1 << 13 )	/* readSetup	10 ns */
+		| (5 << 7 )	/* readStrobe	60 ns */
+		| (1 << 4 )	/* readHold	10 ns */
+		| (3 << 2 )	/* turnAround	?? ns */
+		| (0 << 0 )	/* asyncSize	8-bit bus */
+		;
+
+	emif_regs = (emifregs)DAVINCI_ASYNC_EMIF_CNTRL_BASE;
+
+	emif_regs->AWCCR |= 0x10000000;
+	emif_regs->AB1CR = acfg1;	/* 0x08244128 */;
+	emif_regs->AB2CR = acfg2;
+	emif_regs->AB3CR = acfg3;
+	emif_regs->AB4CR = acfg4;
+	emif_regs->NANDFCR = 0x00000101;
+}
+
+int board_nand_init(struct nand_chip *nand)
+{
+	nand->IO_ADDR_R   = (void  __iomem *)NAND_CE0DATA;
+	nand->IO_ADDR_W   = (void  __iomem *)NAND_CE0DATA;
+	nand->chip_delay  = 0;
+	nand->select_chip = nand_davinci_select_chip;
+#ifdef CONFIG_SYS_NAND_USE_FLASH_BBT
+	nand->options	  = NAND_USE_FLASH_BBT;
+#endif
+#ifdef CONFIG_SYS_NAND_HW_ECC
+	nand->ecc.mode = NAND_ECC_HW;
+#ifdef CONFIG_SYS_DAVINCI_BROKEN_ECC
+	nand->ecc.layout  = &davinci_nand_ecclayout;
+#ifdef CONFIG_SYS_NAND_LARGEPAGE
+	nand->ecc.size = 2048;
+	nand->ecc.bytes = 12;
+#elif defined(CONFIG_SYS_NAND_SMALLPAGE)
+	nand->ecc.size = 512;
+	nand->ecc.bytes = 3;
+#else
+#error "Either CONFIG_SYS_NAND_LARGEPAGE or CONFIG_SYS_NAND_SMALLPAGE must be defined!"
+#endif
+#else
+	nand->ecc.size = 512;
+	nand->ecc.bytes = 3;
+#endif /* CONFIG_SYS_DAVINCI_BROKEN_ECC */
+	nand->ecc.calculate = nand_davinci_calculate_ecc;
+	nand->ecc.correct  = nand_davinci_correct_data;
+	nand->ecc.hwctl  = nand_davinci_enable_hwecc;
+#else
+	nand->ecc.mode = NAND_ECC_SOFT;
+#endif /* CONFIG_SYS_NAND_HW_ECC */
+
+	/* Set address of hardware control function */
+	nand->cmd_ctrl = nand_davinci_hwcontrol;
+
+	nand->dev_ready = nand_davinci_dev_ready;
+	nand->waitfunc = nand_davinci_waitfunc;
+
+	nand_flash_init();
+
+	return(0);
+}
diff --git a/drivers/mtd/nand/diskonchip.c b/drivers/mtd/nand/diskonchip.c
index fdd85c1..e9dc4d1 100644
--- a/drivers/mtd/nand/diskonchip.c
+++ b/drivers/mtd/nand/diskonchip.c
@@ -15,13 +15,11 @@
  * converted to the generic Reed-Solomon library by Thomas Gleixner <tglx@linutronix.de>
  *
  * Interface to generic NAND code for M-Systems DiskOnChip devices
- *
- * $Id: diskonchip.c,v 1.45 2005/01/05 18:05:14 dwmw2 Exp $
  */
 
 #include <common.h>
 
-#if !defined(CFG_NAND_LEGACY)
+#if !defined(CONFIG_NAND_LEGACY)
 
 #include <linux/kernel.h>
 #include <linux/init.h>
@@ -39,13 +37,13 @@
 #include <linux/mtd/inftl.h>
 
 /* Where to look for the devices? */
-#ifndef CONFIG_MTD_DISKONCHIP_PROBE_ADDRESS
-#define CONFIG_MTD_DISKONCHIP_PROBE_ADDRESS 0
+#ifndef CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADDRESS
+#define CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADDRESS 0
 #endif
 
 static unsigned long __initdata doc_locations[] = {
 #if defined (__alpha__) || defined(__i386__) || defined(__x86_64__)
-#ifdef CONFIG_MTD_DISKONCHIP_PROBE_HIGH
+#ifdef CONFIG_MTD_NAND_DISKONCHIP_PROBE_HIGH
 	0xfffc8000, 0xfffca000, 0xfffcc000, 0xfffce000,
 	0xfffd0000, 0xfffd2000, 0xfffd4000, 0xfffd6000,
 	0xfffd8000, 0xfffda000, 0xfffdc000, 0xfffde000,
@@ -58,14 +56,7 @@ static unsigned long __initdata doc_locations[] = {
 	0xe0000, 0xe2000, 0xe4000, 0xe6000,
 	0xe8000, 0xea000, 0xec000, 0xee000,
 #endif /*  CONFIG_MTD_DOCPROBE_HIGH */
-#elif defined(__PPC__)
-	0xe4000000,
-#elif defined(CONFIG_MOMENCO_OCELOT)
-	0x2f000000,
-	0xff000000,
-#elif defined(CONFIG_MOMENCO_OCELOT_G) || defined (CONFIG_MOMENCO_OCELOT_C)
-	0xff000000,
-##else
+#else
 #warning Unknown architecture for DiskOnChip. No default probe locations defined
 #endif
 	0xffffffff };
@@ -77,7 +68,7 @@ struct doc_priv {
 	unsigned long physadr;
 	u_char ChipID;
 	u_char CDSNControl;
-	int chips_per_floor; /* The number of chips detected on each floor */
+	int chips_per_floor;	/* The number of chips detected on each floor */
 	int curfloor;
 	int curchip;
 	int mh0_page;
@@ -85,14 +76,10 @@ struct doc_priv {
 	struct mtd_info *nextdoc;
 };
 
-/* Max number of eraseblocks to scan (from start of device) for the (I)NFTL
-   MediaHeader.  The spec says to just keep going, I think, but that's just
-   silly. */
-#define MAX_MEDIAHEADER_SCAN 8
-
 /* This is the syndrome computed by the HW ecc generator upon reading an empty
    page, one with all 0xff for data and stored ecc code. */
 static u_char empty_read_syndrome[6] = { 0x26, 0xff, 0x6d, 0x47, 0x73, 0x7a };
+
 /* This is the ecc value computed by the HW ecc generator upon writing an empty
    page, one with all 0xff for data. */
 static u_char empty_write_ecc[6] = { 0x4b, 0x00, 0xe2, 0x0e, 0x93, 0xf7 };
@@ -103,35 +90,36 @@ static u_char empty_write_ecc[6] = { 0x4b, 0x00, 0xe2, 0x0e, 0x93, 0xf7 };
 #define DoC_is_Millennium(doc) ((doc)->ChipID == DOC_ChipID_DocMil)
 #define DoC_is_2000(doc) ((doc)->ChipID == DOC_ChipID_Doc2k)
 
-static void doc200x_hwcontrol(struct mtd_info *mtd, int cmd);
+static void doc200x_hwcontrol(struct mtd_info *mtd, int cmd,
+			      unsigned int bitmask);
 static void doc200x_select_chip(struct mtd_info *mtd, int chip);
 
-static int debug=0;
+static int debug = 0;
 module_param(debug, int, 0);
 
-static int try_dword=1;
+static int try_dword = 1;
 module_param(try_dword, int, 0);
 
-static int no_ecc_failures=0;
+static int no_ecc_failures = 0;
 module_param(no_ecc_failures, int, 0);
 
-#ifdef CONFIG_MTD_PARTITIONS
-static int no_autopart=0;
+static int no_autopart = 0;
 module_param(no_autopart, int, 0);
-#endif
 
-#ifdef MTD_NAND_DISKONCHIP_BBTWRITE
-static int inftl_bbt_write=1;
+static int show_firmware_partition = 0;
+module_param(show_firmware_partition, int, 0);
+
+#ifdef CONFIG_MTD_NAND_DISKONCHIP_BBTWRITE
+static int inftl_bbt_write = 1;
 #else
-static int inftl_bbt_write=0;
+static int inftl_bbt_write = 0;
 #endif
 module_param(inftl_bbt_write, int, 0);
 
-static unsigned long doc_config_location = CONFIG_MTD_DISKONCHIP_PROBE_ADDRESS;
+static unsigned long doc_config_location = CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADDRESS;
 module_param(doc_config_location, ulong, 0);
 MODULE_PARM_DESC(doc_config_location, "Physical memory address at which to probe for DiskOnChip");
 
-
 /* Sector size for HW ECC */
 #define SECTOR_SIZE 512
 /* The sector bytes are packed into NB_DATA 10 bit words */
@@ -155,7 +143,7 @@ static struct rs_control *rs_decoder;
  * some comments, improved a minor bit and converted it to make use
  * of the generic Reed-Solomon libary. tglx
  */
-static int doc_ecc_decode (struct rs_control *rs, uint8_t *data, uint8_t *ecc)
+static int doc_ecc_decode(struct rs_control *rs, uint8_t *data, uint8_t *ecc)
 {
 	int i, j, nerr, errpos[8];
 	uint8_t parity;
@@ -176,11 +164,11 @@ static int doc_ecc_decode (struct rs_control *rs, uint8_t *data, uint8_t *ecc)
 	 *  s[i] = ds[3]x^3 + ds[2]x^2 + ds[1]x^1 + ds[0]
 	 *  where x = alpha^(FCR + i)
 	 */
-	for(j = 1; j < NROOTS; j++) {
-		if(ds[j] == 0)
+	for (j = 1; j < NROOTS; j++) {
+		if (ds[j] == 0)
 			continue;
 		tmp = rs->index_of[ds[j]];
-		for(i = 0; i < NROOTS; i++)
+		for (i = 0; i < NROOTS; i++)
 			s[i] ^= rs->alpha_to[rs_modnn(rs, tmp + (FCR + i) * j)];
 	}
 
@@ -201,7 +189,7 @@ static int doc_ecc_decode (struct rs_control *rs, uint8_t *data, uint8_t *ecc)
 	 * but they are given by the design of the de/encoder circuit
 	 * in the DoC ASIC's.
 	 */
-	for(i = 0;i < nerr; i++) {
+	for (i = 0; i < nerr; i++) {
 		int index, bitpos, pos = 1015 - errpos[i];
 		uint8_t val;
 		if (pos >= NB_DATA && pos < 1019)
@@ -213,8 +201,7 @@ static int doc_ecc_decode (struct rs_control *rs, uint8_t *data, uint8_t *ecc)
 			   can be modified since pos is even */
 			index = (pos >> 3) ^ 1;
 			bitpos = pos & 7;
-			if ((index >= 0 && index < SECTOR_SIZE) ||
-			    index == (SECTOR_SIZE + 1)) {
+			if ((index >= 0 && index < SECTOR_SIZE) || index == (SECTOR_SIZE + 1)) {
 				val = (uint8_t) (errval[i] >> (2 + bitpos));
 				parity ^= val;
 				if (index < SECTOR_SIZE)
@@ -224,9 +211,8 @@ static int doc_ecc_decode (struct rs_control *rs, uint8_t *data, uint8_t *ecc)
 			bitpos = (bitpos + 10) & 7;
 			if (bitpos == 0)
 				bitpos = 8;
-			if ((index >= 0 && index < SECTOR_SIZE) ||
-			    index == (SECTOR_SIZE + 1)) {
-				val = (uint8_t)(errval[i] << (8 - bitpos));
+			if ((index >= 0 && index < SECTOR_SIZE) || index == (SECTOR_SIZE + 1)) {
+				val = (uint8_t) (errval[i] << (8 - bitpos));
 				parity ^= val;
 				if (index < SECTOR_SIZE)
 					data[index] ^= val;
@@ -234,7 +220,7 @@ static int doc_ecc_decode (struct rs_control *rs, uint8_t *data, uint8_t *ecc)
 		}
 	}
 	/* If the parity is wrong, no rescue possible */
-	return parity ? -1 : nerr;
+	return parity ? -EBADMSG : nerr;
 }
 
 static void DoC_Delay(struct doc_priv *doc, unsigned short cycles)
@@ -261,7 +247,8 @@ static int _DoC_WaitReady(struct doc_priv *doc)
 	void __iomem *docptr = doc->virtadr;
 	unsigned long timeo = jiffies + (HZ * 10);
 
-	if(debug) printk("_DoC_WaitReady...\n");
+	if (debug)
+		printk("_DoC_WaitReady...\n");
 	/* Out-of-line routine to wait for chip response */
 	if (DoC_is_MillenniumPlus(doc)) {
 		while ((ReadDOC(docptr, Mplus_FlashControl) & CDSN_CTRL_FR_B_MASK) != CDSN_CTRL_FR_B_MASK) {
@@ -306,7 +293,8 @@ static inline int DoC_WaitReady(struct doc_priv *doc)
 		DoC_Delay(doc, 2);
 	}
 
-	if(debug) printk("DoC_WaitReady OK\n");
+	if (debug)
+		printk("DoC_WaitReady OK\n");
 	return ret;
 }
 
@@ -316,7 +304,8 @@ static void doc2000_write_byte(struct mtd_info *mtd, u_char datum)
 	struct doc_priv *doc = this->priv;
 	void __iomem *docptr = doc->virtadr;
 
-	if(debug)printk("write_byte %02x\n", datum);
+	if (debug)
+		printk("write_byte %02x\n", datum);
 	WriteDOC(datum, docptr, CDSNSlowIO);
 	WriteDOC(datum, docptr, 2k_CDSN_IO);
 }
@@ -331,37 +320,39 @@ static u_char doc2000_read_byte(struct mtd_info *mtd)
 	ReadDOC(docptr, CDSNSlowIO);
 	DoC_Delay(doc, 2);
 	ret = ReadDOC(docptr, 2k_CDSN_IO);
-	if (debug) printk("read_byte returns %02x\n", ret);
+	if (debug)
+		printk("read_byte returns %02x\n", ret);
 	return ret;
 }
 
-static void doc2000_writebuf(struct mtd_info *mtd,
-			     const u_char *buf, int len)
+static void doc2000_writebuf(struct mtd_info *mtd, const u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
 	struct doc_priv *doc = this->priv;
 	void __iomem *docptr = doc->virtadr;
 	int i;
-	if (debug)printk("writebuf of %d bytes: ", len);
-	for (i=0; i < len; i++) {
+	if (debug)
+		printk("writebuf of %d bytes: ", len);
+	for (i = 0; i < len; i++) {
 		WriteDOC_(buf[i], docptr, DoC_2k_CDSN_IO + i);
 		if (debug && i < 16)
 			printk("%02x ", buf[i]);
 	}
-	if (debug) printk("\n");
+	if (debug)
+		printk("\n");
 }
 
-static void doc2000_readbuf(struct mtd_info *mtd,
-			    u_char *buf, int len)
+static void doc2000_readbuf(struct mtd_info *mtd, u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
 	struct doc_priv *doc = this->priv;
 	void __iomem *docptr = doc->virtadr;
 	int i;
 
-	if (debug)printk("readbuf of %d bytes: ", len);
+	if (debug)
+		printk("readbuf of %d bytes: ", len);
 
-	for (i=0; i < len; i++) {
+	for (i = 0; i < len; i++) {
 		buf[i] = ReadDOC(docptr, 2k_CDSN_IO + i);
 	}
 }
@@ -374,28 +365,28 @@ static void doc2000_readbuf_dword(struct mtd_info *mtd,
 	void __iomem *docptr = doc->virtadr;
 	int i;
 
-	if (debug) printk("readbuf_dword of %d bytes: ", len);
+	if (debug)
+		printk("readbuf_dword of %d bytes: ", len);
 
-	if (unlikely((((unsigned long)buf)|len) & 3)) {
-		for (i=0; i < len; i++) {
-			*(uint8_t *)(&buf[i]) = ReadDOC(docptr, 2k_CDSN_IO + i);
+	if (unlikely((((unsigned long)buf) | len) & 3)) {
+		for (i = 0; i < len; i++) {
+			*(uint8_t *) (&buf[i]) = ReadDOC(docptr, 2k_CDSN_IO + i);
 		}
 	} else {
-		for (i=0; i < len; i+=4) {
-			*(uint32_t*)(&buf[i]) = readl(docptr + DoC_2k_CDSN_IO + i);
+		for (i = 0; i < len; i += 4) {
+			*(uint32_t*) (&buf[i]) = readl(docptr + DoC_2k_CDSN_IO + i);
 		}
 	}
 }
 
-static int doc2000_verifybuf(struct mtd_info *mtd,
-			      const u_char *buf, int len)
+static int doc2000_verifybuf(struct mtd_info *mtd, const u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
 	struct doc_priv *doc = this->priv;
 	void __iomem *docptr = doc->virtadr;
 	int i;
 
-	for (i=0; i < len; i++)
+	for (i = 0; i < len; i++)
 		if (buf[i] != ReadDOC(docptr, 2k_CDSN_IO))
 			return -EFAULT;
 	return 0;
@@ -408,12 +399,15 @@ static uint16_t __init doc200x_ident_chip(struct mtd_info *mtd, int nr)
 	uint16_t ret;
 
 	doc200x_select_chip(mtd, nr);
-	doc200x_hwcontrol(mtd, NAND_CTL_SETCLE);
-	this->write_byte(mtd, NAND_CMD_READID);
-	doc200x_hwcontrol(mtd, NAND_CTL_CLRCLE);
-	doc200x_hwcontrol(mtd, NAND_CTL_SETALE);
-	this->write_byte(mtd, 0);
-	doc200x_hwcontrol(mtd, NAND_CTL_CLRALE);
+	doc200x_hwcontrol(mtd, NAND_CMD_READID,
+			  NAND_CTRL_CLE | NAND_CTRL_CHANGE);
+	doc200x_hwcontrol(mtd, 0, NAND_CTRL_ALE | NAND_CTRL_CHANGE);
+	doc200x_hwcontrol(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
+
+	/* We cant' use dev_ready here, but at least we wait for the
+	 * command to complete
+	 */
+	udelay(50);
 
 	ret = this->read_byte(mtd) << 8;
 	ret |= this->read_byte(mtd);
@@ -426,12 +420,13 @@ static uint16_t __init doc200x_ident_chip(struct mtd_info *mtd, int nr)
 		} ident;
 		void __iomem *docptr = doc->virtadr;
 
-		doc200x_hwcontrol(mtd, NAND_CTL_SETCLE);
-		doc2000_write_byte(mtd, NAND_CMD_READID);
-		doc200x_hwcontrol(mtd, NAND_CTL_CLRCLE);
-		doc200x_hwcontrol(mtd, NAND_CTL_SETALE);
-		doc2000_write_byte(mtd, 0);
-		doc200x_hwcontrol(mtd, NAND_CTL_CLRALE);
+		doc200x_hwcontrol(mtd, NAND_CMD_READID,
+				  NAND_CTRL_CLE | NAND_CTRL_CHANGE);
+		doc200x_hwcontrol(mtd, 0, NAND_CTRL_ALE | NAND_CTRL_CHANGE);
+		doc200x_hwcontrol(mtd, NAND_CMD_NONE,
+				  NAND_NCE | NAND_CTRL_CHANGE);
+
+		udelay(50);
 
 		ident.dword = readl(docptr + DoC_2k_CDSN_IO);
 		if (((ident.byte[0] << 8) | ident.byte[1]) == ret) {
@@ -465,7 +460,7 @@ static void __init doc2000_count_chips(struct mtd_info *mtd)
 	printk(KERN_DEBUG "Detected %d chips per floor.\n", i);
 }
 
-static int doc200x_wait(struct mtd_info *mtd, struct nand_chip *this, int state)
+static int doc200x_wait(struct mtd_info *mtd, struct nand_chip *this)
 {
 	struct doc_priv *doc = this->priv;
 
@@ -504,22 +499,20 @@ static u_char doc2001_read_byte(struct mtd_info *mtd)
 	return ReadDOC(docptr, LastDataRead);
 }
 
-static void doc2001_writebuf(struct mtd_info *mtd,
-			     const u_char *buf, int len)
+static void doc2001_writebuf(struct mtd_info *mtd, const u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
 	struct doc_priv *doc = this->priv;
 	void __iomem *docptr = doc->virtadr;
 	int i;
 
-	for (i=0; i < len; i++)
+	for (i = 0; i < len; i++)
 		WriteDOC_(buf[i], docptr, DoC_Mil_CDSN_IO + i);
 	/* Terminate write pipeline */
 	WriteDOC(0x00, docptr, WritePipeTerm);
 }
 
-static void doc2001_readbuf(struct mtd_info *mtd,
-			    u_char *buf, int len)
+static void doc2001_readbuf(struct mtd_info *mtd, u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
 	struct doc_priv *doc = this->priv;
@@ -529,15 +522,14 @@ static void doc2001_readbuf(struct mtd_info *mtd,
 	/* Start read pipeline */
 	ReadDOC(docptr, ReadPipeInit);
 
-	for (i=0; i < len-1; i++)
+	for (i = 0; i < len - 1; i++)
 		buf[i] = ReadDOC(docptr, Mil_CDSN_IO + (i & 0xff));
 
 	/* Terminate read pipeline */
 	buf[i] = ReadDOC(docptr, LastDataRead);
 }
 
-static int doc2001_verifybuf(struct mtd_info *mtd,
-			     const u_char *buf, int len)
+static int doc2001_verifybuf(struct mtd_info *mtd, const u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
 	struct doc_priv *doc = this->priv;
@@ -547,7 +539,7 @@ static int doc2001_verifybuf(struct mtd_info *mtd,
 	/* Start read pipeline */
 	ReadDOC(docptr, ReadPipeInit);
 
-	for (i=0; i < len-1; i++)
+	for (i = 0; i < len - 1; i++)
 		if (buf[i] != ReadDOC(docptr, Mil_CDSN_IO)) {
 			ReadDOC(docptr, LastDataRead);
 			return i;
@@ -567,81 +559,84 @@ static u_char doc2001plus_read_byte(struct mtd_info *mtd)
 	ReadDOC(docptr, Mplus_ReadPipeInit);
 	ReadDOC(docptr, Mplus_ReadPipeInit);
 	ret = ReadDOC(docptr, Mplus_LastDataRead);
-	if (debug) printk("read_byte returns %02x\n", ret);
+	if (debug)
+		printk("read_byte returns %02x\n", ret);
 	return ret;
 }
 
-static void doc2001plus_writebuf(struct mtd_info *mtd,
-			     const u_char *buf, int len)
+static void doc2001plus_writebuf(struct mtd_info *mtd, const u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
 	struct doc_priv *doc = this->priv;
 	void __iomem *docptr = doc->virtadr;
 	int i;
 
-	if (debug)printk("writebuf of %d bytes: ", len);
-	for (i=0; i < len; i++) {
+	if (debug)
+		printk("writebuf of %d bytes: ", len);
+	for (i = 0; i < len; i++) {
 		WriteDOC_(buf[i], docptr, DoC_Mil_CDSN_IO + i);
 		if (debug && i < 16)
 			printk("%02x ", buf[i]);
 	}
-	if (debug) printk("\n");
+	if (debug)
+		printk("\n");
 }
 
-static void doc2001plus_readbuf(struct mtd_info *mtd,
-			    u_char *buf, int len)
+static void doc2001plus_readbuf(struct mtd_info *mtd, u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
 	struct doc_priv *doc = this->priv;
 	void __iomem *docptr = doc->virtadr;
 	int i;
 
-	if (debug)printk("readbuf of %d bytes: ", len);
+	if (debug)
+		printk("readbuf of %d bytes: ", len);
 
 	/* Start read pipeline */
 	ReadDOC(docptr, Mplus_ReadPipeInit);
 	ReadDOC(docptr, Mplus_ReadPipeInit);
 
-	for (i=0; i < len-2; i++) {
+	for (i = 0; i < len - 2; i++) {
 		buf[i] = ReadDOC(docptr, Mil_CDSN_IO);
 		if (debug && i < 16)
 			printk("%02x ", buf[i]);
 	}
 
 	/* Terminate read pipeline */
-	buf[len-2] = ReadDOC(docptr, Mplus_LastDataRead);
+	buf[len - 2] = ReadDOC(docptr, Mplus_LastDataRead);
 	if (debug && i < 16)
-		printk("%02x ", buf[len-2]);
-	buf[len-1] = ReadDOC(docptr, Mplus_LastDataRead);
+		printk("%02x ", buf[len - 2]);
+	buf[len - 1] = ReadDOC(docptr, Mplus_LastDataRead);
 	if (debug && i < 16)
-		printk("%02x ", buf[len-1]);
-	if (debug) printk("\n");
+		printk("%02x ", buf[len - 1]);
+	if (debug)
+		printk("\n");
 }
 
-static int doc2001plus_verifybuf(struct mtd_info *mtd,
-			     const u_char *buf, int len)
+static int doc2001plus_verifybuf(struct mtd_info *mtd, const u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
 	struct doc_priv *doc = this->priv;
 	void __iomem *docptr = doc->virtadr;
 	int i;
 
-	if (debug)printk("verifybuf of %d bytes: ", len);
+	if (debug)
+		printk("verifybuf of %d bytes: ", len);
 
 	/* Start read pipeline */
 	ReadDOC(docptr, Mplus_ReadPipeInit);
 	ReadDOC(docptr, Mplus_ReadPipeInit);
 
-	for (i=0; i < len-2; i++)
+	for (i = 0; i < len - 2; i++)
 		if (buf[i] != ReadDOC(docptr, Mil_CDSN_IO)) {
 			ReadDOC(docptr, Mplus_LastDataRead);
 			ReadDOC(docptr, Mplus_LastDataRead);
 			return i;
 		}
-	if (buf[len-2] != ReadDOC(docptr, Mplus_LastDataRead))
-		return len-2;
-	if (buf[len-1] != ReadDOC(docptr, Mplus_LastDataRead))
-		return len-1;
+	if (buf[len - 2] != ReadDOC(docptr, Mplus_LastDataRead))
+		return len - 2;
+	if (buf[len - 1] != ReadDOC(docptr, Mplus_LastDataRead))
+		return len - 1;
 	return 0;
 }
 
@@ -652,7 +647,8 @@ static void doc2001plus_select_chip(struct mtd_info *mtd, int chip)
 	void __iomem *docptr = doc->virtadr;
 	int floor = 0;
 
-	if(debug)printk("select chip (%d)\n", chip);
+	if (debug)
+		printk("select chip (%d)\n", chip);
 
 	if (chip == -1) {
 		/* Disable flash internally */
@@ -661,7 +657,7 @@ static void doc2001plus_select_chip(struct mtd_info *mtd, int chip)
 	}
 
 	floor = chip / doc->chips_per_floor;
-	chip -= (floor *  doc->chips_per_floor);
+	chip -= (floor * doc->chips_per_floor);
 
 	/* Assert ChipEnable and deassert WriteProtect */
 	WriteDOC((DOC_FLASH_CE), docptr, Mplus_FlashSelect);
@@ -678,65 +674,54 @@ static void doc200x_select_chip(struct mtd_info *mtd, int chip)
 	void __iomem *docptr = doc->virtadr;
 	int floor = 0;
 
-	if(debug)printk("select chip (%d)\n", chip);
+	if (debug)
+		printk("select chip (%d)\n", chip);
 
 	if (chip == -1)
 		return;
 
 	floor = chip / doc->chips_per_floor;
-	chip -= (floor *  doc->chips_per_floor);
+	chip -= (floor * doc->chips_per_floor);
 
 	/* 11.4.4 -- deassert CE before changing chip */
-	doc200x_hwcontrol(mtd, NAND_CTL_CLRNCE);
+	doc200x_hwcontrol(mtd, NAND_CMD_NONE, 0 | NAND_CTRL_CHANGE);
 
 	WriteDOC(floor, docptr, FloorSelect);
 	WriteDOC(chip, docptr, CDSNDeviceSelect);
 
-	doc200x_hwcontrol(mtd, NAND_CTL_SETNCE);
+	doc200x_hwcontrol(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
 
 	doc->curchip = chip;
 	doc->curfloor = floor;
 }
 
-static void doc200x_hwcontrol(struct mtd_info *mtd, int cmd)
+#define CDSN_CTRL_MSK (CDSN_CTRL_CE | CDSN_CTRL_CLE | CDSN_CTRL_ALE)
+
+static void doc200x_hwcontrol(struct mtd_info *mtd, int cmd,
+			      unsigned int ctrl)
 {
 	struct nand_chip *this = mtd->priv;
 	struct doc_priv *doc = this->priv;
 	void __iomem *docptr = doc->virtadr;
 
-	switch(cmd) {
-	case NAND_CTL_SETNCE:
-		doc->CDSNControl |= CDSN_CTRL_CE;
-		break;
-	case NAND_CTL_CLRNCE:
-		doc->CDSNControl &= ~CDSN_CTRL_CE;
-		break;
-	case NAND_CTL_SETCLE:
-		doc->CDSNControl |= CDSN_CTRL_CLE;
-		break;
-	case NAND_CTL_CLRCLE:
-		doc->CDSNControl &= ~CDSN_CTRL_CLE;
-		break;
-	case NAND_CTL_SETALE:
-		doc->CDSNControl |= CDSN_CTRL_ALE;
-		break;
-	case NAND_CTL_CLRALE:
-		doc->CDSNControl &= ~CDSN_CTRL_ALE;
-		break;
-	case NAND_CTL_SETWP:
-		doc->CDSNControl |= CDSN_CTRL_WP;
-		break;
-	case NAND_CTL_CLRWP:
-		doc->CDSNControl &= ~CDSN_CTRL_WP;
-		break;
+	if (ctrl & NAND_CTRL_CHANGE) {
+		doc->CDSNControl &= ~CDSN_CTRL_MSK;
+		doc->CDSNControl |= ctrl & CDSN_CTRL_MSK;
+		if (debug)
+			printk("hwcontrol(%d): %02x\n", cmd, doc->CDSNControl);
+		WriteDOC(doc->CDSNControl, docptr, CDSNControl);
+		/* 11.4.3 -- 4 NOPs after CSDNControl write */
+		DoC_Delay(doc, 4);
+	}
+	if (cmd != NAND_CMD_NONE) {
+		if (DoC_is_2000(doc))
+			doc2000_write_byte(mtd, cmd);
+		else
+			doc2001_write_byte(mtd, cmd);
 	}
-	if (debug)printk("hwcontrol(%d): %02x\n", cmd, doc->CDSNControl);
-	WriteDOC(doc->CDSNControl, docptr, CDSNControl);
-	/* 11.4.3 -- 4 NOPs after CSDNControl write */
-	DoC_Delay(doc, 4);
 }
 
-static void doc2001plus_command (struct mtd_info *mtd, unsigned command, int column, int page_addr)
+static void doc2001plus_command(struct mtd_info *mtd, unsigned command, int column, int page_addr)
 {
 	struct nand_chip *this = mtd->priv;
 	struct doc_priv *doc = this->priv;
@@ -757,9 +742,9 @@ static void doc2001plus_command (struct mtd_info *mtd, unsigned command, int col
 	if (command == NAND_CMD_SEQIN) {
 		int readcmd;
 
-		if (column >= mtd->oobblock) {
+		if (column >= mtd->writesize) {
 			/* OOB area */
-			column -= mtd->oobblock;
+			column -= mtd->writesize;
 			readcmd = NAND_CMD_READOOB;
 		} else if (column < 256) {
 			/* First 256 bytes --> READ0 */
@@ -783,25 +768,26 @@ static void doc2001plus_command (struct mtd_info *mtd, unsigned command, int col
 			WriteDOC(column, docptr, Mplus_FlashAddress);
 		}
 		if (page_addr != -1) {
-			WriteDOC((unsigned char) (page_addr & 0xff), docptr, Mplus_FlashAddress);
-			WriteDOC((unsigned char) ((page_addr >> 8) & 0xff), docptr, Mplus_FlashAddress);
+			WriteDOC((unsigned char)(page_addr & 0xff), docptr, Mplus_FlashAddress);
+			WriteDOC((unsigned char)((page_addr >> 8) & 0xff), docptr, Mplus_FlashAddress);
 			/* One more address cycle for higher density devices */
 			if (this->chipsize & 0x0c000000) {
-				WriteDOC((unsigned char) ((page_addr >> 16) & 0x0f), docptr, Mplus_FlashAddress);
+				WriteDOC((unsigned char)((page_addr >> 16) & 0x0f), docptr, Mplus_FlashAddress);
 				printk("high density\n");
 			}
 		}
 		WriteDOC(0, docptr, Mplus_WritePipeTerm);
 		WriteDOC(0, docptr, Mplus_WritePipeTerm);
 		/* deassert ALE */
-		if (command == NAND_CMD_READ0 || command == NAND_CMD_READ1 || command == NAND_CMD_READOOB || command == NAND_CMD_READID)
+		if (command == NAND_CMD_READ0 || command == NAND_CMD_READ1 ||
+		    command == NAND_CMD_READOOB || command == NAND_CMD_READID)
 			WriteDOC(0, docptr, Mplus_FlashControl);
 	}
 
 	/*
 	 * program and erase have their own busy handlers
 	 * status and sequential in needs no delay
-	*/
+	 */
 	switch (command) {
 
 	case NAND_CMD_PAGEPROG:
@@ -818,26 +804,26 @@ static void doc2001plus_command (struct mtd_info *mtd, unsigned command, int col
 		WriteDOC(NAND_CMD_STATUS, docptr, Mplus_FlashCmd);
 		WriteDOC(0, docptr, Mplus_WritePipeTerm);
 		WriteDOC(0, docptr, Mplus_WritePipeTerm);
-		while ( !(this->read_byte(mtd) & 0x40));
+		while (!(this->read_byte(mtd) & 0x40)) ;
 		return;
 
-	/* This applies to read commands */
+		/* This applies to read commands */
 	default:
 		/*
 		 * If we don't have access to the busy pin, we apply the given
 		 * command delay
-		*/
+		 */
 		if (!this->dev_ready) {
-			udelay (this->chip_delay);
+			udelay(this->chip_delay);
 			return;
 		}
 	}
 
 	/* Apply this short delay always to ensure that we do wait tWB in
 	 * any case on any machine. */
-	ndelay (100);
+	ndelay(100);
 	/* wait until command is processed */
-	while (!this->dev_ready(mtd));
+	while (!this->dev_ready(mtd)) ;
 }
 
 static int doc200x_dev_ready(struct mtd_info *mtd)
@@ -850,23 +836,25 @@ static int doc200x_dev_ready(struct mtd_info *mtd)
 		/* 11.4.2 -- must NOP four times before checking FR/B# */
 		DoC_Delay(doc, 4);
 		if ((ReadDOC(docptr, Mplus_FlashControl) & CDSN_CTRL_FR_B_MASK) != CDSN_CTRL_FR_B_MASK) {
-			if(debug)
+			if (debug)
 				printk("not ready\n");
 			return 0;
 		}
-		if (debug)printk("was ready\n");
+		if (debug)
+			printk("was ready\n");
 		return 1;
 	} else {
 		/* 11.4.2 -- must NOP four times before checking FR/B# */
 		DoC_Delay(doc, 4);
 		if (!(ReadDOC(docptr, CDSNControl) & CDSN_CTRL_FR_B)) {
-			if(debug)
+			if (debug)
 				printk("not ready\n");
 			return 0;
 		}
 		/* 11.4.2 -- Must NOP twice if it's ready */
 		DoC_Delay(doc, 2);
-		if (debug)printk("was ready\n");
+		if (debug)
+			printk("was ready\n");
 		return 1;
 	}
 }
@@ -885,7 +873,7 @@ static void doc200x_enable_hwecc(struct mtd_info *mtd, int mode)
 	void __iomem *docptr = doc->virtadr;
 
 	/* Prime the ECC engine */
-	switch(mode) {
+	switch (mode) {
 	case NAND_ECC_READ:
 		WriteDOC(DOC_ECC_RESET, docptr, ECCConf);
 		WriteDOC(DOC_ECC_EN, docptr, ECCConf);
@@ -904,7 +892,7 @@ static void doc2001plus_enable_hwecc(struct mtd_info *mtd, int mode)
 	void __iomem *docptr = doc->virtadr;
 
 	/* Prime the ECC engine */
-	switch(mode) {
+	switch (mode) {
 	case NAND_ECC_READ:
 		WriteDOC(DOC_ECC_RESET, docptr, Mplus_ECCConf);
 		WriteDOC(DOC_ECC_EN, docptr, Mplus_ECCConf);
@@ -917,8 +905,7 @@ static void doc2001plus_enable_hwecc(struct mtd_info *mtd, int mode)
 }
 
 /* This code is only called on write */
-static int doc200x_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
-				 unsigned char *ecc_code)
+static int doc200x_calculate_ecc(struct mtd_info *mtd, const u_char *dat, unsigned char *ecc_code)
 {
 	struct nand_chip *this = mtd->priv;
 	struct doc_priv *doc = this->priv;
@@ -962,7 +949,8 @@ static int doc200x_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
 		   often.  It could be optimized away by examining the data in
 		   the writebuf routine, and remembering the result. */
 		for (i = 0; i < 512; i++) {
-			if (dat[i] == 0xff) continue;
+			if (dat[i] == 0xff)
+				continue;
 			emptymatch = 0;
 			break;
 		}
@@ -970,17 +958,20 @@ static int doc200x_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
 	/* If emptymatch still =1, we do have an all-0xff data buffer.
 	   Return all-0xff ecc value instead of the computed one, so
 	   it'll look just like a freshly-erased page. */
-	if (emptymatch) memset(ecc_code, 0xff, 6);
+	if (emptymatch)
+		memset(ecc_code, 0xff, 6);
 #endif
 	return 0;
 }
 
-static int doc200x_correct_data(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc)
+static int doc200x_correct_data(struct mtd_info *mtd, u_char *dat,
+				u_char *read_ecc, u_char *isnull)
 {
 	int i, ret = 0;
 	struct nand_chip *this = mtd->priv;
 	struct doc_priv *doc = this->priv;
 	void __iomem *docptr = doc->virtadr;
+	uint8_t calc_ecc[6];
 	volatile u_char dummy;
 	int emptymatch = 1;
 
@@ -1013,18 +1004,20 @@ static int doc200x_correct_data(struct mtd_info *mtd, u_char *dat, u_char *read_
 		   all-0xff data and stored ecc block.  Check the stored ecc. */
 		if (emptymatch) {
 			for (i = 0; i < 6; i++) {
-				if (read_ecc[i] == 0xff) continue;
+				if (read_ecc[i] == 0xff)
+					continue;
 				emptymatch = 0;
 				break;
 			}
 		}
 		/* If emptymatch still =1, check the data block. */
 		if (emptymatch) {
-		/* Note: this somewhat expensive test should not be triggered
-		   often.  It could be optimized away by examining the data in
-		   the readbuf routine, and remembering the result. */
+			/* Note: this somewhat expensive test should not be triggered
+			   often.  It could be optimized away by examining the data in
+			   the readbuf routine, and remembering the result. */
 			for (i = 0; i < 512; i++) {
-				if (dat[i] == 0xff) continue;
+				if (dat[i] == 0xff)
+					continue;
 				emptymatch = 0;
 				break;
 			}
@@ -1033,7 +1026,8 @@ static int doc200x_correct_data(struct mtd_info *mtd, u_char *dat, u_char *read_
 		   erased block, in which case the ECC will not come out right.
 		   We'll suppress the error and tell the caller everything's
 		   OK.  Because it is. */
-		if (!emptymatch) ret = doc_ecc_decode (rs_decoder, dat, calc_ecc);
+		if (!emptymatch)
+			ret = doc_ecc_decode(rs_decoder, dat, calc_ecc);
 		if (ret > 0)
 			printk(KERN_ERR "doc200x_correct_data corrected %d errors\n", ret);
 	}
@@ -1041,7 +1035,7 @@ static int doc200x_correct_data(struct mtd_info *mtd, u_char *dat, u_char *read_
 		WriteDOC(DOC_ECC_DIS, docptr, Mplus_ECCConf);
 	else
 		WriteDOC(DOC_ECC_DIS, docptr, ECCConf);
-	if (no_ecc_failures && (ret == -1)) {
+	if (no_ecc_failures && (ret == -EBADMSG)) {
 		printk(KERN_ERR "suppressing ECC failure\n");
 		ret = 0;
 	}
@@ -1050,11 +1044,20 @@ static int doc200x_correct_data(struct mtd_info *mtd, u_char *dat, u_char *read_
 
 /*u_char mydatabuf[528]; */
 
-static struct nand_oobinfo doc200x_oobinfo = {
-	.useecc = MTD_NANDECC_AUTOPLACE,
+/* The strange out-of-order .oobfree list below is a (possibly unneeded)
+ * attempt to retain compatibility.  It used to read:
+ * 	.oobfree = { {8, 8} }
+ * Since that leaves two bytes unusable, it was changed.  But the following
+ * scheme might affect existing jffs2 installs by moving the cleanmarker:
+ * 	.oobfree = { {6, 10} }
+ * jffs2 seems to handle the above gracefully, but the current scheme seems
+ * safer.  The only problem with it is that any code that parses oobfree must
+ * be able to handle out-of-order segments.
+ */
+static struct nand_ecclayout doc200x_oobinfo = {
 	.eccbytes = 6,
 	.eccpos = {0, 1, 2, 3, 4, 5},
-	.oobfree = { {8, 8} }
+	.oobfree = {{8, 8}, {6, 2}}
 };
 
 /* Find the (I)NFTL Media Header, and optionally also the mirror media header.
@@ -1063,28 +1066,28 @@ static struct nand_oobinfo doc200x_oobinfo = {
    either "ANAND" or "BNAND".  If findmirror=1, also look for the mirror media
    header.  The page #s of the found media headers are placed in mh0_page and
    mh1_page in the DOC private structure. */
-static int __init find_media_headers(struct mtd_info *mtd, u_char *buf,
-				     const char *id, int findmirror)
+static int __init find_media_headers(struct mtd_info *mtd, u_char *buf, const char *id, int findmirror)
 {
 	struct nand_chip *this = mtd->priv;
 	struct doc_priv *doc = this->priv;
-	unsigned offs, end = (MAX_MEDIAHEADER_SCAN << this->phys_erase_shift);
+	unsigned offs;
 	int ret;
 	size_t retlen;
 
-	end = min(end, mtd->size); /* paranoia */
-	for (offs = 0; offs < end; offs += mtd->erasesize) {
-		ret = mtd->read(mtd, offs, mtd->oobblock, &retlen, buf);
-		if (retlen != mtd->oobblock) continue;
+	for (offs = 0; offs < mtd->size; offs += mtd->erasesize) {
+		ret = mtd->read(mtd, offs, mtd->writesize, &retlen, buf);
+		if (retlen != mtd->writesize)
+			continue;
 		if (ret) {
-			printk(KERN_WARNING "ECC error scanning DOC at 0x%x\n",
-				offs);
+			printk(KERN_WARNING "ECC error scanning DOC at 0x%x\n", offs);
 		}
-		if (memcmp(buf, id, 6)) continue;
+		if (memcmp(buf, id, 6))
+			continue;
 		printk(KERN_INFO "Found DiskOnChip %s Media Header at 0x%x\n", id, offs);
 		if (doc->mh0_page == -1) {
 			doc->mh0_page = offs >> this->page_shift;
-			if (!findmirror) return 1;
+			if (!findmirror)
+				return 1;
 			continue;
 		}
 		doc->mh1_page = offs >> this->page_shift;
@@ -1097,8 +1100,8 @@ static int __init find_media_headers(struct mtd_info *mtd, u_char *buf,
 	/* Only one mediaheader was found.  We want buf to contain a
 	   mediaheader on return, so we'll have to re-read the one we found. */
 	offs = doc->mh0_page << this->page_shift;
-	ret = mtd->read(mtd, offs, mtd->oobblock, &retlen, buf);
-	if (retlen != mtd->oobblock) {
+	ret = mtd->read(mtd, offs, mtd->writesize, &retlen, buf);
+	if (retlen != mtd->writesize) {
 		/* Insanity.  Give up. */
 		printk(KERN_ERR "Read DiskOnChip Media Header once, but can't reread it???\n");
 		return 0;
@@ -1106,8 +1109,7 @@ static int __init find_media_headers(struct mtd_info *mtd, u_char *buf,
 	return 1;
 }
 
-static inline int __init nftl_partscan(struct mtd_info *mtd,
-				struct mtd_partition *parts)
+static inline int __init nftl_partscan(struct mtd_info *mtd, struct mtd_partition *parts)
 {
 	struct nand_chip *this = mtd->priv;
 	struct doc_priv *doc = this->priv;
@@ -1115,19 +1117,23 @@ static inline int __init nftl_partscan(struct mtd_info *mtd,
 	u_char *buf;
 	struct NFTLMediaHeader *mh;
 	const unsigned psize = 1 << this->page_shift;
+	int numparts = 0;
 	unsigned blocks, maxblocks;
 	int offs, numheaders;
 
-	buf = kmalloc(mtd->oobblock, GFP_KERNEL);
+	buf = kmalloc(mtd->writesize, GFP_KERNEL);
 	if (!buf) {
 		printk(KERN_ERR "DiskOnChip mediaheader kmalloc failed!\n");
 		return 0;
 	}
-	if (!(numheaders=find_media_headers(mtd, buf, "ANAND", 1))) goto out;
-	mh = (struct NFTLMediaHeader *) buf;
+	if (!(numheaders = find_media_headers(mtd, buf, "ANAND", 1)))
+		goto out;
+	mh = (struct NFTLMediaHeader *)buf;
+
+	le16_to_cpus(&mh->NumEraseUnits);
+	le16_to_cpus(&mh->FirstPhysicalEUN);
+	le32_to_cpus(&mh->FormattedSize);
 
-/*#ifdef CONFIG_MTD_DEBUG_VERBOSE */
-/*	if (CONFIG_MTD_DEBUG_VERBOSE >= 2) */
 	printk(KERN_INFO "    DataOrgID        = %s\n"
 			 "    NumEraseUnits    = %d\n"
 			 "    FirstPhysicalEUN = %d\n"
@@ -1136,7 +1142,6 @@ static inline int __init nftl_partscan(struct mtd_info *mtd,
 		mh->DataOrgID, mh->NumEraseUnits,
 		mh->FirstPhysicalEUN, mh->FormattedSize,
 		mh->UnitSizeFactor);
-/*#endif */
 
 	blocks = mtd->size >> this->phys_erase_shift;
 	maxblocks = min(32768U, mtd->erasesize - psize);
@@ -1145,8 +1150,8 @@ static inline int __init nftl_partscan(struct mtd_info *mtd,
 		/* Auto-determine UnitSizeFactor.  The constraints are:
 		   - There can be at most 32768 virtual blocks.
 		   - There can be at most (virtual block size - page size)
-		     virtual blocks (because MediaHeader+BBT must fit in 1).
-		*/
+		   virtual blocks (because MediaHeader+BBT must fit in 1).
+		 */
 		mh->UnitSizeFactor = 0xff;
 		while (blocks > maxblocks) {
 			blocks >>= 1;
@@ -1179,31 +1184,35 @@ static inline int __init nftl_partscan(struct mtd_info *mtd,
 	offs <<= this->page_shift;
 	offs += mtd->erasesize;
 
-	/*parts[0].name = " DiskOnChip Boot / Media Header partition"; */
-	/*parts[0].offset = 0; */
-	/*parts[0].size = offs; */
+	if (show_firmware_partition == 1) {
+		parts[0].name = " DiskOnChip Firmware / Media Header partition";
+		parts[0].offset = 0;
+		parts[0].size = offs;
+		numparts = 1;
+	}
+
+	parts[numparts].name = " DiskOnChip BDTL partition";
+	parts[numparts].offset = offs;
+	parts[numparts].size = (mh->NumEraseUnits - numheaders) << this->bbt_erase_shift;
 
-	parts[0].name = " DiskOnChip BDTL partition";
-	parts[0].offset = offs;
-	parts[0].size = (mh->NumEraseUnits - numheaders) << this->bbt_erase_shift;
+	offs += parts[numparts].size;
+	numparts++;
 
-	offs += parts[0].size;
 	if (offs < mtd->size) {
-		parts[1].name = " DiskOnChip Remainder partition";
-		parts[1].offset = offs;
-		parts[1].size = mtd->size - offs;
-		ret = 2;
-		goto out;
+		parts[numparts].name = " DiskOnChip Remainder partition";
+		parts[numparts].offset = offs;
+		parts[numparts].size = mtd->size - offs;
+		numparts++;
 	}
-	ret = 1;
-out:
+
+	ret = numparts;
+ out:
 	kfree(buf);
 	return ret;
 }
 
 /* This is a stripped-down copy of the code in inftlmount.c */
-static inline int __init inftl_partscan(struct mtd_info *mtd,
-				 struct mtd_partition *parts)
+static inline int __init inftl_partscan(struct mtd_info *mtd, struct mtd_partition *parts)
 {
 	struct nand_chip *this = mtd->priv;
 	struct doc_priv *doc = this->priv;
@@ -1220,25 +1229,24 @@ static inline int __init inftl_partscan(struct mtd_info *mtd,
 	if (inftl_bbt_write)
 		end -= (INFTL_BBT_RESERVED_BLOCKS << this->phys_erase_shift);
 
-	buf = kmalloc(mtd->oobblock, GFP_KERNEL);
+	buf = kmalloc(mtd->writesize, GFP_KERNEL);
 	if (!buf) {
 		printk(KERN_ERR "DiskOnChip mediaheader kmalloc failed!\n");
 		return 0;
 	}
 
-	if (!find_media_headers(mtd, buf, "BNAND", 0)) goto out;
+	if (!find_media_headers(mtd, buf, "BNAND", 0))
+		goto out;
 	doc->mh1_page = doc->mh0_page + (4096 >> this->page_shift);
-	mh = (struct INFTLMediaHeader *) buf;
+	mh = (struct INFTLMediaHeader *)buf;
 
-	mh->NoOfBootImageBlocks = le32_to_cpu(mh->NoOfBootImageBlocks);
-	mh->NoOfBinaryPartitions = le32_to_cpu(mh->NoOfBinaryPartitions);
-	mh->NoOfBDTLPartitions = le32_to_cpu(mh->NoOfBDTLPartitions);
-	mh->BlockMultiplierBits = le32_to_cpu(mh->BlockMultiplierBits);
-	mh->FormatFlags = le32_to_cpu(mh->FormatFlags);
-	mh->PercentUsed = le32_to_cpu(mh->PercentUsed);
+	le32_to_cpus(&mh->NoOfBootImageBlocks);
+	le32_to_cpus(&mh->NoOfBinaryPartitions);
+	le32_to_cpus(&mh->NoOfBDTLPartitions);
+	le32_to_cpus(&mh->BlockMultiplierBits);
+	le32_to_cpus(&mh->FormatFlags);
+	le32_to_cpus(&mh->PercentUsed);
 
-/*#ifdef CONFIG_MTD_DEBUG_VERBOSE */
-/*	if (CONFIG_MTD_DEBUG_VERBOSE >= 2) */
 	printk(KERN_INFO "    bootRecordID          = %s\n"
 			 "    NoOfBootImageBlocks   = %d\n"
 			 "    NoOfBinaryPartitions  = %d\n"
@@ -1256,7 +1264,6 @@ static inline int __init inftl_partscan(struct mtd_info *mtd,
 		((unsigned char *) &mh->OsakVersion)[2] & 0xf,
 		((unsigned char *) &mh->OsakVersion)[3] & 0xf,
 		mh->PercentUsed);
-/*#endif */
 
 	vshift = this->phys_erase_shift + mh->BlockMultiplierBits;
 
@@ -1275,15 +1282,13 @@ static inline int __init inftl_partscan(struct mtd_info *mtd,
 	/* Scan the partitions */
 	for (i = 0; (i < 4); i++) {
 		ip = &(mh->Partitions[i]);
-		ip->virtualUnits = le32_to_cpu(ip->virtualUnits);
-		ip->firstUnit = le32_to_cpu(ip->firstUnit);
-		ip->lastUnit = le32_to_cpu(ip->lastUnit);
-		ip->flags = le32_to_cpu(ip->flags);
-		ip->spareUnits = le32_to_cpu(ip->spareUnits);
-		ip->Reserved0 = le32_to_cpu(ip->Reserved0);
-
-/*#ifdef CONFIG_MTD_DEBUG_VERBOSE */
-/*		if (CONFIG_MTD_DEBUG_VERBOSE >= 2) */
+		le32_to_cpus(&ip->virtualUnits);
+		le32_to_cpus(&ip->firstUnit);
+		le32_to_cpus(&ip->lastUnit);
+		le32_to_cpus(&ip->flags);
+		le32_to_cpus(&ip->spareUnits);
+		le32_to_cpus(&ip->Reserved0);
+
 		printk(KERN_INFO	"    PARTITION[%d] ->\n"
 			"        virtualUnits    = %d\n"
 			"        firstUnit       = %d\n"
@@ -1293,16 +1298,14 @@ static inline int __init inftl_partscan(struct mtd_info *mtd,
 			i, ip->virtualUnits, ip->firstUnit,
 			ip->lastUnit, ip->flags,
 			ip->spareUnits);
-/*#endif */
 
-/*
-		if ((i == 0) && (ip->firstUnit > 0)) {
+		if ((show_firmware_partition == 1) &&
+		    (i == 0) && (ip->firstUnit > 0)) {
 			parts[0].name = " DiskOnChip IPL / Media Header partition";
 			parts[0].offset = 0;
 			parts[0].size = mtd->erasesize * ip->firstUnit;
 			numparts = 1;
 		}
-*/
 
 		if (ip->flags & INFTL_BINARY)
 			parts[numparts].name = " DiskOnChip BDK partition";
@@ -1311,8 +1314,10 @@ static inline int __init inftl_partscan(struct mtd_info *mtd,
 		parts[numparts].offset = ip->firstUnit << vshift;
 		parts[numparts].size = (1 + ip->lastUnit - ip->firstUnit) << vshift;
 		numparts++;
-		if (ip->lastUnit > lastvunit) lastvunit = ip->lastUnit;
-		if (ip->flags & INFTL_LAST) break;
+		if (ip->lastUnit > lastvunit)
+			lastvunit = ip->lastUnit;
+		if (ip->flags & INFTL_LAST)
+			break;
 	}
 	lastvunit++;
 	if ((lastvunit << vshift) < end) {
@@ -1322,7 +1327,7 @@ static inline int __init inftl_partscan(struct mtd_info *mtd,
 		numparts++;
 	}
 	ret = numparts;
-out:
+ out:
 	kfree(buf);
 	return ret;
 }
@@ -1334,11 +1339,12 @@ static int __init nftl_scan_bbt(struct mtd_info *mtd)
 	struct doc_priv *doc = this->priv;
 	struct mtd_partition parts[2];
 
-	memset((char *) parts, 0, sizeof(parts));
+	memset((char *)parts, 0, sizeof(parts));
 	/* On NFTL, we have to find the media headers before we can read the
 	   BBTs, since they're stored in the media header eraseblocks. */
 	numparts = nftl_partscan(mtd, parts);
-	if (!numparts) return -EIO;
+	if (!numparts)
+		return -EIO;
 	this->bbt_td->options = NAND_BBT_ABSPAGE | NAND_BBT_8BIT |
 				NAND_BBT_SAVECONTENT | NAND_BBT_WRITE |
 				NAND_BBT_VERSION;
@@ -1385,8 +1391,7 @@ static int __init inftl_scan_bbt(struct mtd_info *mtd)
 		this->bbt_td->pages[0] = 2;
 		this->bbt_md = NULL;
 	} else {
-		this->bbt_td->options = NAND_BBT_LASTBLOCK | NAND_BBT_8BIT |
-					NAND_BBT_VERSION;
+		this->bbt_td->options = NAND_BBT_LASTBLOCK | NAND_BBT_8BIT | NAND_BBT_VERSION;
 		if (inftl_bbt_write)
 			this->bbt_td->options |= NAND_BBT_WRITE;
 		this->bbt_td->offs = 8;
@@ -1396,8 +1401,7 @@ static int __init inftl_scan_bbt(struct mtd_info *mtd)
 		this->bbt_td->reserved_block_code = 0x01;
 		this->bbt_td->pattern = "MSYS_BBT";
 
-		this->bbt_md->options = NAND_BBT_LASTBLOCK | NAND_BBT_8BIT |
-					NAND_BBT_VERSION;
+		this->bbt_md->options = NAND_BBT_LASTBLOCK | NAND_BBT_8BIT | NAND_BBT_VERSION;
 		if (inftl_bbt_write)
 			this->bbt_md->options |= NAND_BBT_WRITE;
 		this->bbt_md->offs = 8;
@@ -1412,12 +1416,13 @@ static int __init inftl_scan_bbt(struct mtd_info *mtd)
 	   At least as nand_bbt.c is currently written. */
 	if ((ret = nand_scan_bbt(mtd, NULL)))
 		return ret;
-	memset((char *) parts, 0, sizeof(parts));
+	memset((char *)parts, 0, sizeof(parts));
 	numparts = inftl_partscan(mtd, parts);
 	/* At least for now, require the INFTL Media Header.  We could probably
 	   do without it for non-INFTL use, since all it gives us is
 	   autopartitioning, but I want to give it more thought. */
-	if (!numparts) return -EIO;
+	if (!numparts)
+		return -EIO;
 	add_mtd_device(mtd);
 #ifdef CONFIG_MTD_PARTITIONS
 	if (!no_autopart)
@@ -1431,7 +1436,6 @@ static inline int __init doc2000_init(struct mtd_info *mtd)
 	struct nand_chip *this = mtd->priv;
 	struct doc_priv *doc = this->priv;
 
-	this->write_byte = doc2000_write_byte;
 	this->read_byte = doc2000_read_byte;
 	this->write_buf = doc2000_writebuf;
 	this->read_buf = doc2000_readbuf;
@@ -1449,7 +1453,6 @@ static inline int __init doc2001_init(struct mtd_info *mtd)
 	struct nand_chip *this = mtd->priv;
 	struct doc_priv *doc = this->priv;
 
-	this->write_byte = doc2001_write_byte;
 	this->read_byte = doc2001_read_byte;
 	this->write_buf = doc2001_writebuf;
 	this->read_buf = doc2001_readbuf;
@@ -1481,16 +1484,15 @@ static inline int __init doc2001plus_init(struct mtd_info *mtd)
 	struct nand_chip *this = mtd->priv;
 	struct doc_priv *doc = this->priv;
 
-	this->write_byte = NULL;
 	this->read_byte = doc2001plus_read_byte;
 	this->write_buf = doc2001plus_writebuf;
 	this->read_buf = doc2001plus_readbuf;
 	this->verify_buf = doc2001plus_verifybuf;
 	this->scan_bbt = inftl_scan_bbt;
-	this->hwcontrol = NULL;
+	this->cmd_ctrl = NULL;
 	this->select_chip = doc2001plus_select_chip;
 	this->cmdfunc = doc2001plus_command;
-	this->enable_hwecc = doc2001plus_enable_hwecc;
+	this->ecc.hwctl = doc2001plus_enable_hwecc;
 
 	doc->chips_per_floor = 1;
 	mtd->name = "DiskOnChip Millennium Plus";
@@ -1498,7 +1500,7 @@ static inline int __init doc2001plus_init(struct mtd_info *mtd)
 	return 1;
 }
 
-static inline int __init doc_probe(unsigned long physadr)
+static int __init doc_probe(unsigned long physadr)
 {
 	unsigned char ChipID;
 	struct mtd_info *mtd;
@@ -1527,20 +1529,16 @@ static inline int __init doc_probe(unsigned long physadr)
 	save_control = ReadDOC(virtadr, DOCControl);
 
 	/* Reset the DiskOnChip ASIC */
-	WriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_RESET,
-		 virtadr, DOCControl);
-	WriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_RESET,
-		 virtadr, DOCControl);
+	WriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_RESET, virtadr, DOCControl);
+	WriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_RESET, virtadr, DOCControl);
 
 	/* Enable the DiskOnChip ASIC */
-	WriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_NORMAL,
-		 virtadr, DOCControl);
-	WriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_NORMAL,
-		 virtadr, DOCControl);
+	WriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_NORMAL, virtadr, DOCControl);
+	WriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_NORMAL, virtadr, DOCControl);
 
 	ChipID = ReadDOC(virtadr, ChipID);
 
-	switch(ChipID) {
+	switch (ChipID) {
 	case DOC_ChipID_Doc2k:
 		reg = DoC_2k_ECCStatus;
 		break;
@@ -1556,15 +1554,13 @@ static inline int __init doc_probe(unsigned long physadr)
 			ReadDOC(virtadr, Mplus_Power);
 
 		/* Reset the Millennium Plus ASIC */
-		tmp = DOC_MODE_RESET | DOC_MODE_MDWREN | DOC_MODE_RST_LAT |
-			DOC_MODE_BDECT;
+		tmp = DOC_MODE_RESET | DOC_MODE_MDWREN | DOC_MODE_RST_LAT | DOC_MODE_BDECT;
 		WriteDOC(tmp, virtadr, Mplus_DOCControl);
 		WriteDOC(~tmp, virtadr, Mplus_CtrlConfirm);
 
 		mdelay(1);
 		/* Enable the Millennium Plus ASIC */
-		tmp = DOC_MODE_NORMAL | DOC_MODE_MDWREN | DOC_MODE_RST_LAT |
-			DOC_MODE_BDECT;
+		tmp = DOC_MODE_NORMAL | DOC_MODE_MDWREN | DOC_MODE_RST_LAT | DOC_MODE_BDECT;
 		WriteDOC(tmp, virtadr, Mplus_DOCControl);
 		WriteDOC(~tmp, virtadr, Mplus_CtrlConfirm);
 		mdelay(1);
@@ -1588,7 +1584,7 @@ static inline int __init doc_probe(unsigned long physadr)
 		goto notfound;
 	}
 	/* Check the TOGGLE bit in the ECC register */
-	tmp  = ReadDOC_(virtadr, reg) & DOC_TOGGLE_BIT;
+	tmp = ReadDOC_(virtadr, reg) & DOC_TOGGLE_BIT;
 	tmpb = ReadDOC_(virtadr, reg) & DOC_TOGGLE_BIT;
 	tmpc = ReadDOC_(virtadr, reg) & DOC_TOGGLE_BIT;
 	if ((tmp == tmpb) || (tmp != tmpc)) {
@@ -1618,11 +1614,11 @@ static inline int __init doc_probe(unsigned long physadr)
 		if (ChipID == DOC_ChipID_DocMilPlus16) {
 			WriteDOC(~newval, virtadr, Mplus_AliasResolution);
 			oldval = ReadDOC(doc->virtadr, Mplus_AliasResolution);
-			WriteDOC(newval, virtadr, Mplus_AliasResolution); /* restore it */
+			WriteDOC(newval, virtadr, Mplus_AliasResolution);	/* restore it */
 		} else {
 			WriteDOC(~newval, virtadr, AliasResolution);
 			oldval = ReadDOC(doc->virtadr, AliasResolution);
-			WriteDOC(newval, virtadr, AliasResolution); /* restore it */
+			WriteDOC(newval, virtadr, AliasResolution);	/* restore it */
 		}
 		newval = ~newval;
 		if (oldval == newval) {
@@ -1634,16 +1630,13 @@ static inline int __init doc_probe(unsigned long physadr)
 	printk(KERN_NOTICE "DiskOnChip found at 0x%lx\n", physadr);
 
 	len = sizeof(struct mtd_info) +
-	      sizeof(struct nand_chip) +
-	      sizeof(struct doc_priv) +
-	      (2 * sizeof(struct nand_bbt_descr));
-	mtd =  kmalloc(len, GFP_KERNEL);
+	    sizeof(struct nand_chip) + sizeof(struct doc_priv) + (2 * sizeof(struct nand_bbt_descr));
+	mtd = kzalloc(len, GFP_KERNEL);
 	if (!mtd) {
 		printk(KERN_ERR "DiskOnChip kmalloc (%d bytes) failed!\n", len);
 		ret = -ENOMEM;
 		goto fail;
 	}
-	memset(mtd, 0, len);
 
 	nand			= (struct nand_chip *) (mtd + 1);
 	doc			= (struct doc_priv *) (nand + 1);
@@ -1655,17 +1648,19 @@ static inline int __init doc_probe(unsigned long physadr)
 
 	nand->priv		= doc;
 	nand->select_chip	= doc200x_select_chip;
-	nand->hwcontrol		= doc200x_hwcontrol;
+	nand->cmd_ctrl		= doc200x_hwcontrol;
 	nand->dev_ready		= doc200x_dev_ready;
 	nand->waitfunc		= doc200x_wait;
 	nand->block_bad		= doc200x_block_bad;
-	nand->enable_hwecc	= doc200x_enable_hwecc;
-	nand->calculate_ecc	= doc200x_calculate_ecc;
-	nand->correct_data	= doc200x_correct_data;
+	nand->ecc.hwctl		= doc200x_enable_hwecc;
+	nand->ecc.calculate	= doc200x_calculate_ecc;
+	nand->ecc.correct	= doc200x_correct_data;
 
-	nand->autooob		= &doc200x_oobinfo;
-	nand->eccmode		= NAND_ECC_HW6_512;
-	nand->options		= NAND_USE_FLASH_BBT | NAND_HWECC_SYNDROME;
+	nand->ecc.layout	= &doc200x_oobinfo;
+	nand->ecc.mode		= NAND_ECC_HW_SYNDROME;
+	nand->ecc.size		= 512;
+	nand->ecc.bytes		= 6;
+	nand->options		= NAND_USE_FLASH_BBT;
 
 	doc->physadr		= physadr;
 	doc->virtadr		= virtadr;
@@ -1699,11 +1694,11 @@ static inline int __init doc_probe(unsigned long physadr)
 	doclist = mtd;
 	return 0;
 
-notfound:
+ notfound:
 	/* Put back the contents of the DOCControl register, in case it's not
 	   actually a DiskOnChip.  */
 	WriteDOC(save_control, virtadr, DOCControl);
-fail:
+ fail:
 	iounmap(virtadr);
 	return ret;
 }
@@ -1740,7 +1735,7 @@ static int __init init_nanddoc(void)
 	 */
 	rs_decoder = init_rs(10, 0x409, FCR, 1, NROOTS);
 	if (!rs_decoder) {
-		printk (KERN_ERR "DiskOnChip: Could not create a RS decoder\n");
+		printk(KERN_ERR "DiskOnChip: Could not create a RS decoder\n");
 		return -ENOMEM;
 	}
 
@@ -1750,7 +1745,7 @@ static int __init init_nanddoc(void)
 		if (ret < 0)
 			goto outerr;
 	} else {
-		for (i=0; (doc_locations[i] != 0xffffffff); i++) {
+		for (i = 0; (doc_locations[i] != 0xffffffff); i++) {
 			doc_probe(doc_locations[i]);
 		}
 	}
@@ -1762,7 +1757,7 @@ static int __init init_nanddoc(void)
 		goto outerr;
 	}
 	return 0;
-outerr:
+ outerr:
 	free_rs(rs_decoder);
 	return ret;
 }
diff --git a/drivers/mtd/nand/fsl_elbc_nand.c b/drivers/mtd/nand/fsl_elbc_nand.c
new file mode 100644
index 0000000..3f318e0
--- /dev/null
+++ b/drivers/mtd/nand/fsl_elbc_nand.c
@@ -0,0 +1,827 @@
+/* Freescale Enhanced Local Bus Controller FCM NAND driver
+ *
+ * Copyright (c) 2006-2008 Freescale Semiconductor
+ *
+ * Authors: Nick Spence <nick.spence@freescale.com>,
+ *          Scott Wood <scottwood@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <common.h>
+#include <malloc.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+
+#include <asm/io.h>
+#include <asm/errno.h>
+
+#ifdef VERBOSE_DEBUG
+#define DEBUG_ELBC
+#define vdbg(format, arg...) printf("DEBUG: " format, ##arg)
+#else
+#define vdbg(format, arg...) do {} while (0)
+#endif
+
+/* Can't use plain old DEBUG because the linux mtd
+ * headers define it as a macro.
+ */
+#ifdef DEBUG_ELBC
+#define dbg(format, arg...) printf("DEBUG: " format, ##arg)
+#else
+#define dbg(format, arg...) do {} while (0)
+#endif
+
+#define MAX_BANKS 8
+#define ERR_BYTE 0xFF /* Value returned for read bytes when read failed */
+#define FCM_TIMEOUT_MSECS 10 /* Maximum number of mSecs to wait for FCM */
+
+#define LTESR_NAND_MASK (LTESR_FCT | LTESR_PAR | LTESR_CC)
+
+struct fsl_elbc_ctrl;
+
+/* mtd information per set */
+
+struct fsl_elbc_mtd {
+	struct mtd_info mtd;
+	struct nand_chip chip;
+	struct fsl_elbc_ctrl *ctrl;
+
+	struct device *dev;
+	int bank;               /* Chip select bank number           */
+	u8 __iomem *vbase;      /* Chip select base virtual address  */
+	int page_size;          /* NAND page size (0=512, 1=2048)    */
+	unsigned int fmr;       /* FCM Flash Mode Register value     */
+};
+
+/* overview of the fsl elbc controller */
+
+struct fsl_elbc_ctrl {
+	struct nand_hw_control controller;
+	struct fsl_elbc_mtd *chips[MAX_BANKS];
+
+	/* device info */
+	fsl_lbus_t *regs;
+	u8 __iomem *addr;        /* Address of assigned FCM buffer        */
+	unsigned int page;       /* Last page written to / read from      */
+	unsigned int read_bytes; /* Number of bytes read during command   */
+	unsigned int column;     /* Saved column from SEQIN               */
+	unsigned int index;      /* Pointer to next byte to 'read'        */
+	unsigned int status;     /* status read from LTESR after last op  */
+	unsigned int mdr;        /* UPM/FCM Data Register value           */
+	unsigned int use_mdr;    /* Non zero if the MDR is to be set      */
+	unsigned int oob;        /* Non zero if operating on OOB data     */
+	uint8_t *oob_poi;        /* Place to write ECC after read back    */
+};
+
+/* These map to the positions used by the FCM hardware ECC generator */
+
+/* Small Page FLASH with FMR[ECCM] = 0 */
+static struct nand_ecclayout fsl_elbc_oob_sp_eccm0 = {
+	.eccbytes = 3,
+	.eccpos = {6, 7, 8},
+	.oobfree = { {0, 5}, {9, 7} },
+};
+
+/* Small Page FLASH with FMR[ECCM] = 1 */
+static struct nand_ecclayout fsl_elbc_oob_sp_eccm1 = {
+	.eccbytes = 3,
+	.eccpos = {8, 9, 10},
+	.oobfree = { {0, 5}, {6, 2}, {11, 5} },
+};
+
+/* Large Page FLASH with FMR[ECCM] = 0 */
+static struct nand_ecclayout fsl_elbc_oob_lp_eccm0 = {
+	.eccbytes = 12,
+	.eccpos = {6, 7, 8, 22, 23, 24, 38, 39, 40, 54, 55, 56},
+	.oobfree = { {1, 5}, {9, 13}, {25, 13}, {41, 13}, {57, 7} },
+};
+
+/* Large Page FLASH with FMR[ECCM] = 1 */
+static struct nand_ecclayout fsl_elbc_oob_lp_eccm1 = {
+	.eccbytes = 12,
+	.eccpos = {8, 9, 10, 24, 25, 26, 40, 41, 42, 56, 57, 58},
+	.oobfree = { {1, 7}, {11, 13}, {27, 13}, {43, 13}, {59, 5} },
+};
+
+/*
+ * fsl_elbc_oob_lp_eccm* specify that LP NAND's OOB free area starts at offset
+ * 1, so we have to adjust bad block pattern. This pattern should be used for
+ * x8 chips only. So far hardware does not support x16 chips anyway.
+ */
+static u8 scan_ff_pattern[] = { 0xff, };
+
+static struct nand_bbt_descr largepage_memorybased = {
+	.options = 0,
+	.offs = 0,
+	.len = 1,
+	.pattern = scan_ff_pattern,
+};
+
+/*
+ * ELBC may use HW ECC, so that OOB offsets, that NAND core uses for bbt,
+ * interfere with ECC positions, that's why we implement our own descriptors.
+ * OOB {11, 5}, works for both SP and LP chips, with ECCM = 1 and ECCM = 0.
+ */
+static u8 bbt_pattern[] = {'B', 'b', 't', '0' };
+static u8 mirror_pattern[] = {'1', 't', 'b', 'B' };
+
+static struct nand_bbt_descr bbt_main_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE |
+		   NAND_BBT_2BIT | NAND_BBT_VERSION,
+	.offs =	11,
+	.len = 4,
+	.veroffs = 15,
+	.maxblocks = 4,
+	.pattern = bbt_pattern,
+};
+
+static struct nand_bbt_descr bbt_mirror_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE |
+		   NAND_BBT_2BIT | NAND_BBT_VERSION,
+	.offs =	11,
+	.len = 4,
+	.veroffs = 15,
+	.maxblocks = 4,
+	.pattern = mirror_pattern,
+};
+
+/*=================================*/
+
+/*
+ * Set up the FCM hardware block and page address fields, and the fcm
+ * structure addr field to point to the correct FCM buffer in memory
+ */
+static void set_addr(struct mtd_info *mtd, int column, int page_addr, int oob)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct fsl_elbc_mtd *priv = chip->priv;
+	struct fsl_elbc_ctrl *ctrl = priv->ctrl;
+	fsl_lbus_t *lbc = ctrl->regs;
+	int buf_num;
+
+	ctrl->page = page_addr;
+
+	if (priv->page_size) {
+		out_be32(&lbc->fbar, page_addr >> 6);
+		out_be32(&lbc->fpar,
+			 ((page_addr << FPAR_LP_PI_SHIFT) & FPAR_LP_PI) |
+			 (oob ? FPAR_LP_MS : 0) | column);
+		buf_num = (page_addr & 1) << 2;
+	} else {
+		out_be32(&lbc->fbar, page_addr >> 5);
+		out_be32(&lbc->fpar,
+			 ((page_addr << FPAR_SP_PI_SHIFT) & FPAR_SP_PI) |
+			 (oob ? FPAR_SP_MS : 0) | column);
+		buf_num = page_addr & 7;
+	}
+
+	ctrl->addr = priv->vbase + buf_num * 1024;
+	ctrl->index = column;
+
+	/* for OOB data point to the second half of the buffer */
+	if (oob)
+		ctrl->index += priv->page_size ? 2048 : 512;
+
+	vdbg("set_addr: bank=%d, ctrl->addr=0x%p (0x%p), "
+	     "index %x, pes %d ps %d\n",
+	     buf_num, ctrl->addr, priv->vbase, ctrl->index,
+	     chip->phys_erase_shift, chip->page_shift);
+}
+
+/*
+ * execute FCM command and wait for it to complete
+ */
+static int fsl_elbc_run_command(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct fsl_elbc_mtd *priv = chip->priv;
+	struct fsl_elbc_ctrl *ctrl = priv->ctrl;
+	fsl_lbus_t *lbc = ctrl->regs;
+	long long end_tick;
+	u32 ltesr;
+
+	/* Setup the FMR[OP] to execute without write protection */
+	out_be32(&lbc->fmr, priv->fmr | 3);
+	if (ctrl->use_mdr)
+		out_be32(&lbc->mdr, ctrl->mdr);
+
+	vdbg("fsl_elbc_run_command: fmr=%08x fir=%08x fcr=%08x\n",
+	     in_be32(&lbc->fmr), in_be32(&lbc->fir), in_be32(&lbc->fcr));
+	vdbg("fsl_elbc_run_command: fbar=%08x fpar=%08x "
+	     "fbcr=%08x bank=%d\n",
+	     in_be32(&lbc->fbar), in_be32(&lbc->fpar),
+	     in_be32(&lbc->fbcr), priv->bank);
+
+	/* execute special operation */
+	out_be32(&lbc->lsor, priv->bank);
+
+	/* wait for FCM complete flag or timeout */
+	end_tick = usec2ticks(FCM_TIMEOUT_MSECS * 1000) + get_ticks();
+
+	ltesr = 0;
+	while (end_tick > get_ticks()) {
+		ltesr = in_be32(&lbc->ltesr);
+		if (ltesr & LTESR_CC)
+			break;
+	}
+
+	ctrl->status = ltesr & LTESR_NAND_MASK;
+	out_be32(&lbc->ltesr, ctrl->status);
+	out_be32(&lbc->lteatr, 0);
+
+	/* store mdr value in case it was needed */
+	if (ctrl->use_mdr)
+		ctrl->mdr = in_be32(&lbc->mdr);
+
+	ctrl->use_mdr = 0;
+
+	vdbg("fsl_elbc_run_command: stat=%08x mdr=%08x fmr=%08x\n",
+	     ctrl->status, ctrl->mdr, in_be32(&lbc->fmr));
+
+	/* returns 0 on success otherwise non-zero) */
+	return ctrl->status == LTESR_CC ? 0 : -EIO;
+}
+
+static void fsl_elbc_do_read(struct nand_chip *chip, int oob)
+{
+	struct fsl_elbc_mtd *priv = chip->priv;
+	struct fsl_elbc_ctrl *ctrl = priv->ctrl;
+	fsl_lbus_t *lbc = ctrl->regs;
+
+	if (priv->page_size) {
+		out_be32(&lbc->fir,
+			 (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+			 (FIR_OP_CA  << FIR_OP1_SHIFT) |
+			 (FIR_OP_PA  << FIR_OP2_SHIFT) |
+			 (FIR_OP_CW1 << FIR_OP3_SHIFT) |
+			 (FIR_OP_RBW << FIR_OP4_SHIFT));
+
+		out_be32(&lbc->fcr, (NAND_CMD_READ0 << FCR_CMD0_SHIFT) |
+				    (NAND_CMD_READSTART << FCR_CMD1_SHIFT));
+	} else {
+		out_be32(&lbc->fir,
+			 (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+			 (FIR_OP_CA  << FIR_OP1_SHIFT) |
+			 (FIR_OP_PA  << FIR_OP2_SHIFT) |
+			 (FIR_OP_RBW << FIR_OP3_SHIFT));
+
+		if (oob)
+			out_be32(&lbc->fcr,
+				 NAND_CMD_READOOB << FCR_CMD0_SHIFT);
+		else
+			out_be32(&lbc->fcr, NAND_CMD_READ0 << FCR_CMD0_SHIFT);
+	}
+}
+
+/* cmdfunc send commands to the FCM */
+static void fsl_elbc_cmdfunc(struct mtd_info *mtd, unsigned int command,
+			     int column, int page_addr)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct fsl_elbc_mtd *priv = chip->priv;
+	struct fsl_elbc_ctrl *ctrl = priv->ctrl;
+	fsl_lbus_t *lbc = ctrl->regs;
+
+	ctrl->use_mdr = 0;
+
+	/* clear the read buffer */
+	ctrl->read_bytes = 0;
+	if (command != NAND_CMD_PAGEPROG)
+		ctrl->index = 0;
+
+	switch (command) {
+	/* READ0 and READ1 read the entire buffer to use hardware ECC. */
+	case NAND_CMD_READ1:
+		column += 256;
+
+	/* fall-through */
+	case NAND_CMD_READ0:
+		vdbg("fsl_elbc_cmdfunc: NAND_CMD_READ0, page_addr:"
+		     " 0x%x, column: 0x%x.\n", page_addr, column);
+
+		out_be32(&lbc->fbcr, 0); /* read entire page to enable ECC */
+		set_addr(mtd, 0, page_addr, 0);
+
+		ctrl->read_bytes = mtd->writesize + mtd->oobsize;
+		ctrl->index += column;
+
+		fsl_elbc_do_read(chip, 0);
+		fsl_elbc_run_command(mtd);
+		return;
+
+	/* READOOB reads only the OOB because no ECC is performed. */
+	case NAND_CMD_READOOB:
+		vdbg("fsl_elbc_cmdfunc: NAND_CMD_READOOB, page_addr:"
+		     " 0x%x, column: 0x%x.\n", page_addr, column);
+
+		out_be32(&lbc->fbcr, mtd->oobsize - column);
+		set_addr(mtd, column, page_addr, 1);
+
+		ctrl->read_bytes = mtd->writesize + mtd->oobsize;
+
+		fsl_elbc_do_read(chip, 1);
+		fsl_elbc_run_command(mtd);
+
+		return;
+
+	/* READID must read all 5 possible bytes while CEB is active */
+	case NAND_CMD_READID:
+		vdbg("fsl_elbc_cmdfunc: NAND_CMD_READID.\n");
+
+		out_be32(&lbc->fir, (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+				    (FIR_OP_UA  << FIR_OP1_SHIFT) |
+				    (FIR_OP_RBW << FIR_OP2_SHIFT));
+		out_be32(&lbc->fcr, NAND_CMD_READID << FCR_CMD0_SHIFT);
+		/* 5 bytes for manuf, device and exts */
+		out_be32(&lbc->fbcr, 5);
+		ctrl->read_bytes = 5;
+		ctrl->use_mdr = 1;
+		ctrl->mdr = 0;
+
+		set_addr(mtd, 0, 0, 0);
+		fsl_elbc_run_command(mtd);
+		return;
+
+	/* ERASE1 stores the block and page address */
+	case NAND_CMD_ERASE1:
+		vdbg("fsl_elbc_cmdfunc: NAND_CMD_ERASE1, "
+		     "page_addr: 0x%x.\n", page_addr);
+		set_addr(mtd, 0, page_addr, 0);
+		return;
+
+	/* ERASE2 uses the block and page address from ERASE1 */
+	case NAND_CMD_ERASE2:
+		vdbg("fsl_elbc_cmdfunc: NAND_CMD_ERASE2.\n");
+
+		out_be32(&lbc->fir,
+			 (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+			 (FIR_OP_PA  << FIR_OP1_SHIFT) |
+			 (FIR_OP_CM1 << FIR_OP2_SHIFT));
+
+		out_be32(&lbc->fcr,
+			 (NAND_CMD_ERASE1 << FCR_CMD0_SHIFT) |
+			 (NAND_CMD_ERASE2 << FCR_CMD1_SHIFT));
+
+		out_be32(&lbc->fbcr, 0);
+		ctrl->read_bytes = 0;
+
+		fsl_elbc_run_command(mtd);
+		return;
+
+	/* SEQIN sets up the addr buffer and all registers except the length */
+	case NAND_CMD_SEQIN: {
+		u32 fcr;
+		vdbg("fsl_elbc_cmdfunc: NAND_CMD_SEQIN/PAGE_PROG, "
+		     "page_addr: 0x%x, column: 0x%x.\n",
+		     page_addr, column);
+
+		ctrl->column = column;
+		ctrl->oob = 0;
+
+		if (priv->page_size) {
+			fcr = (NAND_CMD_SEQIN << FCR_CMD0_SHIFT) |
+			      (NAND_CMD_PAGEPROG << FCR_CMD1_SHIFT);
+
+			out_be32(&lbc->fir,
+				 (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+				 (FIR_OP_CA  << FIR_OP1_SHIFT) |
+				 (FIR_OP_PA  << FIR_OP2_SHIFT) |
+				 (FIR_OP_WB  << FIR_OP3_SHIFT) |
+				 (FIR_OP_CW1 << FIR_OP4_SHIFT));
+		} else {
+			fcr = (NAND_CMD_PAGEPROG << FCR_CMD1_SHIFT) |
+			      (NAND_CMD_SEQIN << FCR_CMD2_SHIFT);
+
+			out_be32(&lbc->fir,
+				 (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+				 (FIR_OP_CM2 << FIR_OP1_SHIFT) |
+				 (FIR_OP_CA  << FIR_OP2_SHIFT) |
+				 (FIR_OP_PA  << FIR_OP3_SHIFT) |
+				 (FIR_OP_WB  << FIR_OP4_SHIFT) |
+				 (FIR_OP_CW1 << FIR_OP5_SHIFT));
+
+			if (column >= mtd->writesize) {
+				/* OOB area --> READOOB */
+				column -= mtd->writesize;
+				fcr |= NAND_CMD_READOOB << FCR_CMD0_SHIFT;
+				ctrl->oob = 1;
+			} else if (column < 256) {
+				/* First 256 bytes --> READ0 */
+				fcr |= NAND_CMD_READ0 << FCR_CMD0_SHIFT;
+			} else {
+				/* Second 256 bytes --> READ1 */
+				fcr |= NAND_CMD_READ1 << FCR_CMD0_SHIFT;
+			}
+		}
+
+		out_be32(&lbc->fcr, fcr);
+		set_addr(mtd, column, page_addr, ctrl->oob);
+		return;
+	}
+
+	/* PAGEPROG reuses all of the setup from SEQIN and adds the length */
+	case NAND_CMD_PAGEPROG: {
+		int full_page;
+		vdbg("fsl_elbc_cmdfunc: NAND_CMD_PAGEPROG "
+		     "writing %d bytes.\n", ctrl->index);
+
+		/* if the write did not start at 0 or is not a full page
+		 * then set the exact length, otherwise use a full page
+		 * write so the HW generates the ECC.
+		 */
+		if (ctrl->oob || ctrl->column != 0 ||
+		    ctrl->index != mtd->writesize + mtd->oobsize) {
+			out_be32(&lbc->fbcr, ctrl->index);
+			full_page = 0;
+		} else {
+			out_be32(&lbc->fbcr, 0);
+			full_page = 1;
+		}
+
+		fsl_elbc_run_command(mtd);
+
+		/* Read back the page in order to fill in the ECC for the
+		 * caller.  Is this really needed?
+		 */
+		if (full_page && ctrl->oob_poi) {
+			out_be32(&lbc->fbcr, 3);
+			set_addr(mtd, 6, page_addr, 1);
+
+			ctrl->read_bytes = mtd->writesize + 9;
+
+			fsl_elbc_do_read(chip, 1);
+			fsl_elbc_run_command(mtd);
+
+			memcpy_fromio(ctrl->oob_poi + 6,
+				      &ctrl->addr[ctrl->index], 3);
+			ctrl->index += 3;
+		}
+
+		ctrl->oob_poi = NULL;
+		return;
+	}
+
+	/* CMD_STATUS must read the status byte while CEB is active */
+	/* Note - it does not wait for the ready line */
+	case NAND_CMD_STATUS:
+		out_be32(&lbc->fir,
+			 (FIR_OP_CM0 << FIR_OP0_SHIFT) |
+			 (FIR_OP_RBW << FIR_OP1_SHIFT));
+		out_be32(&lbc->fcr, NAND_CMD_STATUS << FCR_CMD0_SHIFT);
+		out_be32(&lbc->fbcr, 1);
+		set_addr(mtd, 0, 0, 0);
+		ctrl->read_bytes = 1;
+
+		fsl_elbc_run_command(mtd);
+
+		/* The chip always seems to report that it is
+		 * write-protected, even when it is not.
+		 */
+		out_8(ctrl->addr, in_8(ctrl->addr) | NAND_STATUS_WP);
+		return;
+
+	/* RESET without waiting for the ready line */
+	case NAND_CMD_RESET:
+		dbg("fsl_elbc_cmdfunc: NAND_CMD_RESET.\n");
+		out_be32(&lbc->fir, FIR_OP_CM0 << FIR_OP0_SHIFT);
+		out_be32(&lbc->fcr, NAND_CMD_RESET << FCR_CMD0_SHIFT);
+		fsl_elbc_run_command(mtd);
+		return;
+
+	default:
+		printf("fsl_elbc_cmdfunc: error, unsupported command 0x%x.\n",
+			command);
+	}
+}
+
+static void fsl_elbc_select_chip(struct mtd_info *mtd, int chip)
+{
+	/* The hardware does not seem to support multiple
+	 * chips per bank.
+	 */
+}
+
+/*
+ * Write buf to the FCM Controller Data Buffer
+ */
+static void fsl_elbc_write_buf(struct mtd_info *mtd, const u8 *buf, int len)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct fsl_elbc_mtd *priv = chip->priv;
+	struct fsl_elbc_ctrl *ctrl = priv->ctrl;
+	unsigned int bufsize = mtd->writesize + mtd->oobsize;
+
+	if (len <= 0) {
+		printf("write_buf of %d bytes", len);
+		ctrl->status = 0;
+		return;
+	}
+
+	if ((unsigned int)len > bufsize - ctrl->index) {
+		printf("write_buf beyond end of buffer "
+		       "(%d requested, %u available)\n",
+		       len, bufsize - ctrl->index);
+		len = bufsize - ctrl->index;
+	}
+
+	memcpy_toio(&ctrl->addr[ctrl->index], buf, len);
+	/*
+	 * This is workaround for the weird elbc hangs during nand write,
+	 * Scott Wood says: "...perhaps difference in how long it takes a
+	 * write to make it through the localbus compared to a write to IMMR
+	 * is causing problems, and sync isn't helping for some reason."
+	 * Reading back the last byte helps though.
+	 */
+	in_8(&ctrl->addr[ctrl->index] + len - 1);
+
+	ctrl->index += len;
+}
+
+/*
+ * read a byte from either the FCM hardware buffer if it has any data left
+ * otherwise issue a command to read a single byte.
+ */
+static u8 fsl_elbc_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct fsl_elbc_mtd *priv = chip->priv;
+	struct fsl_elbc_ctrl *ctrl = priv->ctrl;
+
+	/* If there are still bytes in the FCM, then use the next byte. */
+	if (ctrl->index < ctrl->read_bytes)
+		return in_8(&ctrl->addr[ctrl->index++]);
+
+	printf("read_byte beyond end of buffer\n");
+	return ERR_BYTE;
+}
+
+/*
+ * Read from the FCM Controller Data Buffer
+ */
+static void fsl_elbc_read_buf(struct mtd_info *mtd, u8 *buf, int len)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct fsl_elbc_mtd *priv = chip->priv;
+	struct fsl_elbc_ctrl *ctrl = priv->ctrl;
+	int avail;
+
+	if (len < 0)
+		return;
+
+	avail = min((unsigned int)len, ctrl->read_bytes - ctrl->index);
+	memcpy_fromio(buf, &ctrl->addr[ctrl->index], avail);
+	ctrl->index += avail;
+
+	if (len > avail)
+		printf("read_buf beyond end of buffer "
+		       "(%d requested, %d available)\n",
+		       len, avail);
+}
+
+/*
+ * Verify buffer against the FCM Controller Data Buffer
+ */
+static int fsl_elbc_verify_buf(struct mtd_info *mtd,
+			       const u_char *buf, int len)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct fsl_elbc_mtd *priv = chip->priv;
+	struct fsl_elbc_ctrl *ctrl = priv->ctrl;
+	int i;
+
+	if (len < 0) {
+		printf("write_buf of %d bytes", len);
+		return -EINVAL;
+	}
+
+	if ((unsigned int)len > ctrl->read_bytes - ctrl->index) {
+		printf("verify_buf beyond end of buffer "
+		       "(%d requested, %u available)\n",
+		       len, ctrl->read_bytes - ctrl->index);
+
+		ctrl->index = ctrl->read_bytes;
+		return -EINVAL;
+	}
+
+	for (i = 0; i < len; i++)
+		if (in_8(&ctrl->addr[ctrl->index + i]) != buf[i])
+			break;
+
+	ctrl->index += len;
+	return i == len && ctrl->status == LTESR_CC ? 0 : -EIO;
+}
+
+/* This function is called after Program and Erase Operations to
+ * check for success or failure.
+ */
+static int fsl_elbc_wait(struct mtd_info *mtd, struct nand_chip *chip)
+{
+	struct fsl_elbc_mtd *priv = chip->priv;
+	struct fsl_elbc_ctrl *ctrl = priv->ctrl;
+	fsl_lbus_t *lbc = ctrl->regs;
+
+	if (ctrl->status != LTESR_CC)
+		return NAND_STATUS_FAIL;
+
+	/* Use READ_STATUS command, but wait for the device to be ready */
+	ctrl->use_mdr = 0;
+	out_be32(&lbc->fir,
+		 (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+		 (FIR_OP_RBW << FIR_OP1_SHIFT));
+	out_be32(&lbc->fcr, NAND_CMD_STATUS << FCR_CMD0_SHIFT);
+	out_be32(&lbc->fbcr, 1);
+	set_addr(mtd, 0, 0, 0);
+	ctrl->read_bytes = 1;
+
+	fsl_elbc_run_command(mtd);
+
+	if (ctrl->status != LTESR_CC)
+		return NAND_STATUS_FAIL;
+
+	/* The chip always seems to report that it is
+	 * write-protected, even when it is not.
+	 */
+	out_8(ctrl->addr, in_8(ctrl->addr) | NAND_STATUS_WP);
+	return fsl_elbc_read_byte(mtd);
+}
+
+static int fsl_elbc_read_page(struct mtd_info *mtd,
+			      struct nand_chip *chip,
+			      uint8_t *buf)
+{
+	fsl_elbc_read_buf(mtd, buf, mtd->writesize);
+	fsl_elbc_read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	if (fsl_elbc_wait(mtd, chip) & NAND_STATUS_FAIL)
+		mtd->ecc_stats.failed++;
+
+	return 0;
+}
+
+/* ECC will be calculated automatically, and errors will be detected in
+ * waitfunc.
+ */
+static void fsl_elbc_write_page(struct mtd_info *mtd,
+				struct nand_chip *chip,
+				const uint8_t *buf)
+{
+	struct fsl_elbc_mtd *priv = chip->priv;
+	struct fsl_elbc_ctrl *ctrl = priv->ctrl;
+
+	fsl_elbc_write_buf(mtd, buf, mtd->writesize);
+	fsl_elbc_write_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	ctrl->oob_poi = chip->oob_poi;
+}
+
+static struct fsl_elbc_ctrl *elbc_ctrl;
+
+static void fsl_elbc_ctrl_init(void)
+{
+	elbc_ctrl = kzalloc(sizeof(*elbc_ctrl), GFP_KERNEL);
+	if (!elbc_ctrl)
+		return;
+
+#ifdef CONFIG_MPC85xx
+	elbc_ctrl->regs = (void *)CONFIG_SYS_MPC85xx_LBC_ADDR;
+#else
+	elbc_ctrl->regs = &((immap_t *)CONFIG_SYS_IMMR)->lbus;
+#endif
+
+	/* clear event registers */
+	out_be32(&elbc_ctrl->regs->ltesr, LTESR_NAND_MASK);
+	out_be32(&elbc_ctrl->regs->lteatr, 0);
+
+	/* Enable interrupts for any detected events */
+	out_be32(&elbc_ctrl->regs->lteir, LTESR_NAND_MASK);
+
+	elbc_ctrl->read_bytes = 0;
+	elbc_ctrl->index = 0;
+	elbc_ctrl->addr = NULL;
+}
+
+int board_nand_init(struct nand_chip *nand)
+{
+	struct fsl_elbc_mtd *priv;
+	uint32_t br = 0, or = 0;
+
+	if (!elbc_ctrl) {
+		fsl_elbc_ctrl_init();
+		if (!elbc_ctrl)
+			return -1;
+	}
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->ctrl = elbc_ctrl;
+	priv->vbase = nand->IO_ADDR_R;
+
+	/* Find which chip select it is connected to.  It'd be nice
+	 * if we could pass more than one datum to the NAND driver...
+	 */
+	for (priv->bank = 0; priv->bank < MAX_BANKS; priv->bank++) {
+		phys_addr_t base_addr = virt_to_phys(nand->IO_ADDR_R);
+
+		br = in_be32(&elbc_ctrl->regs->bank[priv->bank].br);
+		or = in_be32(&elbc_ctrl->regs->bank[priv->bank].or);
+
+		if ((br & BR_V) && (br & BR_MSEL) == BR_MS_FCM &&
+		    (br & or & BR_BA) == BR_PHYS_ADDR(base_addr))
+			break;
+	}
+
+	if (priv->bank >= MAX_BANKS) {
+		printf("fsl_elbc_nand: address did not match any "
+		       "chip selects\n");
+		return -ENODEV;
+	}
+
+	elbc_ctrl->chips[priv->bank] = priv;
+
+	/* fill in nand_chip structure */
+	/* set up function call table */
+	nand->read_byte = fsl_elbc_read_byte;
+	nand->write_buf = fsl_elbc_write_buf;
+	nand->read_buf = fsl_elbc_read_buf;
+	nand->verify_buf = fsl_elbc_verify_buf;
+	nand->select_chip = fsl_elbc_select_chip;
+	nand->cmdfunc = fsl_elbc_cmdfunc;
+	nand->waitfunc = fsl_elbc_wait;
+
+	/* set up nand options */
+	nand->bbt_td = &bbt_main_descr;
+	nand->bbt_md = &bbt_mirror_descr;
+
+  	/* set up nand options */
+	nand->options = NAND_NO_READRDY | NAND_NO_AUTOINCR |
+			NAND_USE_FLASH_BBT;
+
+	nand->controller = &elbc_ctrl->controller;
+	nand->priv = priv;
+
+	nand->ecc.read_page = fsl_elbc_read_page;
+	nand->ecc.write_page = fsl_elbc_write_page;
+
+#ifdef CONFIG_FSL_ELBC_FMR
+	priv->fmr = CONFIG_FSL_ELBC_FMR;
+#else
+	priv->fmr = (15 << FMR_CWTO_SHIFT) | (2 << FMR_AL_SHIFT);
+
+	/*
+	 * Hardware expects small page has ECCM0, large page has ECCM1
+	 * when booting from NAND.  Board config can override if not
+	 * booting from NAND.
+	 */
+	if (or & OR_FCM_PGS)
+		priv->fmr |= FMR_ECCM;
+#endif
+
+	/* If CS Base Register selects full hardware ECC then use it */
+	if ((br & BR_DECC) == BR_DECC_CHK_GEN) {
+		nand->ecc.mode = NAND_ECC_HW;
+
+		nand->ecc.layout = (priv->fmr & FMR_ECCM) ?
+				   &fsl_elbc_oob_sp_eccm1 :
+				   &fsl_elbc_oob_sp_eccm0;
+
+		nand->ecc.size = 512;
+		nand->ecc.bytes = 3;
+		nand->ecc.steps = 1;
+	} else {
+		/* otherwise fall back to default software ECC */
+		nand->ecc.mode = NAND_ECC_SOFT;
+	}
+
+	/* Large-page-specific setup */
+	if (or & OR_FCM_PGS) {
+		priv->page_size = 1;
+		nand->badblock_pattern = &largepage_memorybased;
+
+		/* adjust ecc setup if needed */
+		if ((br & BR_DECC) == BR_DECC_CHK_GEN) {
+			nand->ecc.steps = 4;
+			nand->ecc.layout = (priv->fmr & FMR_ECCM) ?
+					   &fsl_elbc_oob_lp_eccm1 :
+					   &fsl_elbc_oob_lp_eccm0;
+		}
+	}
+
+	return 0;
+}
diff --git a/drivers/mtd/nand/fsl_upm.c b/drivers/mtd/nand/fsl_upm.c
index 67ae9c8..7cb99cb 100644
--- a/drivers/mtd/nand/fsl_upm.c
+++ b/drivers/mtd/nand/fsl_upm.c
@@ -11,8 +11,6 @@
  */
 
 #include <config.h>
-
-#if defined(CONFIG_CMD_NAND) && defined(CONFIG_NAND_FSL_UPM)
 #include <common.h>
 #include <asm/io.h>
 #include <asm/errno.h>
@@ -20,8 +18,6 @@
 #include <linux/mtd/fsl_upm.h>
 #include <nand.h>
 
-static int fsl_upm_in_pattern;
-
 static void fsl_upm_start_pattern(struct fsl_upm *upm, u32 pat_offset)
 {
 	clrsetbits_be32(upm->mxmr, MxMR_MAD_MSK, MxMR_OP_RUNP | pat_offset);
@@ -35,66 +31,95 @@ static void fsl_upm_end_pattern(struct fsl_upm *upm)
 		eieio();
 }
 
-static void fsl_upm_run_pattern(struct fsl_upm *upm, int width, u32 cmd)
+static void fsl_upm_run_pattern(struct fsl_upm *upm, int width,
+				void __iomem *io_addr, u32 mar)
 {
-	out_be32(upm->mar, cmd << (32 - width));
+	out_be32(upm->mar, mar);
 	switch (width) {
 	case 8:
-		out_8(upm->io_addr, 0x0);
+		out_8(io_addr, 0x0);
 		break;
 	case 16:
-		out_be16(upm->io_addr, 0x0);
+		out_be16(io_addr, 0x0);
 		break;
 	case 32:
-		out_be32(upm->io_addr, 0x0);
+		out_be32(io_addr, 0x0);
 		break;
 	}
 }
 
-static void nand_hwcontrol (struct mtd_info *mtd, int cmd)
+static void fun_wait(struct fsl_upm_nand *fun)
+{
+	if (fun->dev_ready) {
+		while (!fun->dev_ready(fun->chip_nr))
+			debug("unexpected busy state\n");
+	} else {
+		/*
+		 * If the R/B pin is not connected, like on the TQM8548,
+		 * a short delay is necessary.
+		 */
+		udelay(1);
+	}
+}
+
+#if CONFIG_SYS_NAND_MAX_CHIPS > 1
+static void fun_select_chip(struct mtd_info *mtd, int chip_nr)
 {
 	struct nand_chip *chip = mtd->priv;
 	struct fsl_upm_nand *fun = chip->priv;
 
-	switch (cmd) {
-	case NAND_CTL_SETCLE:
-		fsl_upm_start_pattern(&fun->upm, fun->upm_cmd_offset);
-		fsl_upm_in_pattern++;
-		break;
-	case NAND_CTL_SETALE:
-		fsl_upm_start_pattern(&fun->upm, fun->upm_addr_offset);
-		fsl_upm_in_pattern++;
-		break;
-	case NAND_CTL_CLRCLE:
-	case NAND_CTL_CLRALE:
-		fsl_upm_end_pattern(&fun->upm);
-		fsl_upm_in_pattern--;
-		break;
+	if (chip_nr >= 0) {
+		fun->chip_nr = chip_nr;
+		chip->IO_ADDR_R = chip->IO_ADDR_W =
+			fun->upm.io_addr + fun->chip_offset * chip_nr;
+	} else if (chip_nr == -1) {
+		chip->cmd_ctrl(mtd, NAND_CMD_NONE, 0 | NAND_CTRL_CHANGE);
 	}
 }
+#endif
 
-static void nand_write_byte(struct mtd_info *mtd, u_char byte)
+static void fun_cmd_ctrl(struct mtd_info *mtd, int cmd, unsigned int ctrl)
 {
 	struct nand_chip *chip = mtd->priv;
+	struct fsl_upm_nand *fun = chip->priv;
+	void __iomem *io_addr;
+	u32 mar;
 
-	if (fsl_upm_in_pattern) {
-		struct fsl_upm_nand *fun = chip->priv;
+	if (!(ctrl & fun->last_ctrl)) {
+		fsl_upm_end_pattern(&fun->upm);
 
-		fsl_upm_run_pattern(&fun->upm, fun->width, byte);
+		if (cmd == NAND_CMD_NONE)
+			return;
 
-		/*
-		 * Some boards/chips needs this. At least on MPC8360E-RDK we
-		 * need it. Probably weird chip, because I don't see any need
-		 * for this on MPC8555E + Samsung K9F1G08U0A. Usually here are
-		 * 0-2 unexpected busy states per block read.
-		 */
-		if (fun->wait_pattern) {
-			while (!fun->dev_ready())
-				debug("unexpected busy state\n");
-		}
-	} else {
-		out_8(chip->IO_ADDR_W, byte);
+		fun->last_ctrl = ctrl & (NAND_ALE | NAND_CLE);
+	}
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		if (ctrl & NAND_ALE)
+			fsl_upm_start_pattern(&fun->upm, fun->upm_addr_offset);
+		else if (ctrl & NAND_CLE)
+			fsl_upm_start_pattern(&fun->upm, fun->upm_cmd_offset);
+	}
+
+	mar = cmd << (32 - fun->width);
+	io_addr = fun->upm.io_addr;
+#if CONFIG_SYS_NAND_MAX_CHIPS > 1
+	if (fun->chip_nr > 0) {
+		io_addr += fun->chip_offset * fun->chip_nr;
+		if (fun->upm_mar_chip_offset)
+			mar |= fun->upm_mar_chip_offset * fun->chip_nr;
 	}
+#endif
+	fsl_upm_run_pattern(&fun->upm, fun->width, io_addr, mar);
+
+	/*
+	 * Some boards/chips needs this. At least the MPC8360E-RDK and
+	 * TQM8548 need it. Probably weird chip, because I don't see
+	 * any need for this on MPC8555E + Samsung K9F1G08U0A. Usually
+	 * here are 0-2 unexpected busy states per block read.
+	 */
+	if (fun->wait_flags & FSL_UPM_WAIT_RUN_PATTERN)
+		fun_wait(fun);
 }
 
 static u8 nand_read_byte(struct mtd_info *mtd)
@@ -108,9 +133,16 @@ static void nand_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
 {
 	int i;
 	struct nand_chip *chip = mtd->priv;
+	struct fsl_upm_nand *fun = chip->priv;
 
-	for (i = 0; i < len; i++)
+	for (i = 0; i < len; i++) {
 		out_8(chip->IO_ADDR_W, buf[i]);
+		if (fun->wait_flags & FSL_UPM_WAIT_WRITE_BYTE)
+			fun_wait(fun);
+	}
+
+	if (fun->wait_flags & FSL_UPM_WAIT_WRITE_BUFFER)
+		fun_wait(fun);
 }
 
 static void nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
@@ -140,7 +172,7 @@ static int nand_dev_ready(struct mtd_info *mtd)
 	struct nand_chip *chip = mtd->priv;
 	struct fsl_upm_nand *fun = chip->priv;
 
-	return fun->dev_ready();
+	return fun->dev_ready(fun->chip_nr);
 }
 
 int fsl_upm_nand_init(struct nand_chip *chip, struct fsl_upm_nand *fun)
@@ -148,13 +180,17 @@ int fsl_upm_nand_init(struct nand_chip *chip, struct fsl_upm_nand *fun)
 	if (fun->width != 8 && fun->width != 16 && fun->width != 32)
 		return -ENOSYS;
 
+	fun->last_ctrl = NAND_CLE;
+
 	chip->priv = fun;
 	chip->chip_delay = fun->chip_delay;
-	chip->eccmode = NAND_ECC_SOFT;
-	chip->hwcontrol = nand_hwcontrol;
+	chip->ecc.mode = NAND_ECC_SOFT;
+	chip->cmd_ctrl = fun_cmd_ctrl;
+#if CONFIG_SYS_NAND_MAX_CHIPS > 1
+	chip->select_chip = fun_select_chip;
+#endif
 	chip->read_byte = nand_read_byte;
 	chip->read_buf = nand_read_buf;
-	chip->write_byte = nand_write_byte;
 	chip->write_buf = nand_write_buf;
 	chip->verify_buf = nand_verify_buf;
 	if (fun->dev_ready)
@@ -162,4 +198,3 @@ int fsl_upm_nand_init(struct nand_chip *chip, struct fsl_upm_nand *fun)
 
 	return 0;
 }
-#endif /* CONFIG_CMD_NAND */
diff --git a/drivers/mtd/nand/nand.c b/drivers/mtd/nand/nand.c
index e44470e..d369115 100644
--- a/drivers/mtd/nand/nand.c
+++ b/drivers/mtd/nand/nand.c
@@ -22,35 +22,50 @@
  */
 
 #include <common.h>
-
-#if defined(CONFIG_CMD_NAND) && !defined(CFG_NAND_LEGACY)
-
 #include <nand.h>
 
-#ifndef CFG_NAND_BASE_LIST
-#define CFG_NAND_BASE_LIST { CFG_NAND_BASE }
+#ifndef CONFIG_SYS_NAND_BASE_LIST
+#define CONFIG_SYS_NAND_BASE_LIST { CONFIG_SYS_NAND_BASE }
 #endif
 
+DECLARE_GLOBAL_DATA_PTR;
+
 int nand_curr_device = -1;
-nand_info_t nand_info[CFG_MAX_NAND_DEVICE];
+nand_info_t nand_info[CONFIG_SYS_MAX_NAND_DEVICE];
 
-static struct nand_chip nand_chip[CFG_MAX_NAND_DEVICE];
-static ulong base_address[CFG_MAX_NAND_DEVICE] = CFG_NAND_BASE_LIST;
+static struct nand_chip nand_chip[CONFIG_SYS_MAX_NAND_DEVICE];
+static ulong base_address[CONFIG_SYS_MAX_NAND_DEVICE] = CONFIG_SYS_NAND_BASE_LIST;
 
 static const char default_nand_name[] = "nand";
-
-extern int board_nand_init(struct nand_chip *nand);
+static __attribute__((unused)) char dev_name[CONFIG_SYS_MAX_NAND_DEVICE][8];
 
 static void nand_init_chip(struct mtd_info *mtd, struct nand_chip *nand,
 			   ulong base_addr)
 {
+	int maxchips = CONFIG_SYS_NAND_MAX_CHIPS;
+	int __attribute__((unused)) i = 0;
+
+	if (maxchips < 1)
+		maxchips = 1;
 	mtd->priv = nand;
 
 	nand->IO_ADDR_R = nand->IO_ADDR_W = (void  __iomem *)base_addr;
 	if (board_nand_init(nand) == 0) {
-		if (nand_scan(mtd, 1) == 0) {
+		if (nand_scan(mtd, maxchips) == 0) {
 			if (!mtd->name)
 				mtd->name = (char *)default_nand_name;
+			else
+				mtd->name += gd->reloc_off;
+
+#ifdef CONFIG_MTD_PARTITIONS
+			/*
+			 * Add MTD device so that we can reference it later
+			 * via the mtdcore infrastructure (e.g. ubi).
+			 */
+			sprintf(dev_name[i], "nand%d", i);
+			mtd->name = dev_name[i++];
+			add_mtd_device(mtd);
+#endif
 		} else
 			mtd->name = NULL;
 	} else {
@@ -64,20 +79,18 @@ void nand_init(void)
 {
 	int i;
 	unsigned int size = 0;
-	for (i = 0; i < CFG_MAX_NAND_DEVICE; i++) {
+	for (i = 0; i < CONFIG_SYS_MAX_NAND_DEVICE; i++) {
 		nand_init_chip(&nand_info[i], &nand_chip[i], base_address[i]);
-		size += nand_info[i].size;
+		size += nand_info[i].size / 1024;
 		if (nand_curr_device == -1)
 			nand_curr_device = i;
 	}
-	printf("%u MiB\n", size / (1024 * 1024));
+	printf("%u MiB\n", size / 1024);
 
-#ifdef CFG_NAND_SELECT_DEVICE
+#ifdef CONFIG_SYS_NAND_SELECT_DEVICE
 	/*
 	 * Select the chip in the board/cpu specific driver
 	 */
 	board_nand_select_device(nand_info[nand_curr_device].priv, nand_curr_device);
 #endif
 }
-
-#endif
diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index 6416d15..d2bd996 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -7,41 +7,24 @@
  *   Basic support for AG-AND chips is provided.
  *
  *	Additional technical information is available on
- *	http://www.linux-mtd.infradead.org/tech/nand.html
+ *	http://www.linux-mtd.infradead.org/doc/nand.html
  *
  *  Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)
- *		  2002 Thomas Gleixner (tglx@linutronix.de)
+ *		  2002-2006 Thomas Gleixner (tglx@linutronix.de)
  *
- *  02-08-2004  tglx: support for strange chips, which cannot auto increment
- *		pages on read / read_oob
- *
- *  03-17-2004  tglx: Check ready before auto increment check. Simon Bayes
- *		pointed this out, as he marked an auto increment capable chip
- *		as NOAUTOINCR in the board driver.
- *		Make reads over block boundaries work too
- *
- *  04-14-2004	tglx: first working version for 2k page size chips
- *
- *  05-19-2004  tglx: Basic support for Renesas AG-AND chips
- *
- *  09-24-2004  tglx: add support for hardware controllers (e.g. ECC) shared
- *		among multiple independend devices. Suggestions and initial patch
- *		from Ben Dooks <ben-mtd@fluff.org>
- *
- * Credits:
+ *  Credits:
  *	David Woodhouse for adding multichip support
  *
  *	Aleph One Ltd. and Toby Churchill Ltd. for supporting the
  *	rework for 2K page size chips
  *
- * TODO:
+ *  TODO:
  *	Enable cached programming for 2k page size chips
  *	Check, if mtd->ecctype should be set to MTD_ECC_HW
  *	if we have HW ecc support.
  *	The AG-AND chips have nice features for speed improvement,
  *	which are not supported yet. Read / program 4 pages in one go.
- *
- * $Id: nand_base.c,v 1.126 2004/12/13 11:22:25 lavinen Exp $
+ *	BBT table is not serialized, has to be fixed
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -51,8 +34,10 @@
 
 /* XXX U-BOOT XXX */
 #if 0
+#include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
+#include <linux/err.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/types.h>
@@ -62,6 +47,7 @@
 #include <linux/mtd/compatmac.h>
 #include <linux/interrupt.h>
 #include <linux/bitops.h>
+#include <linux/leds.h>
 #include <asm/io.h>
 
 #ifdef CONFIG_MTD_PARTITIONS
@@ -72,15 +58,20 @@
 
 #include <common.h>
 
-#if defined(CONFIG_CMD_NAND) && !defined(CFG_NAND_LEGACY)
+#define ENOTSUPP	524	/* Operation is not supported */
 
 #include <malloc.h>
 #include <watchdog.h>
+#include <linux/err.h>
 #include <linux/mtd/compat.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/nand.h>
 #include <linux/mtd/nand_ecc.h>
 
+#ifdef CONFIG_MTD_PARTITIONS
+#include <linux/mtd/partitions.h>
+#endif
+
 #include <asm/io.h>
 #include <asm/errno.h>
 
@@ -88,84 +79,79 @@
 #include <jffs2/jffs2.h>
 #endif
 
+/*
+ * CONFIG_SYS_NAND_RESET_CNT is used as a timeout mechanism when resetting
+ * a flash.  NAND flash is initialized prior to interrupts so standard timers
+ * can't be used.  CONFIG_SYS_NAND_RESET_CNT should be set to a value
+ * which is greater than (max NAND reset time / NAND status read time).
+ * A conservative default of 200000 (500 us / 25 ns) is used as a default.
+ */
+#ifndef CONFIG_SYS_NAND_RESET_CNT
+#define CONFIG_SYS_NAND_RESET_CNT 200000
+#endif
+
 /* Define default oob placement schemes for large and small page devices */
-static struct nand_oobinfo nand_oob_8 = {
-	.useecc = MTD_NANDECC_AUTOPLACE,
+static struct nand_ecclayout nand_oob_8 = {
 	.eccbytes = 3,
 	.eccpos = {0, 1, 2},
-	.oobfree = { {3, 2}, {6, 2} }
+	.oobfree = {
+		{.offset = 3,
+		 .length = 2},
+		{.offset = 6,
+		 .length = 2}}
 };
 
-static struct nand_oobinfo nand_oob_16 = {
-	.useecc = MTD_NANDECC_AUTOPLACE,
+static struct nand_ecclayout nand_oob_16 = {
 	.eccbytes = 6,
 	.eccpos = {0, 1, 2, 3, 6, 7},
-	.oobfree = { {8, 8} }
+	.oobfree = {
+		{.offset = 8,
+		 . length = 8}}
 };
 
-static struct nand_oobinfo nand_oob_64 = {
-	.useecc = MTD_NANDECC_AUTOPLACE,
+static struct nand_ecclayout nand_oob_64 = {
 	.eccbytes = 24,
 	.eccpos = {
-		40, 41, 42, 43, 44, 45, 46, 47,
-		48, 49, 50, 51, 52, 53, 54, 55,
-		56, 57, 58, 59, 60, 61, 62, 63},
-	.oobfree = { {2, 38} }
+		   40, 41, 42, 43, 44, 45, 46, 47,
+		   48, 49, 50, 51, 52, 53, 54, 55,
+		   56, 57, 58, 59, 60, 61, 62, 63},
+	.oobfree = {
+		{.offset = 2,
+		 .length = 38}}
 };
 
-static struct nand_oobinfo nand_oob_128 = {
-	.useecc = MTD_NANDECC_AUTOPLACE,
+static struct nand_ecclayout nand_oob_128 = {
 	.eccbytes = 48,
 	.eccpos = {
-		80,  81,  82,  83,  84,  85,  86,  87,
-		88,  89,  90,  91,  92,  93,  94,  95,
-		96,  97,  98,  99, 100, 101, 102, 103,
-		104, 105, 106, 107, 108, 109, 110, 111,
-		112, 113, 114, 115, 116, 117, 118, 119,
-		120, 121, 122, 123, 124, 125, 126, 127},
-	.oobfree = { {2, 78} }
+		    80,  81,  82,  83,  84,  85,  86,  87,
+		    88,  89,  90,  91,  92,  93,  94,  95,
+		    96,  97,  98,  99, 100, 101, 102, 103,
+		   104, 105, 106, 107, 108, 109, 110, 111,
+		   112, 113, 114, 115, 116, 117, 118, 119,
+		   120, 121, 122, 123, 124, 125, 126, 127},
+	.oobfree = {
+		{.offset = 2,
+		 .length = 78}}
 };
 
-/* This is used for padding purposes in nand_write_oob */
-static u_char *ffchars;
+
+static int nand_get_device(struct nand_chip *chip, struct mtd_info *mtd,
+			   int new_state);
+
+static int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
+			     struct mtd_oob_ops *ops);
+
+static int nand_wait(struct mtd_info *mtd, struct nand_chip *this);
 
 /*
- * NAND low-level MTD interface functions
+ * For devices which display every fart in the system on a separate LED. Is
+ * compiled away when LED support is disabled.
  */
-static void nand_write_buf(struct mtd_info *mtd, const u_char *buf, int len);
-static void nand_read_buf(struct mtd_info *mtd, u_char *buf, int len);
-static int nand_verify_buf(struct mtd_info *mtd, const u_char *buf, int len);
-
-static int nand_read (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf);
-static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
-			  size_t * retlen, u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel);
-static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf);
-static int nand_write (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf);
-static int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
-			   size_t * retlen, const u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel);
-static int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char *buf);
 /* XXX U-BOOT XXX */
 #if 0
-static int nand_writev (struct mtd_info *mtd, const struct kvec *vecs,
-			unsigned long count, loff_t to, size_t * retlen);
-static int nand_writev_ecc (struct mtd_info *mtd, const struct kvec *vecs,
-			unsigned long count, loff_t to, size_t * retlen, u_char *eccbuf, struct nand_oobinfo *oobsel);
-#endif
-static int nand_erase (struct mtd_info *mtd, struct erase_info *instr);
-static void nand_sync (struct mtd_info *mtd);
-
-/* Some internal functions */
-static int nand_write_page (struct mtd_info *mtd, struct nand_chip *this, int page, u_char *oob_buf,
-		struct nand_oobinfo *oobsel, int mode);
-#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
-static int nand_verify_pages (struct mtd_info *mtd, struct nand_chip *this, int page, int numpages,
-	u_char *oob_buf, struct nand_oobinfo *oobsel, int chipnr, int oobmode);
-#else
-#define nand_verify_pages(...) (0)
+DEFINE_LED_TRIGGER(nand_led_trigger);
 #endif
 
-static void nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int new_state);
-
 /**
  * nand_release_device - [GENERIC] release chip
  * @mtd:	MTD device structure
@@ -174,33 +160,25 @@ static void nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int n
  */
 /* XXX U-BOOT XXX */
 #if 0
-static void nand_release_device (struct mtd_info *mtd)
+static void nand_release_device(struct mtd_info *mtd)
 {
-	struct nand_chip *this = mtd->priv;
+	struct nand_chip *chip = mtd->priv;
 
 	/* De-select the NAND device */
-	this->select_chip(mtd, -1);
-	/* Do we have a hardware controller ? */
-	if (this->controller) {
-		spin_lock(&this->controller->lock);
-		this->controller->active = NULL;
-		spin_unlock(&this->controller->lock);
-	}
-	/* Release the chip */
-	spin_lock (&this->chip_lock);
-	this->state = FL_READY;
-	wake_up (&this->wq);
-	spin_unlock (&this->chip_lock);
+	chip->select_chip(mtd, -1);
+
+	/* Release the controller and the chip */
+	spin_lock(&chip->controller->lock);
+	chip->controller->active = NULL;
+	chip->state = FL_READY;
+	wake_up(&chip->controller->wq);
+	spin_unlock(&chip->controller->lock);
 }
 #else
 static void nand_release_device (struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
 	this->select_chip(mtd, -1);	/* De-select the NAND device */
-	if (ffchars) {
-		kfree(ffchars);
-		ffchars = NULL;
-	}
 }
 #endif
 
@@ -210,23 +188,10 @@ static void nand_release_device (struct mtd_info *mtd)
  *
  * Default read function for 8bit buswith
  */
-static u_char nand_read_byte(struct mtd_info *mtd)
+static uint8_t nand_read_byte(struct mtd_info *mtd)
 {
-	struct nand_chip *this = mtd->priv;
-	return readb(this->IO_ADDR_R);
-}
-
-/**
- * nand_write_byte - [DEFAULT] write one byte to the chip
- * @mtd:	MTD device structure
- * @byte:	pointer to data byte to write
- *
- * Default write function for 8it buswith
- */
-static void nand_write_byte(struct mtd_info *mtd, u_char byte)
-{
-	struct nand_chip *this = mtd->priv;
-	writeb(byte, this->IO_ADDR_W);
+	struct nand_chip *chip = mtd->priv;
+	return readb(chip->IO_ADDR_R);
 }
 
 /**
@@ -236,24 +201,10 @@ static void nand_write_byte(struct mtd_info *mtd, u_char byte)
  * Default read function for 16bit buswith with
  * endianess conversion
  */
-static u_char nand_read_byte16(struct mtd_info *mtd)
-{
-	struct nand_chip *this = mtd->priv;
-	return (u_char) cpu_to_le16(readw(this->IO_ADDR_R));
-}
-
-/**
- * nand_write_byte16 - [DEFAULT] write one byte endianess aware to the chip
- * @mtd:	MTD device structure
- * @byte:	pointer to data byte to write
- *
- * Default write function for 16bit buswith with
- * endianess conversion
- */
-static void nand_write_byte16(struct mtd_info *mtd, u_char byte)
+static uint8_t nand_read_byte16(struct mtd_info *mtd)
 {
-	struct nand_chip *this = mtd->priv;
-	writew(le16_to_cpu((u16) byte), this->IO_ADDR_W);
+	struct nand_chip *chip = mtd->priv;
+	return (uint8_t) cpu_to_le16(readw(chip->IO_ADDR_R));
 }
 
 /**
@@ -265,40 +216,26 @@ static void nand_write_byte16(struct mtd_info *mtd, u_char byte)
  */
 static u16 nand_read_word(struct mtd_info *mtd)
 {
-	struct nand_chip *this = mtd->priv;
-	return readw(this->IO_ADDR_R);
-}
-
-/**
- * nand_write_word - [DEFAULT] write one word to the chip
- * @mtd:	MTD device structure
- * @word:	data word to write
- *
- * Default write function for 16bit buswith without
- * endianess conversion
- */
-static void nand_write_word(struct mtd_info *mtd, u16 word)
-{
-	struct nand_chip *this = mtd->priv;
-	writew(word, this->IO_ADDR_W);
+	struct nand_chip *chip = mtd->priv;
+	return readw(chip->IO_ADDR_R);
 }
 
 /**
  * nand_select_chip - [DEFAULT] control CE line
  * @mtd:	MTD device structure
- * @chip:	chipnumber to select, -1 for deselect
+ * @chipnr:	chipnumber to select, -1 for deselect
  *
  * Default select function for 1 chip devices.
  */
-static void nand_select_chip(struct mtd_info *mtd, int chip)
+static void nand_select_chip(struct mtd_info *mtd, int chipnr)
 {
-	struct nand_chip *this = mtd->priv;
-	switch(chip) {
+	struct nand_chip *chip = mtd->priv;
+
+	switch (chipnr) {
 	case -1:
-		this->hwcontrol(mtd, NAND_CTL_CLRNCE);
+		chip->cmd_ctrl(mtd, NAND_CMD_NONE, 0 | NAND_CTRL_CHANGE);
 		break;
 	case 0:
-		this->hwcontrol(mtd, NAND_CTL_SETNCE);
 		break;
 
 	default:
@@ -314,13 +251,13 @@ static void nand_select_chip(struct mtd_info *mtd, int chip)
  *
  * Default write function for 8bit buswith
  */
-static void nand_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
+static void nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
 {
 	int i;
-	struct nand_chip *this = mtd->priv;
+	struct nand_chip *chip = mtd->priv;
 
-	for (i=0; i<len; i++)
-		writeb(buf[i], this->IO_ADDR_W);
+	for (i = 0; i < len; i++)
+		writeb(buf[i], chip->IO_ADDR_W);
 }
 
 /**
@@ -331,13 +268,13 @@ static void nand_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
  *
  * Default read function for 8bit buswith
  */
-static void nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+static void nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
 {
 	int i;
-	struct nand_chip *this = mtd->priv;
+	struct nand_chip *chip = mtd->priv;
 
-	for (i=0; i<len; i++)
-		buf[i] = readb(this->IO_ADDR_R);
+	for (i = 0; i < len; i++)
+		buf[i] = readb(chip->IO_ADDR_R);
 }
 
 /**
@@ -348,15 +285,14 @@ static void nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
  *
  * Default verify function for 8bit buswith
  */
-static int nand_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)
+static int nand_verify_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
 {
 	int i;
-	struct nand_chip *this = mtd->priv;
+	struct nand_chip *chip = mtd->priv;
 
-	for (i=0; i<len; i++)
-		if (buf[i] != readb(this->IO_ADDR_R))
+	for (i = 0; i < len; i++)
+		if (buf[i] != readb(chip->IO_ADDR_R))
 			return -EFAULT;
-
 	return 0;
 }
 
@@ -368,15 +304,15 @@ static int nand_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)
  *
  * Default write function for 16bit buswith
  */
-static void nand_write_buf16(struct mtd_info *mtd, const u_char *buf, int len)
+static void nand_write_buf16(struct mtd_info *mtd, const uint8_t *buf, int len)
 {
 	int i;
-	struct nand_chip *this = mtd->priv;
+	struct nand_chip *chip = mtd->priv;
 	u16 *p = (u16 *) buf;
 	len >>= 1;
 
-	for (i=0; i<len; i++)
-		writew(p[i], this->IO_ADDR_W);
+	for (i = 0; i < len; i++)
+		writew(p[i], chip->IO_ADDR_W);
 
 }
 
@@ -388,15 +324,15 @@ static void nand_write_buf16(struct mtd_info *mtd, const u_char *buf, int len)
  *
  * Default read function for 16bit buswith
  */
-static void nand_read_buf16(struct mtd_info *mtd, u_char *buf, int len)
+static void nand_read_buf16(struct mtd_info *mtd, uint8_t *buf, int len)
 {
 	int i;
-	struct nand_chip *this = mtd->priv;
+	struct nand_chip *chip = mtd->priv;
 	u16 *p = (u16 *) buf;
 	len >>= 1;
 
-	for (i=0; i<len; i++)
-		p[i] = readw(this->IO_ADDR_R);
+	for (i = 0; i < len; i++)
+		p[i] = readw(chip->IO_ADDR_R);
 }
 
 /**
@@ -407,15 +343,15 @@ static void nand_read_buf16(struct mtd_info *mtd, u_char *buf, int len)
  *
  * Default verify function for 16bit buswith
  */
-static int nand_verify_buf16(struct mtd_info *mtd, const u_char *buf, int len)
+static int nand_verify_buf16(struct mtd_info *mtd, const uint8_t *buf, int len)
 {
 	int i;
-	struct nand_chip *this = mtd->priv;
+	struct nand_chip *chip = mtd->priv;
 	u16 *p = (u16 *) buf;
 	len >>= 1;
 
-	for (i=0; i<len; i++)
-		if (p[i] != readw(this->IO_ADDR_R))
+	for (i = 0; i < len; i++)
+		if (p[i] != readw(chip->IO_ADDR_R))
 			return -EFAULT;
 
 	return 0;
@@ -432,38 +368,36 @@ static int nand_verify_buf16(struct mtd_info *mtd, const u_char *buf, int len)
 static int nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
 {
 	int page, chipnr, res = 0;
-	struct nand_chip *this = mtd->priv;
+	struct nand_chip *chip = mtd->priv;
 	u16 bad;
 
-	page = (int)(ofs >> this->page_shift) & this->pagemask;
+	page = (int)(ofs >> chip->page_shift) & chip->pagemask;
 
 	if (getchip) {
-		chipnr = (int)(ofs >> this->chip_shift);
+		chipnr = (int)(ofs >> chip->chip_shift);
 
-		/* Grab the lock and see if the device is available */
-		nand_get_device (this, mtd, FL_READING);
+		nand_get_device(chip, mtd, FL_READING);
 
 		/* Select the NAND device */
-		this->select_chip(mtd, chipnr);
+		chip->select_chip(mtd, chipnr);
 	}
 
-	if (this->options & NAND_BUSWIDTH_16) {
-		this->cmdfunc (mtd, NAND_CMD_READOOB, this->badblockpos & 0xFE, page);
-		bad = cpu_to_le16(this->read_word(mtd));
-		if (this->badblockpos & 0x1)
-			bad >>= 1;
+	if (chip->options & NAND_BUSWIDTH_16) {
+		chip->cmdfunc(mtd, NAND_CMD_READOOB, chip->badblockpos & 0xFE,
+			      page);
+		bad = cpu_to_le16(chip->read_word(mtd));
+		if (chip->badblockpos & 0x1)
+			bad >>= 8;
 		if ((bad & 0xFF) != 0xff)
 			res = 1;
 	} else {
-		this->cmdfunc (mtd, NAND_CMD_READOOB, this->badblockpos, page);
-		if (this->read_byte(mtd) != 0xff)
+		chip->cmdfunc(mtd, NAND_CMD_READOOB, chip->badblockpos, page);
+		if (chip->read_byte(mtd) != 0xff)
 			res = 1;
 	}
 
-	if (getchip) {
-		/* Deselect and wake up anyone waiting on the device */
+	if (getchip)
 		nand_release_device(mtd);
-	}
 
 	return res;
 }
@@ -478,22 +412,36 @@ static int nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
 */
 static int nand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
 {
-	struct nand_chip *this = mtd->priv;
-	u_char buf[2] = {0, 0};
-	size_t	retlen;
-	int block;
+	struct nand_chip *chip = mtd->priv;
+	uint8_t buf[2] = { 0, 0 };
+	int block, ret;
 
 	/* Get block number */
-	block = ((int) ofs) >> this->bbt_erase_shift;
-	this->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
+	block = (int)(ofs >> chip->bbt_erase_shift);
+	if (chip->bbt)
+		chip->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
 
 	/* Do we have a flash based bad block table ? */
-	if (this->options & NAND_USE_FLASH_BBT)
-		return nand_update_bbt (mtd, ofs);
+	if (chip->options & NAND_USE_FLASH_BBT)
+		ret = nand_update_bbt(mtd, ofs);
+	else {
+		/* We write two bytes, so we dont have to mess with 16 bit
+		 * access
+		 */
+		nand_get_device(chip, mtd, FL_WRITING);
+		ofs += mtd->oobsize;
+		chip->ops.len = chip->ops.ooblen = 2;
+		chip->ops.datbuf = NULL;
+		chip->ops.oobbuf = buf;
+		chip->ops.ooboffs = chip->badblockpos & ~0x01;
+
+		ret = nand_do_write_oob(mtd, ofs, &chip->ops);
+		nand_release_device(mtd);
+	}
+	if (!ret)
+		mtd->ecc_stats.badblocks++;
 
-	/* We write two bytes, so we dont have to mess with 16 bit access */
-	ofs += mtd->oobsize + (this->badblockpos & ~0x01);
-	return nand_write_oob (mtd, ofs , 2, &retlen, buf);
+	return ret;
 }
 
 /**
@@ -503,12 +451,12 @@ static int nand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
  *
  * The function expects, that the device is already selected
  */
-static int nand_check_wp (struct mtd_info *mtd)
+static int nand_check_wp(struct mtd_info *mtd)
 {
-	struct nand_chip *this = mtd->priv;
+	struct nand_chip *chip = mtd->priv;
 	/* Check the WP bit */
-	this->cmdfunc (mtd, NAND_CMD_STATUS, -1, -1);
-	return (this->read_byte(mtd) & 0x80) ? 0 : 1;
+	chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
+	return (chip->read_byte(mtd) & NAND_STATUS_WP) ? 0 : 1;
 }
 
 /**
@@ -521,16 +469,60 @@ static int nand_check_wp (struct mtd_info *mtd)
  * Check, if the block is bad. Either by reading the bad block table or
  * calling of the scan function.
  */
-static int nand_block_checkbad (struct mtd_info *mtd, loff_t ofs, int getchip, int allowbbt)
+static int nand_block_checkbad(struct mtd_info *mtd, loff_t ofs, int getchip,
+			       int allowbbt)
 {
-	struct nand_chip *this = mtd->priv;
+	struct nand_chip *chip = mtd->priv;
+
+	if (!(chip->options & NAND_BBT_SCANNED)) {
+		chip->options |= NAND_BBT_SCANNED;
+		chip->scan_bbt(mtd);
+	}
 
-	if (!this->bbt)
-		return this->block_bad(mtd, ofs, getchip);
+	if (!chip->bbt)
+		return chip->block_bad(mtd, ofs, getchip);
 
 	/* Return info from the table */
-	return nand_isbad_bbt (mtd, ofs, allowbbt);
+	return nand_isbad_bbt(mtd, ofs, allowbbt);
+}
+
+/*
+ * Wait for the ready pin, after a command
+ * The timeout is catched later.
+ */
+/* XXX U-BOOT XXX */
+#if 0
+void nand_wait_ready(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	unsigned long timeo = jiffies + 2;
+
+	led_trigger_event(nand_led_trigger, LED_FULL);
+	/* wait until command is processed or timeout occures */
+	do {
+		if (chip->dev_ready(mtd))
+			break;
+		touch_softlockup_watchdog();
+	} while (time_before(jiffies, timeo));
+	led_trigger_event(nand_led_trigger, LED_OFF);
+}
+EXPORT_SYMBOL_GPL(nand_wait_ready);
+#else
+void nand_wait_ready(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	u32 timeo = ((u32)CONFIG_SYS_HZ * 20) / 1000;
+
+	reset_timer();
+
+	/* wait until command is processed or timeout occures */
+	while (get_timer(0) < timeo) {
+		if (chip->dev_ready)
+			if (chip->dev_ready(mtd))
+				break;
+	}
 }
+#endif
 
 /**
  * nand_command - [DEFAULT] Send command to NAND device
@@ -542,21 +534,22 @@ static int nand_block_checkbad (struct mtd_info *mtd, loff_t ofs, int getchip, i
  * Send command to NAND device. This function is used for small page
  * devices (256/512 Bytes per page)
  */
-static void nand_command (struct mtd_info *mtd, unsigned command, int column, int page_addr)
+static void nand_command(struct mtd_info *mtd, unsigned int command,
+			 int column, int page_addr)
 {
-	register struct nand_chip *this = mtd->priv;
+	register struct nand_chip *chip = mtd->priv;
+	int ctrl = NAND_CTRL_CLE | NAND_CTRL_CHANGE;
+	uint32_t rst_sts_cnt = CONFIG_SYS_NAND_RESET_CNT;
 
-	/* Begin command latch cycle */
-	this->hwcontrol(mtd, NAND_CTL_SETCLE);
 	/*
 	 * Write out the command to the device.
 	 */
 	if (command == NAND_CMD_SEQIN) {
 		int readcmd;
 
-		if (column >= mtd->oobblock) {
+		if (column >= mtd->writesize) {
 			/* OOB area */
-			column -= mtd->oobblock;
+			column -= mtd->writesize;
 			readcmd = NAND_CMD_READOOB;
 		} else if (column < 256) {
 			/* First 256 bytes --> READ0 */
@@ -565,38 +558,37 @@ static void nand_command (struct mtd_info *mtd, unsigned command, int column, in
 			column -= 256;
 			readcmd = NAND_CMD_READ1;
 		}
-		this->write_byte(mtd, readcmd);
+		chip->cmd_ctrl(mtd, readcmd, ctrl);
+		ctrl &= ~NAND_CTRL_CHANGE;
 	}
-	this->write_byte(mtd, command);
+	chip->cmd_ctrl(mtd, command, ctrl);
 
-	/* Set ALE and clear CLE to start address cycle */
-	this->hwcontrol(mtd, NAND_CTL_CLRCLE);
-
-	if (column != -1 || page_addr != -1) {
-		this->hwcontrol(mtd, NAND_CTL_SETALE);
-
-		/* Serially input address */
-		if (column != -1) {
-			/* Adjust columns for 16 bit buswidth */
-			if (this->options & NAND_BUSWIDTH_16)
-				column >>= 1;
-			this->write_byte(mtd, column);
-		}
-		if (page_addr != -1) {
-			this->write_byte(mtd, (unsigned char) (page_addr & 0xff));
-			this->write_byte(mtd, (unsigned char) ((page_addr >> 8) & 0xff));
-			/* One more address cycle for devices > 32MiB */
-			if (this->chipsize > (32 << 20))
-				this->write_byte(mtd, (unsigned char) ((page_addr >> 16) & 0x0f));
-		}
-		/* Latch in address */
-		this->hwcontrol(mtd, NAND_CTL_CLRALE);
+	/*
+	 * Address cycle, when necessary
+	 */
+	ctrl = NAND_CTRL_ALE | NAND_CTRL_CHANGE;
+	/* Serially input address */
+	if (column != -1) {
+		/* Adjust columns for 16 bit buswidth */
+		if (chip->options & NAND_BUSWIDTH_16)
+			column >>= 1;
+		chip->cmd_ctrl(mtd, column, ctrl);
+		ctrl &= ~NAND_CTRL_CHANGE;
+	}
+	if (page_addr != -1) {
+		chip->cmd_ctrl(mtd, page_addr, ctrl);
+		ctrl &= ~NAND_CTRL_CHANGE;
+		chip->cmd_ctrl(mtd, page_addr >> 8, ctrl);
+		/* One more address cycle for devices > 32MiB */
+		if (chip->chipsize > (32 << 20))
+			chip->cmd_ctrl(mtd, page_addr >> 16, ctrl);
 	}
+	chip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
 
 	/*
 	 * program and erase have their own busy handlers
 	 * status and sequential in needs no delay
-	*/
+	 */
 	switch (command) {
 
 	case NAND_CMD_PAGEPROG:
@@ -607,32 +599,33 @@ static void nand_command (struct mtd_info *mtd, unsigned command, int column, in
 		return;
 
 	case NAND_CMD_RESET:
-		if (this->dev_ready)
+		if (chip->dev_ready)
 			break;
-		udelay(this->chip_delay);
-		this->hwcontrol(mtd, NAND_CTL_SETCLE);
-		this->write_byte(mtd, NAND_CMD_STATUS);
-		this->hwcontrol(mtd, NAND_CTL_CLRCLE);
-		while ( !(this->read_byte(mtd) & 0x40));
+		udelay(chip->chip_delay);
+		chip->cmd_ctrl(mtd, NAND_CMD_STATUS,
+			       NAND_CTRL_CLE | NAND_CTRL_CHANGE);
+		chip->cmd_ctrl(mtd,
+			       NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
+		while (!(chip->read_byte(mtd) & NAND_STATUS_READY) &&
+			(rst_sts_cnt--));
 		return;
 
-	/* This applies to read commands */
+		/* This applies to read commands */
 	default:
 		/*
 		 * If we don't have access to the busy pin, we apply the given
 		 * command delay
-		*/
-		if (!this->dev_ready) {
-			udelay (this->chip_delay);
+		 */
+		if (!chip->dev_ready) {
+			udelay(chip->chip_delay);
 			return;
 		}
 	}
-
 	/* Apply this short delay always to ensure that we do wait tWB in
 	 * any case on any machine. */
-	ndelay (100);
-	/* wait until command is processed */
-	while (!this->dev_ready(mtd));
+	ndelay(100);
+
+	nand_wait_ready(mtd);
 }
 
 /**
@@ -642,55 +635,54 @@ static void nand_command (struct mtd_info *mtd, unsigned command, int column, in
  * @column:	the column address for this command, -1 if none
  * @page_addr:	the page address for this command, -1 if none
  *
- * Send command to NAND device. This is the version for the new large page devices
- * We dont have the seperate regions as we have in the small page devices.
- * We must emulate NAND_CMD_READOOB to keep the code compatible.
- *
+ * Send command to NAND device. This is the version for the new large page
+ * devices We dont have the separate regions as we have in the small page
+ * devices.  We must emulate NAND_CMD_READOOB to keep the code compatible.
  */
-static void nand_command_lp (struct mtd_info *mtd, unsigned command, int column, int page_addr)
+static void nand_command_lp(struct mtd_info *mtd, unsigned int command,
+			    int column, int page_addr)
 {
-	register struct nand_chip *this = mtd->priv;
+	register struct nand_chip *chip = mtd->priv;
+	uint32_t rst_sts_cnt = CONFIG_SYS_NAND_RESET_CNT;
 
 	/* Emulate NAND_CMD_READOOB */
 	if (command == NAND_CMD_READOOB) {
-		column += mtd->oobblock;
+		column += mtd->writesize;
 		command = NAND_CMD_READ0;
 	}
 
-
-	/* Begin command latch cycle */
-	this->hwcontrol(mtd, NAND_CTL_SETCLE);
-	/* Write out the command to the device. */
-	this->write_byte(mtd, command);
-	/* End command latch cycle */
-	this->hwcontrol(mtd, NAND_CTL_CLRCLE);
+	/* Command latch cycle */
+	chip->cmd_ctrl(mtd, command & 0xff,
+		       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
 
 	if (column != -1 || page_addr != -1) {
-		this->hwcontrol(mtd, NAND_CTL_SETALE);
+		int ctrl = NAND_CTRL_CHANGE | NAND_NCE | NAND_ALE;
 
 		/* Serially input address */
 		if (column != -1) {
 			/* Adjust columns for 16 bit buswidth */
-			if (this->options & NAND_BUSWIDTH_16)
+			if (chip->options & NAND_BUSWIDTH_16)
 				column >>= 1;
-			this->write_byte(mtd, column & 0xff);
-			this->write_byte(mtd, column >> 8);
+			chip->cmd_ctrl(mtd, column, ctrl);
+			ctrl &= ~NAND_CTRL_CHANGE;
+			chip->cmd_ctrl(mtd, column >> 8, ctrl);
 		}
 		if (page_addr != -1) {
-			this->write_byte(mtd, (unsigned char) (page_addr & 0xff));
-			this->write_byte(mtd, (unsigned char) ((page_addr >> 8) & 0xff));
+			chip->cmd_ctrl(mtd, page_addr, ctrl);
+			chip->cmd_ctrl(mtd, page_addr >> 8,
+				       NAND_NCE | NAND_ALE);
 			/* One more address cycle for devices > 128MiB */
-			if (this->chipsize > (128 << 20))
-				this->write_byte(mtd, (unsigned char) ((page_addr >> 16) & 0xff));
+			if (chip->chipsize > (128 << 20))
+				chip->cmd_ctrl(mtd, page_addr >> 16,
+					       NAND_NCE | NAND_ALE);
 		}
-		/* Latch in address */
-		this->hwcontrol(mtd, NAND_CTL_CLRALE);
 	}
+	chip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
 
 	/*
 	 * program and erase have their own busy handlers
-	 * status and sequential in needs no delay
-	*/
+	 * status, sequential in, and deplete1 need no delay
+	 */
 	switch (command) {
 
 	case NAND_CMD_CACHEDPROG:
@@ -698,51 +690,70 @@ static void nand_command_lp (struct mtd_info *mtd, unsigned command, int column,
 	case NAND_CMD_ERASE1:
 	case NAND_CMD_ERASE2:
 	case NAND_CMD_SEQIN:
+	case NAND_CMD_RNDIN:
 	case NAND_CMD_STATUS:
+	case NAND_CMD_DEPLETE1:
 		return;
 
+		/*
+		 * read error status commands require only a short delay
+		 */
+	case NAND_CMD_STATUS_ERROR:
+	case NAND_CMD_STATUS_ERROR0:
+	case NAND_CMD_STATUS_ERROR1:
+	case NAND_CMD_STATUS_ERROR2:
+	case NAND_CMD_STATUS_ERROR3:
+		udelay(chip->chip_delay);
+		return;
 
 	case NAND_CMD_RESET:
-		if (this->dev_ready)
+		if (chip->dev_ready)
 			break;
-		udelay(this->chip_delay);
-		this->hwcontrol(mtd, NAND_CTL_SETCLE);
-		this->write_byte(mtd, NAND_CMD_STATUS);
-		this->hwcontrol(mtd, NAND_CTL_CLRCLE);
-		while ( !(this->read_byte(mtd) & 0x40));
+		udelay(chip->chip_delay);
+		chip->cmd_ctrl(mtd, NAND_CMD_STATUS,
+			       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
+		chip->cmd_ctrl(mtd, NAND_CMD_NONE,
+			       NAND_NCE | NAND_CTRL_CHANGE);
+		while (!(chip->read_byte(mtd) & NAND_STATUS_READY) &&
+			(rst_sts_cnt--));
+		return;
+
+	case NAND_CMD_RNDOUT:
+		/* No ready / busy check necessary */
+		chip->cmd_ctrl(mtd, NAND_CMD_RNDOUTSTART,
+			       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
+		chip->cmd_ctrl(mtd, NAND_CMD_NONE,
+			       NAND_NCE | NAND_CTRL_CHANGE);
 		return;
 
 	case NAND_CMD_READ0:
-		/* Begin command latch cycle */
-		this->hwcontrol(mtd, NAND_CTL_SETCLE);
-		/* Write out the start read command */
-		this->write_byte(mtd, NAND_CMD_READSTART);
-		/* End command latch cycle */
-		this->hwcontrol(mtd, NAND_CTL_CLRCLE);
-		/* Fall through into ready check */
-
-	/* This applies to read commands */
+		chip->cmd_ctrl(mtd, NAND_CMD_READSTART,
+			       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
+		chip->cmd_ctrl(mtd, NAND_CMD_NONE,
+			       NAND_NCE | NAND_CTRL_CHANGE);
+
+		/* This applies to read commands */
 	default:
 		/*
 		 * If we don't have access to the busy pin, we apply the given
 		 * command delay
-		*/
-		if (!this->dev_ready) {
-			udelay (this->chip_delay);
+		 */
+		if (!chip->dev_ready) {
+			udelay(chip->chip_delay);
 			return;
 		}
 	}
 
 	/* Apply this short delay always to ensure that we do wait tWB in
 	 * any case on any machine. */
-	ndelay (100);
-	/* wait until command is processed */
-	while (!this->dev_ready(mtd));
+	ndelay(100);
+
+	nand_wait_ready(mtd);
 }
 
 /**
  * nand_get_device - [GENERIC] Get chip for selected access
- * @this:	the nand chip descriptor
+ * @chip:	the nand chip descriptor
  * @mtd:	MTD device structure
  * @new_state:	the state which is requested
  *
@@ -750,105 +761,102 @@ static void nand_command_lp (struct mtd_info *mtd, unsigned command, int column,
  */
 /* XXX U-BOOT XXX */
 #if 0
-static void nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int new_state)
+static int
+nand_get_device(struct nand_chip *chip, struct mtd_info *mtd, int new_state)
 {
-	struct nand_chip *active = this;
+	spinlock_t *lock = &chip->controller->lock;
+	wait_queue_head_t *wq = &chip->controller->wq;
+	DECLARE_WAITQUEUE(wait, current);
+ retry:
+	spin_lock(lock);
 
-	DECLARE_WAITQUEUE (wait, current);
-
-	/*
-	 * Grab the lock and see if the device is available
-	*/
-retry:
 	/* Hardware controller shared among independend devices */
-	if (this->controller) {
-		spin_lock (&this->controller->lock);
-		if (this->controller->active)
-			active = this->controller->active;
-		else
-			this->controller->active = this;
-		spin_unlock (&this->controller->lock);
-	}
+	/* Hardware controller shared among independend devices */
+	if (!chip->controller->active)
+		chip->controller->active = chip;
 
-	if (active == this) {
-		spin_lock (&this->chip_lock);
-		if (this->state == FL_READY) {
-			this->state = new_state;
-			spin_unlock (&this->chip_lock);
-			return;
-		}
+	if (chip->controller->active == chip && chip->state == FL_READY) {
+		chip->state = new_state;
+		spin_unlock(lock);
+		return 0;
+	}
+	if (new_state == FL_PM_SUSPENDED) {
+		spin_unlock(lock);
+		return (chip->state == FL_PM_SUSPENDED) ? 0 : -EAGAIN;
 	}
-	set_current_state (TASK_UNINTERRUPTIBLE);
-	add_wait_queue (&active->wq, &wait);
-	spin_unlock (&active->chip_lock);
-	schedule ();
-	remove_wait_queue (&active->wq, &wait);
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	add_wait_queue(wq, &wait);
+	spin_unlock(lock);
+	schedule();
+	remove_wait_queue(wq, &wait);
 	goto retry;
 }
 #else
-static void nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int new_state) {}
+static int nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int new_state)
+{
+	this->state = new_state;
+	return 0;
+}
 #endif
 
 /**
  * nand_wait - [DEFAULT]  wait until the command is done
  * @mtd:	MTD device structure
- * @this:	NAND chip structure
- * @state:	state to select the max. timeout value
+ * @chip:	NAND chip structure
  *
  * Wait for command done. This applies to erase and program only
  * Erase can take up to 400ms and program up to 20ms according to
  * general NAND and SmartMedia specs
- *
-*/
+ */
 /* XXX U-BOOT XXX */
 #if 0
-static int nand_wait(struct mtd_info *mtd, struct nand_chip *this, int state)
+static int nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
 {
-	unsigned long	timeo = jiffies;
-	int	status;
+
+	unsigned long timeo = jiffies;
+	int status, state = chip->state;
 
 	if (state == FL_ERASING)
-		 timeo += (HZ * 400) / 1000;
+		timeo += (HZ * 400) / 1000;
 	else
-		 timeo += (HZ * 20) / 1000;
+		timeo += (HZ * 20) / 1000;
+
+	led_trigger_event(nand_led_trigger, LED_FULL);
 
 	/* Apply this short delay always to ensure that we do wait tWB in
 	 * any case on any machine. */
-	ndelay (100);
+	ndelay(100);
 
-	if ((state == FL_ERASING) && (this->options & NAND_IS_AND))
-		this->cmdfunc (mtd, NAND_CMD_STATUS_MULTI, -1, -1);
+	if ((state == FL_ERASING) && (chip->options & NAND_IS_AND))
+		chip->cmdfunc(mtd, NAND_CMD_STATUS_MULTI, -1, -1);
 	else
-		this->cmdfunc (mtd, NAND_CMD_STATUS, -1, -1);
+		chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
 
 	while (time_before(jiffies, timeo)) {
-		/* Check, if we were interrupted */
-		if (this->state != state)
-			return 0;
-
-		if (this->dev_ready) {
-			if (this->dev_ready(mtd))
+		if (chip->dev_ready) {
+			if (chip->dev_ready(mtd))
 				break;
 		} else {
-			if (this->read_byte(mtd) & NAND_STATUS_READY)
+			if (chip->read_byte(mtd) & NAND_STATUS_READY)
 				break;
 		}
-		yield ();
+		cond_resched();
 	}
-	status = (int) this->read_byte(mtd);
-	return status;
+	led_trigger_event(nand_led_trigger, LED_OFF);
 
-	return 0;
+	status = (int)chip->read_byte(mtd);
+	return status;
 }
 #else
-static int nand_wait(struct mtd_info *mtd, struct nand_chip *this, int state)
+static int nand_wait(struct mtd_info *mtd, struct nand_chip *this)
 {
 	unsigned long	timeo;
+	int state = this->state;
 
 	if (state == FL_ERASING)
-		timeo = (CFG_HZ * 400) / 1000;
+		timeo = ((unsigned long)CONFIG_SYS_HZ * 400) / 1000;
 	else
-		timeo = (CFG_HZ * 20) / 1000;
+		timeo = ((unsigned long)CONFIG_SYS_HZ * 20) / 1000;
 
 	if ((state == FL_ERASING) && (this->options & NAND_IS_AND))
 		this->cmdfunc(mtd, NAND_CMD_STATUS_MULTI, -1, -1);
@@ -881,478 +889,389 @@ static int nand_wait(struct mtd_info *mtd, struct nand_chip *this, int state)
 #endif
 
 /**
- * nand_write_page - [GENERIC] write one page
- * @mtd:	MTD device structure
- * @this:	NAND chip structure
- * @page:	startpage inside the chip, must be called with (page & this->pagemask)
- * @oob_buf:	out of band data buffer
- * @oobsel:	out of band selecttion structre
- * @cached:	1 = enable cached programming if supported by chip
- *
- * Nand_page_program function is used for write and writev !
- * This function will always program a full page of data
- * If you call it with a non page aligned buffer, you're lost :)
- *
- * Cached programming is not supported yet.
+ * nand_read_page_raw - [Intern] read raw page data without ecc
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @buf:	buffer to store read data
  */
-static int nand_write_page (struct mtd_info *mtd, struct nand_chip *this, int page,
-	u_char *oob_buf,  struct nand_oobinfo *oobsel, int cached)
+static int nand_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+			      uint8_t *buf)
 {
-	int	i, status;
-	u_char	ecc_code[NAND_MAX_OOBSIZE];
-	int	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
-	uint	*oob_config = oobsel->eccpos;
-	int	datidx = 0, eccidx = 0, eccsteps = this->eccsteps;
-	int	eccbytes = 0;
+	chip->read_buf(mtd, buf, mtd->writesize);
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+	return 0;
+}
 
-	/* FIXME: Enable cached programming */
-	cached = 0;
+/**
+ * nand_read_page_swecc - [REPLACABLE] software ecc based page read function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @buf:	buffer to store read data
+ */
+static int nand_read_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
+				uint8_t *buf)
+{
+	int i, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	uint8_t *p = buf;
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	uint8_t *ecc_code = chip->buffers->ecccode;
+	uint32_t *eccpos = chip->ecc.layout->eccpos;
 
-	/* Send command to begin auto page programming */
-	this->cmdfunc (mtd, NAND_CMD_SEQIN, 0x00, page);
+	chip->ecc.read_page_raw(mtd, chip, buf);
 
-	/* Write out complete page of data, take care of eccmode */
-	switch (eccmode) {
-	/* No ecc, write all */
-	case NAND_ECC_NONE:
-		printk (KERN_WARNING "Writing data without ECC to NAND-FLASH is not recommended\n");
-		this->write_buf(mtd, this->data_poi, mtd->oobblock);
-		break;
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
+		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
 
-	/* Software ecc 3/256, write all */
-	case NAND_ECC_SOFT:
-		for (; eccsteps; eccsteps--) {
-			this->calculate_ecc(mtd, &this->data_poi[datidx], ecc_code);
-			for (i = 0; i < 3; i++, eccidx++)
-				oob_buf[oob_config[eccidx]] = ecc_code[i];
-			datidx += this->eccsize;
-		}
-		this->write_buf(mtd, this->data_poi, mtd->oobblock);
-		break;
-	default:
-		eccbytes = this->eccbytes;
-		for (; eccsteps; eccsteps--) {
-			/* enable hardware ecc logic for write */
-			this->enable_hwecc(mtd, NAND_ECC_WRITE);
-			this->write_buf(mtd, &this->data_poi[datidx], this->eccsize);
-			this->calculate_ecc(mtd, &this->data_poi[datidx], ecc_code);
-			for (i = 0; i < eccbytes; i++, eccidx++)
-				oob_buf[oob_config[eccidx]] = ecc_code[i];
-			/* If the hardware ecc provides syndromes then
-			 * the ecc code must be written immediately after
-			 * the data bytes (words) */
-			if (this->options & NAND_HWECC_SYNDROME)
-				this->write_buf(mtd, ecc_code, eccbytes);
-			datidx += this->eccsize;
-		}
-		break;
-	}
+	for (i = 0; i < chip->ecc.total; i++)
+		ecc_code[i] = chip->oob_poi[eccpos[i]];
 
-	/* Write out OOB data */
-	if (this->options & NAND_HWECC_SYNDROME)
-		this->write_buf(mtd, &oob_buf[oobsel->eccbytes], mtd->oobsize - oobsel->eccbytes);
-	else
-		this->write_buf(mtd, oob_buf, mtd->oobsize);
-
-	/* Send command to actually program the data */
-	this->cmdfunc (mtd, cached ? NAND_CMD_CACHEDPROG : NAND_CMD_PAGEPROG, -1, -1);
-
-	if (!cached) {
-		/* call wait ready function */
-		status = this->waitfunc (mtd, this, FL_WRITING);
-		/* See if device thinks it succeeded */
-		if (status & 0x01) {
-			MTDDEBUG (MTD_DEBUG_LEVEL0,
-			          "%s: Failed write, page 0x%08x, ",
-			          __FUNCTION__, page);
-			return -EIO;
-		}
-	} else {
-		/* FIXME: Implement cached programming ! */
-		/* wait until cache is ready*/
-		/* status = this->waitfunc (mtd, this, FL_CACHEDRPG); */
+	eccsteps = chip->ecc.steps;
+	p = buf;
+
+	for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		int stat;
+
+		stat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
+		if (stat < 0)
+			mtd->ecc_stats.failed++;
+		else
+			mtd->ecc_stats.corrected += stat;
 	}
 	return 0;
 }
 
-#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
 /**
- * nand_verify_pages - [GENERIC] verify the chip contents after a write
- * @mtd:	MTD device structure
- * @this:	NAND chip structure
- * @page:	startpage inside the chip, must be called with (page & this->pagemask)
- * @numpages:	number of pages to verify
- * @oob_buf:	out of band data buffer
- * @oobsel:	out of band selecttion structre
- * @chipnr:	number of the current chip
- * @oobmode:	1 = full buffer verify, 0 = ecc only
- *
- * The NAND device assumes that it is always writing to a cleanly erased page.
- * Hence, it performs its internal write verification only on bits that
- * transitioned from 1 to 0. The device does NOT verify the whole page on a
- * byte by byte basis. It is possible that the page was not completely erased
- * or the page is becoming unusable due to wear. The read with ECC would catch
- * the error later when the ECC page check fails, but we would rather catch
- * it early in the page write stage. Better to write no data than invalid data.
+ * nand_read_subpage - [REPLACABLE] software ecc based sub-page read function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @dataofs	offset of requested data within the page
+ * @readlen	data length
+ * @buf:	buffer to store read data
  */
-static int nand_verify_pages (struct mtd_info *mtd, struct nand_chip *this, int page, int numpages,
-	u_char *oob_buf, struct nand_oobinfo *oobsel, int chipnr, int oobmode)
-{
-	int	i, j, datidx = 0, oobofs = 0, res = -EIO;
-	int	eccsteps = this->eccsteps;
-	int	hweccbytes;
-	u_char	oobdata[64];
-
-	hweccbytes = (this->options & NAND_HWECC_SYNDROME) ? (oobsel->eccbytes / eccsteps) : 0;
-
-	/* Send command to read back the first page */
-	this->cmdfunc (mtd, NAND_CMD_READ0, 0, page);
-
-	for(;;) {
-		for (j = 0; j < eccsteps; j++) {
-			/* Loop through and verify the data */
-			if (this->verify_buf(mtd, &this->data_poi[datidx], mtd->eccsize)) {
-				MTDDEBUG (MTD_DEBUG_LEVEL0, "%s: "
-				          "Failed write verify, page 0x%08x ",
-				          __FUNCTION__, page);
-				goto out;
-			}
-			datidx += mtd->eccsize;
-			/* Have we a hw generator layout ? */
-			if (!hweccbytes)
-				continue;
-			if (this->verify_buf(mtd, &this->oob_buf[oobofs], hweccbytes)) {
-				MTDDEBUG (MTD_DEBUG_LEVEL0, "%s: "
-				          "Failed write verify, page 0x%08x ",
-				          __FUNCTION__, page);
-				goto out;
-			}
-			oobofs += hweccbytes;
-		}
-
-		/* check, if we must compare all data or if we just have to
-		 * compare the ecc bytes
-		 */
-		if (oobmode) {
-			if (this->verify_buf(mtd, &oob_buf[oobofs], mtd->oobsize - hweccbytes * eccsteps)) {
-				MTDDEBUG (MTD_DEBUG_LEVEL0, "%s: "
-				          "Failed write verify, page 0x%08x ",
-				          __FUNCTION__, page);
-				goto out;
-			}
-		} else {
-			/* Read always, else autoincrement fails */
-			this->read_buf(mtd, oobdata, mtd->oobsize - hweccbytes * eccsteps);
-
-			if (oobsel->useecc != MTD_NANDECC_OFF && !hweccbytes) {
-				int ecccnt = oobsel->eccbytes;
-
-				for (i = 0; i < ecccnt; i++) {
-					int idx = oobsel->eccpos[i];
-					if (oobdata[idx] != oob_buf[oobofs + idx] ) {
-						MTDDEBUG (MTD_DEBUG_LEVEL0,
-						"%s: Failed ECC write "
-						"verify, page 0x%08x, "
-						"%6i bytes were succesful\n",
-						__FUNCTION__, page, i);
-						goto out;
-					}
-				}
-			}
+static int nand_read_subpage(struct mtd_info *mtd, struct nand_chip *chip, uint32_t data_offs, uint32_t readlen, uint8_t *bufpoi)
+{
+	int start_step, end_step, num_steps;
+	uint32_t *eccpos = chip->ecc.layout->eccpos;
+	uint8_t *p;
+	int data_col_addr, i, gaps = 0;
+	int datafrag_len, eccfrag_len, aligned_len, aligned_pos;
+	int busw = (chip->options & NAND_BUSWIDTH_16) ? 2 : 1;
+
+	/* Column address wihin the page aligned to ECC size (256bytes). */
+	start_step = data_offs / chip->ecc.size;
+	end_step = (data_offs + readlen - 1) / chip->ecc.size;
+	num_steps = end_step - start_step + 1;
+
+	/* Data size aligned to ECC ecc.size*/
+	datafrag_len = num_steps * chip->ecc.size;
+	eccfrag_len = num_steps * chip->ecc.bytes;
+
+	data_col_addr = start_step * chip->ecc.size;
+	/* If we read not a page aligned data */
+	if (data_col_addr != 0)
+		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, data_col_addr, -1);
+
+	p = bufpoi + data_col_addr;
+	chip->read_buf(mtd, p, datafrag_len);
+
+	/* Calculate  ECC */
+	for (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size)
+		chip->ecc.calculate(mtd, p, &chip->buffers->ecccalc[i]);
+
+	/* The performance is faster if to position offsets
+	   according to ecc.pos. Let make sure here that
+	   there are no gaps in ecc positions */
+	for (i = 0; i < eccfrag_len - 1; i++) {
+		if (eccpos[i + start_step * chip->ecc.bytes] + 1 !=
+			eccpos[i + start_step * chip->ecc.bytes + 1]) {
+			gaps = 1;
+			break;
 		}
-		oobofs += mtd->oobsize - hweccbytes * eccsteps;
-		page++;
-		numpages--;
-
-		/* Apply delay or wait for ready/busy pin
-		 * Do this before the AUTOINCR check, so no problems
-		 * arise if a chip which does auto increment
-		 * is marked as NOAUTOINCR by the board driver.
-		 * Do this also before returning, so the chip is
-		 * ready for the next command.
-		*/
-		if (!this->dev_ready)
-			udelay (this->chip_delay);
-		else
-			while (!this->dev_ready(mtd));
+	}
+	if (gaps) {
+		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, mtd->writesize, -1);
+		chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+	} else {
+		/* send the command to read the particular ecc bytes */
+		/* take care about buswidth alignment in read_buf */
+		aligned_pos = eccpos[start_step * chip->ecc.bytes] & ~(busw - 1);
+		aligned_len = eccfrag_len;
+		if (eccpos[start_step * chip->ecc.bytes] & (busw - 1))
+			aligned_len++;
+		if (eccpos[(start_step + num_steps) * chip->ecc.bytes] & (busw - 1))
+			aligned_len++;
+
+		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, mtd->writesize + aligned_pos, -1);
+		chip->read_buf(mtd, &chip->oob_poi[aligned_pos], aligned_len);
+	}
 
-		/* All done, return happy */
-		if (!numpages)
-			return 0;
+	for (i = 0; i < eccfrag_len; i++)
+		chip->buffers->ecccode[i] = chip->oob_poi[eccpos[i + start_step * chip->ecc.bytes]];
 
+	p = bufpoi + data_col_addr;
+	for (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size) {
+		int stat;
 
-		/* Check, if the chip supports auto page increment */
-		if (!NAND_CANAUTOINCR(this))
-			this->cmdfunc (mtd, NAND_CMD_READ0, 0x00, page);
+		stat = chip->ecc.correct(mtd, p, &chip->buffers->ecccode[i], &chip->buffers->ecccalc[i]);
+		if (stat < 0)
+			mtd->ecc_stats.failed++;
+		else
+			mtd->ecc_stats.corrected += stat;
 	}
-	/*
-	 * Terminate the read command. We come here in case of an error
-	 * So we must issue a reset command.
-	 */
-out:
-	this->cmdfunc (mtd, NAND_CMD_RESET, -1, -1);
-	return res;
-}
-#endif
-
-/**
- * nand_read - [MTD Interface] MTD compability function for nand_read_ecc
- * @mtd:	MTD device structure
- * @from:	offset to read from
- * @len:	number of bytes to read
- * @retlen:	pointer to variable to store the number of read bytes
- * @buf:	the databuffer to put data
- *
- * This function simply calls nand_read_ecc with oob buffer and oobsel = NULL
-*/
-static int nand_read (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
-{
-	return nand_read_ecc (mtd, from, len, retlen, buf, NULL, NULL);
+	return 0;
 }
 
-
 /**
- * nand_read_ecc - [MTD Interface] Read data with ECC
- * @mtd:	MTD device structure
- * @from:	offset to read from
- * @len:	number of bytes to read
- * @retlen:	pointer to variable to store the number of read bytes
- * @buf:	the databuffer to put data
- * @oob_buf:	filesystem supplied oob data buffer
- * @oobsel:	oob selection structure
+ * nand_read_page_hwecc - [REPLACABLE] hardware ecc based page read function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @buf:	buffer to store read data
  *
- * NAND read with ECC
+ * Not for syndrome calculating ecc controllers which need a special oob layout
  */
-static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
-			  size_t * retlen, u_char * buf, u_char * oob_buf, struct nand_oobinfo *oobsel)
+static int nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
+				uint8_t *buf)
 {
-	int i, j, col, realpage, page, end, ecc, chipnr, sndcmd = 1;
-	int read = 0, oob = 0, ecc_status = 0, ecc_failed = 0;
-	struct nand_chip *this = mtd->priv;
-	u_char *data_poi, *oob_data = oob_buf;
-	u_char ecc_calc[NAND_MAX_OOBSIZE];
-	u_char ecc_code[NAND_MAX_OOBSIZE];
-	int eccmode, eccsteps;
-	unsigned *oob_config;
-	int	datidx;
-	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
-	int	eccbytes;
-	int	compareecc = 1;
-	int	oobreadlen;
-
-
-	MTDDEBUG (MTD_DEBUG_LEVEL3, "nand_read_ecc: from = 0x%08x, len = %i\n",
-	          (unsigned int) from, (int) len);
-
-	/* Do not allow reads past end of device */
-	if ((from + len) > mtd->size) {
-		MTDDEBUG (MTD_DEBUG_LEVEL0,
-		          "nand_read_ecc: Attempt read beyond end of device\n");
-		*retlen = 0;
-		return -EINVAL;
+	int i, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	uint8_t *p = buf;
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	uint8_t *ecc_code = chip->buffers->ecccode;
+	uint32_t *eccpos = chip->ecc.layout->eccpos;
+
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->ecc.hwctl(mtd, NAND_ECC_READ);
+		chip->read_buf(mtd, p, eccsize);
+		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
 	}
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
 
-	/* Grab the lock and see if the device is available */
-	nand_get_device (this, mtd ,FL_READING);
+	for (i = 0; i < chip->ecc.total; i++)
+		ecc_code[i] = chip->oob_poi[eccpos[i]];
 
-	/* use userspace supplied oobinfo, if zero */
-	if (oobsel == NULL)
-		oobsel = &mtd->oobinfo;
+	eccsteps = chip->ecc.steps;
+	p = buf;
 
-	/* Autoplace of oob data ? Use the default placement scheme */
-	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE)
-		oobsel = this->autooob;
+	for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		int stat;
 
-	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
-	oob_config = oobsel->eccpos;
-
-	/* Select the NAND device */
-	chipnr = (int)(from >> this->chip_shift);
-	this->select_chip(mtd, chipnr);
-
-	/* First we calculate the starting page */
-	realpage = (int) (from >> this->page_shift);
-	page = realpage & this->pagemask;
+		stat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
+		if (stat == -1)
+			mtd->ecc_stats.failed++;
+		else
+			mtd->ecc_stats.corrected += stat;
+	}
+	return 0;
+}
 
-	/* Get raw starting column */
-	col = from & (mtd->oobblock - 1);
+/**
+ * nand_read_page_syndrome - [REPLACABLE] hardware ecc syndrom based page read
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @buf:	buffer to store read data
+ *
+ * The hw generator calculates the error syndrome automatically. Therefor
+ * we need a special oob layout and handling.
+ */
+static int nand_read_page_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
+				   uint8_t *buf)
+{
+	int i, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	uint8_t *p = buf;
+	uint8_t *oob = chip->oob_poi;
 
-	end = mtd->oobblock;
-	ecc = this->eccsize;
-	eccbytes = this->eccbytes;
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		int stat;
 
-	if ((eccmode == NAND_ECC_NONE) || (this->options & NAND_HWECC_SYNDROME))
-		compareecc = 0;
+		chip->ecc.hwctl(mtd, NAND_ECC_READ);
+		chip->read_buf(mtd, p, eccsize);
 
-	oobreadlen = mtd->oobsize;
-	if (this->options & NAND_HWECC_SYNDROME)
-		oobreadlen -= oobsel->eccbytes;
+		if (chip->ecc.prepad) {
+			chip->read_buf(mtd, oob, chip->ecc.prepad);
+			oob += chip->ecc.prepad;
+		}
 
-	/* Loop until all data read */
-	while (read < len) {
+		chip->ecc.hwctl(mtd, NAND_ECC_READSYN);
+		chip->read_buf(mtd, oob, eccbytes);
+		stat = chip->ecc.correct(mtd, p, oob, NULL);
 
-		int aligned = (!col && (len - read) >= end);
-		/*
-		 * If the read is not page aligned, we have to read into data buffer
-		 * due to ecc, else we read into return buffer direct
-		 */
-		if (aligned)
-			data_poi = &buf[read];
+		if (stat < 0)
+			mtd->ecc_stats.failed++;
 		else
-			data_poi = this->data_buf;
+			mtd->ecc_stats.corrected += stat;
 
-		/* Check, if we have this page in the buffer
-		 *
-		 * FIXME: Make it work when we must provide oob data too,
-		 * check the usage of data_buf oob field
-		 */
-		if (realpage == this->pagebuf && !oob_buf) {
-			/* aligned read ? */
-			if (aligned)
-				memcpy (data_poi, this->data_buf, end);
-			goto readdata;
-		}
+		oob += eccbytes;
 
-		/* Check, if we must send the read command */
-		if (sndcmd) {
-			this->cmdfunc (mtd, NAND_CMD_READ0, 0x00, page);
-			sndcmd = 0;
+		if (chip->ecc.postpad) {
+			chip->read_buf(mtd, oob, chip->ecc.postpad);
+			oob += chip->ecc.postpad;
 		}
+	}
 
-		/* get oob area, if we have no oob buffer from fs-driver */
-		if (!oob_buf || oobsel->useecc == MTD_NANDECC_AUTOPLACE ||
-			oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
-			oob_data = &this->data_buf[end];
+	/* Calculate remaining oob bytes */
+	i = mtd->oobsize - (oob - chip->oob_poi);
+	if (i)
+		chip->read_buf(mtd, oob, i);
 
-		eccsteps = this->eccsteps;
+	return 0;
+}
 
-		switch (eccmode) {
-		case NAND_ECC_NONE: {	/* No ECC, Read in a page */
-/* XXX U-BOOT XXX */
-#if 0
-			static unsigned long lastwhinge = 0;
-			if ((lastwhinge / HZ) != (jiffies / HZ)) {
-				printk (KERN_WARNING "Reading data from NAND FLASH without ECC is not recommended\n");
-				lastwhinge = jiffies;
+/**
+ * nand_transfer_oob - [Internal] Transfer oob to client buffer
+ * @chip:	nand chip structure
+ * @oob:	oob destination address
+ * @ops:	oob ops structure
+ * @len:	size of oob to transfer
+ */
+static uint8_t *nand_transfer_oob(struct nand_chip *chip, uint8_t *oob,
+				  struct mtd_oob_ops *ops, size_t len)
+{
+	switch(ops->mode) {
+
+	case MTD_OOB_PLACE:
+	case MTD_OOB_RAW:
+		memcpy(oob, chip->oob_poi + ops->ooboffs, len);
+		return oob + len;
+
+	case MTD_OOB_AUTO: {
+		struct nand_oobfree *free = chip->ecc.layout->oobfree;
+		uint32_t boffs = 0, roffs = ops->ooboffs;
+		size_t bytes = 0;
+
+		for(; free->length && len; free++, len -= bytes) {
+			/* Read request not from offset 0 ? */
+			if (unlikely(roffs)) {
+				if (roffs >= free->length) {
+					roffs -= free->length;
+					continue;
+				}
+				boffs = free->offset + roffs;
+				bytes = min_t(size_t, len,
+					      (free->length - roffs));
+				roffs = 0;
+			} else {
+				bytes = min_t(size_t, len, free->length);
+				boffs = free->offset;
 			}
-#else
-			puts("Reading data from NAND FLASH without ECC is not recommended\n");
-#endif
-			this->read_buf(mtd, data_poi, end);
-			break;
+			memcpy(oob, chip->oob_poi + boffs, bytes);
+			oob += bytes;
 		}
+		return oob;
+	}
+	default:
+		BUG();
+	}
+	return NULL;
+}
 
-		case NAND_ECC_SOFT:	/* Software ECC 3/256: Read in a page + oob data */
-			this->read_buf(mtd, data_poi, end);
-			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=3, datidx += ecc)
-				this->calculate_ecc(mtd, &data_poi[datidx], &ecc_calc[i]);
-			break;
+/**
+ * nand_do_read_ops - [Internal] Read data with ECC
+ *
+ * @mtd:	MTD device structure
+ * @from:	offset to read from
+ * @ops:	oob ops structure
+ *
+ * Internal function. Called with chip held.
+ */
+static int nand_do_read_ops(struct mtd_info *mtd, loff_t from,
+			    struct mtd_oob_ops *ops)
+{
+	int chipnr, page, realpage, col, bytes, aligned;
+	struct nand_chip *chip = mtd->priv;
+	struct mtd_ecc_stats stats;
+	int blkcheck = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;
+	int sndcmd = 1;
+	int ret = 0;
+	uint32_t readlen = ops->len;
+	uint32_t oobreadlen = ops->ooblen;
+	uint8_t *bufpoi, *oob, *buf;
 
-		default:
-			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=eccbytes, datidx += ecc) {
-				this->enable_hwecc(mtd, NAND_ECC_READ);
-				this->read_buf(mtd, &data_poi[datidx], ecc);
-
-				/* HW ecc with syndrome calculation must read the
-				 * syndrome from flash immidiately after the data */
-				if (!compareecc) {
-					/* Some hw ecc generators need to know when the
-					 * syndrome is read from flash */
-					this->enable_hwecc(mtd, NAND_ECC_READSYN);
-					this->read_buf(mtd, &oob_data[i], eccbytes);
-					/* We calc error correction directly, it checks the hw
-					 * generator for an error, reads back the syndrome and
-					 * does the error correction on the fly */
-					if (this->correct_data(mtd, &data_poi[datidx], &oob_data[i], &ecc_code[i]) == -1) {
-						MTDDEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: "
-							"Failed ECC read, page 0x%08x on chip %d\n", page, chipnr);
-						ecc_failed++;
-					}
-				} else {
-					this->calculate_ecc(mtd, &data_poi[datidx], &ecc_calc[i]);
-				}
-			}
-			break;
-		}
+	stats = mtd->ecc_stats;
 
-		/* read oobdata */
-		this->read_buf(mtd, &oob_data[mtd->oobsize - oobreadlen], oobreadlen);
+	chipnr = (int)(from >> chip->chip_shift);
+	chip->select_chip(mtd, chipnr);
 
-		/* Skip ECC check, if not requested (ECC_NONE or HW_ECC with syndromes) */
-		if (!compareecc)
-			goto readoob;
+	realpage = (int)(from >> chip->page_shift);
+	page = realpage & chip->pagemask;
 
-		/* Pick the ECC bytes out of the oob data */
-		for (j = 0; j < oobsel->eccbytes; j++)
-			ecc_code[j] = oob_data[oob_config[j]];
+	col = (int)(from & (mtd->writesize - 1));
 
-		/* correct data, if neccecary */
-		for (i = 0, j = 0, datidx = 0; i < this->eccsteps; i++, datidx += ecc) {
-			ecc_status = this->correct_data(mtd, &data_poi[datidx], &ecc_code[j], &ecc_calc[j]);
+	buf = ops->datbuf;
+	oob = ops->oobbuf;
 
-			/* Get next chunk of ecc bytes */
-			j += eccbytes;
+	while(1) {
+		bytes = min(mtd->writesize - col, readlen);
+		aligned = (bytes == mtd->writesize);
 
-			/* Check, if we have a fs supplied oob-buffer,
-			 * This is the legacy mode. Used by YAFFS1
-			 * Should go away some day
-			 */
-			if (oob_buf && oobsel->useecc == MTD_NANDECC_PLACE) {
-				int *p = (int *)(&oob_data[mtd->oobsize]);
-				p[i] = ecc_status;
-			}
+		/* Is the current page in the buffer ? */
+		if (realpage != chip->pagebuf || oob) {
+			bufpoi = aligned ? buf : chip->buffers->databuf;
 
-			if (ecc_status == -1) {
-				MTDDEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: "
-				          "Failed ECC read, page 0x%08x\n",
-				          page);
-				ecc_failed++;
+			if (likely(sndcmd)) {
+				chip->cmdfunc(mtd, NAND_CMD_READ0, 0x00, page);
+				sndcmd = 0;
 			}
-		}
 
-	readoob:
-		/* check, if we have a fs supplied oob-buffer */
-		if (oob_buf) {
-			/* without autoplace. Legacy mode used by YAFFS1 */
-			switch(oobsel->useecc) {
-			case MTD_NANDECC_AUTOPLACE:
-			case MTD_NANDECC_AUTOPL_USR:
-				/* Walk through the autoplace chunks */
-				for (i = 0, j = 0; j < mtd->oobavail; i++) {
-					int from = oobsel->oobfree[i][0];
-					int num = oobsel->oobfree[i][1];
-					memcpy(&oob_buf[oob+j], &oob_data[from], num);
-					j+= num;
-				}
-				oob += mtd->oobavail;
+			/* Now read the page into the buffer */
+			if (unlikely(ops->mode == MTD_OOB_RAW))
+				ret = chip->ecc.read_page_raw(mtd, chip, bufpoi);
+			else if (!aligned && NAND_SUBPAGE_READ(chip) && !oob)
+				ret = chip->ecc.read_subpage(mtd, chip, col, bytes, bufpoi);
+			else
+				ret = chip->ecc.read_page(mtd, chip, bufpoi);
+			if (ret < 0)
 				break;
-			case MTD_NANDECC_PLACE:
-				/* YAFFS1 legacy mode */
-				oob_data += this->eccsteps * sizeof (int);
-			default:
-				oob_data += mtd->oobsize;
+
+			/* Transfer not aligned data */
+			if (!aligned) {
+				if (!NAND_SUBPAGE_READ(chip) && !oob)
+					chip->pagebuf = realpage;
+				memcpy(buf, chip->buffers->databuf + col, bytes);
 			}
+
+			buf += bytes;
+
+			if (unlikely(oob)) {
+				/* Raw mode does data:oob:data:oob */
+				if (ops->mode != MTD_OOB_RAW) {
+					int toread = min(oobreadlen,
+						chip->ecc.layout->oobavail);
+					if (toread) {
+						oob = nand_transfer_oob(chip,
+							oob, ops, toread);
+						oobreadlen -= toread;
+					}
+				} else
+					buf = nand_transfer_oob(chip,
+						buf, ops, mtd->oobsize);
+			}
+
+			if (!(chip->options & NAND_NO_READRDY)) {
+				/*
+				 * Apply delay or wait for ready/busy pin. Do
+				 * this before the AUTOINCR check, so no
+				 * problems arise if a chip which does auto
+				 * increment is marked as NOAUTOINCR by the
+				 * board driver.
+				 */
+				if (!chip->dev_ready)
+					udelay(chip->chip_delay);
+				else
+					nand_wait_ready(mtd);
+			}
+		} else {
+			memcpy(buf, chip->buffers->databuf + col, bytes);
+			buf += bytes;
 		}
-	readdata:
-		/* Partial page read, transfer data into fs buffer */
-		if (!aligned) {
-			for (j = col; j < end && read < len; j++)
-				buf[read++] = data_poi[j];
-			this->pagebuf = realpage;
-		} else
-			read += mtd->oobblock;
-
-		/* Apply delay or wait for ready/busy pin
-		 * Do this before the AUTOINCR check, so no problems
-		 * arise if a chip which does auto increment
-		 * is marked as NOAUTOINCR by the board driver.
-		*/
-		if (!this->dev_ready)
-			udelay (this->chip_delay);
-		else
-			while (!this->dev_ready(mtd));
 
-		if (read == len)
+		readlen -= bytes;
+
+		if (!readlen)
 			break;
 
 		/* For subsequent reads align to page boundary. */
@@ -1360,732 +1279,829 @@ static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
 		/* Increment page address */
 		realpage++;
 
-		page = realpage & this->pagemask;
+		page = realpage & chip->pagemask;
 		/* Check, if we cross a chip boundary */
 		if (!page) {
 			chipnr++;
-			this->select_chip(mtd, -1);
-			this->select_chip(mtd, chipnr);
+			chip->select_chip(mtd, -1);
+			chip->select_chip(mtd, chipnr);
 		}
+
 		/* Check, if the chip supports auto page increment
 		 * or if we have hit a block boundary.
-		*/
-		if (!NAND_CANAUTOINCR(this) || !(page & blockcheck))
+		 */
+		if (!NAND_CANAUTOINCR(chip) || !(page & blkcheck))
 			sndcmd = 1;
 	}
 
-	/* Deselect and wake up anyone waiting on the device */
-	nand_release_device(mtd);
+	ops->retlen = ops->len - (size_t) readlen;
+	if (oob)
+		ops->oobretlen = ops->ooblen - oobreadlen;
 
-	/*
-	 * Return success, if no ECC failures, else -EBADMSG
-	 * fs driver will take care of that, because
-	 * retlen == desired len and result == -EBADMSG
-	 */
-	*retlen = read;
-	return ecc_failed ? -EBADMSG : 0;
+	if (ret)
+		return ret;
+
+	if (mtd->ecc_stats.failed - stats.failed)
+		return -EBADMSG;
+
+	return  mtd->ecc_stats.corrected - stats.corrected ? -EUCLEAN : 0;
 }
 
 /**
- * nand_read_oob - [MTD Interface] NAND read out-of-band
+ * nand_read - [MTD Interface] MTD compability function for nand_do_read_ecc
  * @mtd:	MTD device structure
  * @from:	offset to read from
  * @len:	number of bytes to read
  * @retlen:	pointer to variable to store the number of read bytes
  * @buf:	the databuffer to put data
  *
- * NAND read out-of-band data from the spare area
+ * Get hold of the chip and call nand_do_read
  */
-static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
+static int nand_read(struct mtd_info *mtd, loff_t from, size_t len,
+		     size_t *retlen, uint8_t *buf)
 {
-	int i, col, page, chipnr;
-	struct nand_chip *this = mtd->priv;
-	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
+	struct nand_chip *chip = mtd->priv;
+	int ret;
+
+	/* Do not allow reads past end of device */
+	if ((from + len) > mtd->size)
+		return -EINVAL;
+	if (!len)
+		return 0;
 
-	MTDDEBUG (MTD_DEBUG_LEVEL3, "nand_read_oob: from = 0x%08x, len = %i\n",
-	          (unsigned int) from, (int) len);
+	nand_get_device(chip, mtd, FL_READING);
 
-	/* Shift to get page */
-	page = (int)(from >> this->page_shift);
-	chipnr = (int)(from >> this->chip_shift);
+	chip->ops.len = len;
+	chip->ops.datbuf = buf;
+	chip->ops.oobbuf = NULL;
 
-	/* Mask to get column */
-	col = from & (mtd->oobsize - 1);
+	ret = nand_do_read_ops(mtd, from, &chip->ops);
 
-	/* Initialize return length value */
-	*retlen = 0;
+	*retlen = chip->ops.retlen;
 
-	/* Do not allow reads past end of device */
-	if ((from + len) > mtd->size) {
-		MTDDEBUG (MTD_DEBUG_LEVEL0,
-		          "nand_read_oob: Attempt read beyond end of device\n");
-		*retlen = 0;
-		return -EINVAL;
+	nand_release_device(mtd);
+
+	return ret;
+}
+
+/**
+ * nand_read_oob_std - [REPLACABLE] the most common OOB data read function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @page:	page number to read
+ * @sndcmd:	flag whether to issue read command or not
+ */
+static int nand_read_oob_std(struct mtd_info *mtd, struct nand_chip *chip,
+			     int page, int sndcmd)
+{
+	if (sndcmd) {
+		chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+		sndcmd = 0;
 	}
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+	return sndcmd;
+}
 
-	/* Grab the lock and see if the device is available */
-	nand_get_device (this, mtd , FL_READING);
+/**
+ * nand_read_oob_syndrome - [REPLACABLE] OOB data read function for HW ECC
+ *			    with syndromes
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @page:	page number to read
+ * @sndcmd:	flag whether to issue read command or not
+ */
+static int nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
+				  int page, int sndcmd)
+{
+	uint8_t *buf = chip->oob_poi;
+	int length = mtd->oobsize;
+	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
+	int eccsize = chip->ecc.size;
+	uint8_t *bufpoi = buf;
+	int i, toread, sndrnd = 0, pos;
+
+	chip->cmdfunc(mtd, NAND_CMD_READ0, chip->ecc.size, page);
+	for (i = 0; i < chip->ecc.steps; i++) {
+		if (sndrnd) {
+			pos = eccsize + i * (eccsize + chunk);
+			if (mtd->writesize > 512)
+				chip->cmdfunc(mtd, NAND_CMD_RNDOUT, pos, -1);
+			else
+				chip->cmdfunc(mtd, NAND_CMD_READ0, pos, page);
+		} else
+			sndrnd = 1;
+		toread = min_t(int, length, chunk);
+		chip->read_buf(mtd, bufpoi, toread);
+		bufpoi += toread;
+		length -= toread;
+	}
+	if (length > 0)
+		chip->read_buf(mtd, bufpoi, length);
 
-	/* Select the NAND device */
-	this->select_chip(mtd, chipnr);
+	return 1;
+}
+
+/**
+ * nand_write_oob_std - [REPLACABLE] the most common OOB data write function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @page:	page number to write
+ */
+static int nand_write_oob_std(struct mtd_info *mtd, struct nand_chip *chip,
+			      int page)
+{
+	int status = 0;
+	const uint8_t *buf = chip->oob_poi;
+	int length = mtd->oobsize;
+
+	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
+	chip->write_buf(mtd, buf, length);
+	/* Send command to program the OOB data */
+	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+	status = chip->waitfunc(mtd, chip);
+
+	return status & NAND_STATUS_FAIL ? -EIO : 0;
+}
+
+/**
+ * nand_write_oob_syndrome - [REPLACABLE] OOB data write function for HW ECC
+ *			     with syndrome - only for large page flash !
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @page:	page number to write
+ */
+static int nand_write_oob_syndrome(struct mtd_info *mtd,
+				   struct nand_chip *chip, int page)
+{
+	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
+	int eccsize = chip->ecc.size, length = mtd->oobsize;
+	int i, len, pos, status = 0, sndcmd = 0, steps = chip->ecc.steps;
+	const uint8_t *bufpoi = chip->oob_poi;
 
-	/* Send the read command */
-	this->cmdfunc (mtd, NAND_CMD_READOOB, col, page & this->pagemask);
 	/*
-	 * Read the data, if we read more than one page
-	 * oob data, let the device transfer the data !
+	 * data-ecc-data-ecc ... ecc-oob
+	 * or
+	 * data-pad-ecc-pad-data-pad .... ecc-pad-oob
 	 */
-	i = 0;
-	while (i < len) {
-		int thislen = mtd->oobsize - col;
-		thislen = min_t(int, thislen, len);
-		this->read_buf(mtd, &buf[i], thislen);
-		i += thislen;
-
-		/* Apply delay or wait for ready/busy pin
-		 * Do this before the AUTOINCR check, so no problems
-		 * arise if a chip which does auto increment
-		 * is marked as NOAUTOINCR by the board driver.
-		*/
-		if (!this->dev_ready)
-			udelay (this->chip_delay);
-		else
-			while (!this->dev_ready(mtd));
-
-		/* Read more ? */
-		if (i < len) {
-			page++;
-			col = 0;
-
-			/* Check, if we cross a chip boundary */
-			if (!(page & this->pagemask)) {
-				chipnr++;
-				this->select_chip(mtd, -1);
-				this->select_chip(mtd, chipnr);
-			}
-
-			/* Check, if the chip supports auto page increment
-			 * or if we have hit a block boundary.
-			*/
-			if (!NAND_CANAUTOINCR(this) || !(page & blockcheck)) {
-				/* For subsequent page reads set offset to 0 */
-				this->cmdfunc (mtd, NAND_CMD_READOOB, 0x0, page & this->pagemask);
+	if (!chip->ecc.prepad && !chip->ecc.postpad) {
+		pos = steps * (eccsize + chunk);
+		steps = 0;
+	} else
+		pos = eccsize;
+
+	chip->cmdfunc(mtd, NAND_CMD_SEQIN, pos, page);
+	for (i = 0; i < steps; i++) {
+		if (sndcmd) {
+			if (mtd->writesize <= 512) {
+				uint32_t fill = 0xFFFFFFFF;
+
+				len = eccsize;
+				while (len > 0) {
+					int num = min_t(int, len, 4);
+					chip->write_buf(mtd, (uint8_t *)&fill,
+							num);
+					len -= num;
+				}
+			} else {
+				pos = eccsize + i * (eccsize + chunk);
+				chip->cmdfunc(mtd, NAND_CMD_RNDIN, pos, -1);
 			}
-		}
+		} else
+			sndcmd = 1;
+		len = min_t(int, length, chunk);
+		chip->write_buf(mtd, bufpoi, len);
+		bufpoi += len;
+		length -= len;
 	}
+	if (length > 0)
+		chip->write_buf(mtd, bufpoi, length);
 
-	/* Deselect and wake up anyone waiting on the device */
-	nand_release_device(mtd);
+	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+	status = chip->waitfunc(mtd, chip);
 
-	/* Return happy */
-	*retlen = len;
-	return 0;
+	return status & NAND_STATUS_FAIL ? -EIO : 0;
 }
 
 /**
- * nand_read_raw - [GENERIC] Read raw data including oob into buffer
+ * nand_do_read_oob - [Intern] NAND read out-of-band
  * @mtd:	MTD device structure
- * @buf:	temporary buffer
  * @from:	offset to read from
- * @len:	number of bytes to read
- * @ooblen:	number of oob data bytes to read
+ * @ops:	oob operations description structure
  *
- * Read raw data including oob into buffer
+ * NAND read out-of-band data from the spare area
  */
-int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_t len, size_t ooblen)
+static int nand_do_read_oob(struct mtd_info *mtd, loff_t from,
+			    struct mtd_oob_ops *ops)
 {
-	struct nand_chip *this = mtd->priv;
-	int page = (int) (from >> this->page_shift);
-	int chip = (int) (from >> this->chip_shift);
-	int sndcmd = 1;
-	int cnt = 0;
-	int pagesize = mtd->oobblock + mtd->oobsize;
-	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
+	int page, realpage, chipnr, sndcmd = 1;
+	struct nand_chip *chip = mtd->priv;
+	int blkcheck = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;
+	int readlen = ops->ooblen;
+	int len;
+	uint8_t *buf = ops->oobbuf;
+
+	MTDDEBUG (MTD_DEBUG_LEVEL3, "nand_read_oob: from = 0x%08Lx, len = %i\n",
+	          (unsigned long long)from, readlen);
+
+	if (ops->mode == MTD_OOB_AUTO)
+		len = chip->ecc.layout->oobavail;
+	else
+		len = mtd->oobsize;
+
+	if (unlikely(ops->ooboffs >= len)) {
+		MTDDEBUG (MTD_DEBUG_LEVEL0, "nand_read_oob: "
+		          "Attempt to start read outside oob\n");
+		return -EINVAL;
+	}
 
 	/* Do not allow reads past end of device */
-	if ((from + len) > mtd->size) {
-		MTDDEBUG (MTD_DEBUG_LEVEL0,
-		          "nand_read_raw: Attempt read beyond end of device\n");
+	if (unlikely(from >= mtd->size ||
+		     ops->ooboffs + readlen > ((mtd->size >> chip->page_shift) -
+					(from >> chip->page_shift)) * len)) {
+		MTDDEBUG (MTD_DEBUG_LEVEL0, "nand_read_oob: "
+		          "Attempt read beyond end of device\n");
 		return -EINVAL;
 	}
 
-	/* Grab the lock and see if the device is available */
-	nand_get_device (this, mtd , FL_READING);
+	chipnr = (int)(from >> chip->chip_shift);
+	chip->select_chip(mtd, chipnr);
 
-	this->select_chip (mtd, chip);
+	/* Shift to get page */
+	realpage = (int)(from >> chip->page_shift);
+	page = realpage & chip->pagemask;
 
-	/* Add requested oob length */
-	len += ooblen;
+	while(1) {
+		sndcmd = chip->ecc.read_oob(mtd, chip, page, sndcmd);
 
-	while (len) {
-		if (sndcmd)
-			this->cmdfunc (mtd, NAND_CMD_READ0, 0, page & this->pagemask);
-		sndcmd = 0;
+		len = min(len, readlen);
+		buf = nand_transfer_oob(chip, buf, ops, len);
 
-		this->read_buf (mtd, &buf[cnt], pagesize);
+		if (!(chip->options & NAND_NO_READRDY)) {
+			/*
+			 * Apply delay or wait for ready/busy pin. Do this
+			 * before the AUTOINCR check, so no problems arise if a
+			 * chip which does auto increment is marked as
+			 * NOAUTOINCR by the board driver.
+			 */
+			if (!chip->dev_ready)
+				udelay(chip->chip_delay);
+			else
+				nand_wait_ready(mtd);
+		}
 
-		len -= pagesize;
-		cnt += pagesize;
-		page++;
+		readlen -= len;
+		if (!readlen)
+			break;
 
-		if (!this->dev_ready)
-			udelay (this->chip_delay);
-		else
-			while (!this->dev_ready(mtd));
+		/* Increment page address */
+		realpage++;
 
-		/* Check, if the chip supports auto page increment */
-		if (!NAND_CANAUTOINCR(this) || !(page & blockcheck))
+		page = realpage & chip->pagemask;
+		/* Check, if we cross a chip boundary */
+		if (!page) {
+			chipnr++;
+			chip->select_chip(mtd, -1);
+			chip->select_chip(mtd, chipnr);
+		}
+
+		/* Check, if the chip supports auto page increment
+		 * or if we have hit a block boundary.
+		 */
+		if (!NAND_CANAUTOINCR(chip) || !(page & blkcheck))
 			sndcmd = 1;
 	}
 
-	/* Deselect and wake up anyone waiting on the device */
-	nand_release_device(mtd);
+	ops->oobretlen = ops->ooblen;
 	return 0;
 }
 
-
 /**
- * nand_prepare_oobbuf - [GENERIC] Prepare the out of band buffer
+ * nand_read_oob - [MTD Interface] NAND read data and/or out-of-band
  * @mtd:	MTD device structure
- * @fsbuf:	buffer given by fs driver
- * @oobsel:	out of band selection structre
- * @autoplace:	1 = place given buffer into the oob bytes
- * @numpages:	number of pages to prepare
- *
- * Return:
- * 1. Filesystem buffer available and autoplacement is off,
- *    return filesystem buffer
- * 2. No filesystem buffer or autoplace is off, return internal
- *    buffer
- * 3. Filesystem buffer is given and autoplace selected
- *    put data from fs buffer into internal buffer and
- *    retrun internal buffer
- *
- * Note: The internal buffer is filled with 0xff. This must
- * be done only once, when no autoplacement happens
- * Autoplacement sets the buffer dirty flag, which
- * forces the 0xff fill before using the buffer again.
+ * @from:	offset to read from
+ * @ops:	oob operation description structure
  *
-*/
-static u_char * nand_prepare_oobbuf (struct mtd_info *mtd, u_char *fsbuf, struct nand_oobinfo *oobsel,
-		int autoplace, int numpages)
+ * NAND read data and/or out-of-band data
+ */
+static int nand_read_oob(struct mtd_info *mtd, loff_t from,
+			 struct mtd_oob_ops *ops)
 {
-	struct nand_chip *this = mtd->priv;
-	int i, len, ofs;
-
-	/* Zero copy fs supplied buffer */
-	if (fsbuf && !autoplace)
-		return fsbuf;
-
-	/* Check, if the buffer must be filled with ff again */
-	if (this->oobdirty) {
-		memset (this->oob_buf, 0xff,
-			mtd->oobsize << (this->phys_erase_shift - this->page_shift));
-		this->oobdirty = 0;
-	}
-
-	/* If we have no autoplacement or no fs buffer use the internal one */
-	if (!autoplace || !fsbuf)
-		return this->oob_buf;
-
-	/* Walk through the pages and place the data */
-	this->oobdirty = 1;
-	ofs = 0;
-	while (numpages--) {
-		for (i = 0, len = 0; len < mtd->oobavail; i++) {
-			int to = ofs + oobsel->oobfree[i][0];
-			int num = oobsel->oobfree[i][1];
-			memcpy (&this->oob_buf[to], fsbuf, num);
-			len += num;
-			fsbuf += num;
-		}
-		ofs += mtd->oobavail;
+	struct nand_chip *chip = mtd->priv;
+	int ret = -ENOTSUPP;
+
+	ops->retlen = 0;
+
+	/* Do not allow reads past end of device */
+	if (ops->datbuf && (from + ops->len) > mtd->size) {
+		MTDDEBUG (MTD_DEBUG_LEVEL0, "nand_read_oob: "
+		          "Attempt read beyond end of device\n");
+		return -EINVAL;
+	}
+
+	nand_get_device(chip, mtd, FL_READING);
+
+	switch(ops->mode) {
+	case MTD_OOB_PLACE:
+	case MTD_OOB_AUTO:
+	case MTD_OOB_RAW:
+		break;
+
+	default:
+		goto out;
 	}
-	return this->oob_buf;
+
+	if (!ops->datbuf)
+		ret = nand_do_read_oob(mtd, from, ops);
+	else
+		ret = nand_do_read_ops(mtd, from, ops);
+
+ out:
+	nand_release_device(mtd);
+	return ret;
 }
 
-#define NOTALIGNED(x) (x & (mtd->oobblock-1)) != 0
 
 /**
- * nand_write - [MTD Interface] compability function for nand_write_ecc
- * @mtd:	MTD device structure
- * @to:		offset to write to
- * @len:	number of bytes to write
- * @retlen:	pointer to variable to store the number of written bytes
- * @buf:	the data to write
- *
- * This function simply calls nand_write_ecc with oob buffer and oobsel = NULL
- *
-*/
-static int nand_write (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf)
+ * nand_write_page_raw - [Intern] raw page write function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @buf:	data buffer
+ */
+static void nand_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+				const uint8_t *buf)
 {
-	return (nand_write_ecc (mtd, to, len, retlen, buf, NULL, NULL));
+	chip->write_buf(mtd, buf, mtd->writesize);
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
 }
 
 /**
- * nand_write_ecc - [MTD Interface] NAND write with ECC
- * @mtd:	MTD device structure
- * @to:		offset to write to
- * @len:	number of bytes to write
- * @retlen:	pointer to variable to store the number of written bytes
- * @buf:	the data to write
- * @eccbuf:	filesystem supplied oob data buffer
- * @oobsel:	oob selection structure
- *
- * NAND write with ECC
+ * nand_write_page_swecc - [REPLACABLE] software ecc based page write function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @buf:	data buffer
  */
-static int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
-			   size_t * retlen, const u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel)
+static void nand_write_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
+				  const uint8_t *buf)
 {
-	int startpage, page, ret = -EIO, oob = 0, written = 0, chipnr;
-	int autoplace = 0, numpages, totalpages;
-	struct nand_chip *this = mtd->priv;
-	u_char *oobbuf, *bufstart;
-	int	ppblock = (1 << (this->phys_erase_shift - this->page_shift));
+	int i, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	const uint8_t *p = buf;
+	uint32_t *eccpos = chip->ecc.layout->eccpos;
 
-	MTDDEBUG (MTD_DEBUG_LEVEL3, "nand_write_ecc: to = 0x%08x, len = %i\n",
-	          (unsigned int) to, (int) len);
+	/* Software ecc calculation */
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
+		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
 
-	/* Initialize retlen, in case of early exit */
-	*retlen = 0;
+	for (i = 0; i < chip->ecc.total; i++)
+		chip->oob_poi[eccpos[i]] = ecc_calc[i];
 
-	/* Do not allow write past end of device */
-	if ((to + len) > mtd->size) {
-		MTDDEBUG (MTD_DEBUG_LEVEL0,
-		          "nand_write_ecc: Attempt to write past end of page\n");
-		return -EINVAL;
-	}
+	chip->ecc.write_page_raw(mtd, chip, buf);
+}
 
-	/* reject writes, which are not page aligned */
-	if (NOTALIGNED (to) || NOTALIGNED(len)) {
-		printk (KERN_NOTICE "nand_write_ecc: Attempt to write not page aligned data\n");
-		return -EINVAL;
+/**
+ * nand_write_page_hwecc - [REPLACABLE] hardware ecc based page write function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @buf:	data buffer
+ */
+static void nand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
+				  const uint8_t *buf)
+{
+	int i, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	const uint8_t *p = buf;
+	uint32_t *eccpos = chip->ecc.layout->eccpos;
+
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+		chip->write_buf(mtd, p, eccsize);
+		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
 	}
 
-	/* Grab the lock and see if the device is available */
-	nand_get_device (this, mtd, FL_WRITING);
+	for (i = 0; i < chip->ecc.total; i++)
+		chip->oob_poi[eccpos[i]] = ecc_calc[i];
 
-	/* Calculate chipnr */
-	chipnr = (int)(to >> this->chip_shift);
-	/* Select the NAND device */
-	this->select_chip(mtd, chipnr);
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+}
 
-	/* Check, if it is write protected */
-	if (nand_check_wp(mtd)) {
-		printk (KERN_NOTICE "nand_write_ecc: Device is write protected\n");
-		goto out;
-	}
+/**
+ * nand_write_page_syndrome - [REPLACABLE] hardware ecc syndrom based page write
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @buf:	data buffer
+ *
+ * The hw generator calculates the error syndrome automatically. Therefor
+ * we need a special oob layout and handling.
+ */
+static void nand_write_page_syndrome(struct mtd_info *mtd,
+				    struct nand_chip *chip, const uint8_t *buf)
+{
+	int i, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	const uint8_t *p = buf;
+	uint8_t *oob = chip->oob_poi;
 
-	/* if oobsel is NULL, use chip defaults */
-	if (oobsel == NULL)
-		oobsel = &mtd->oobinfo;
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
 
-	/* Autoplace of oob data ? Use the default placement scheme */
-	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE) {
-		oobsel = this->autooob;
-		autoplace = 1;
-	}
-	if (oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
-		autoplace = 1;
+		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+		chip->write_buf(mtd, p, eccsize);
 
-	/* Setup variables and oob buffer */
-	totalpages = len >> this->page_shift;
-	page = (int) (to >> this->page_shift);
-	/* Invalidate the page cache, if we write to the cached page */
-	if (page <= this->pagebuf && this->pagebuf < (page + totalpages))
-		this->pagebuf = -1;
-
-	/* Set it relative to chip */
-	page &= this->pagemask;
-	startpage = page;
-	/* Calc number of pages we can write in one go */
-	numpages = min (ppblock - (startpage  & (ppblock - 1)), totalpages);
-	oobbuf = nand_prepare_oobbuf (mtd, eccbuf, oobsel, autoplace, numpages);
-	bufstart = (u_char *)buf;
-
-	/* Loop until all data is written */
-	while (written < len) {
-
-		this->data_poi = (u_char*) &buf[written];
-		/* Write one page. If this is the last page to write
-		 * or the last page in this block, then use the
-		 * real pageprogram command, else select cached programming
-		 * if supported by the chip.
-		 */
-		ret = nand_write_page (mtd, this, page, &oobbuf[oob], oobsel, (--numpages > 0));
-		if (ret) {
-			MTDDEBUG (MTD_DEBUG_LEVEL0,
-			          "nand_write_ecc: write_page failed %d\n", ret);
-			goto out;
+		if (chip->ecc.prepad) {
+			chip->write_buf(mtd, oob, chip->ecc.prepad);
+			oob += chip->ecc.prepad;
 		}
-		/* Next oob page */
-		oob += mtd->oobsize;
-		/* Update written bytes count */
-		written += mtd->oobblock;
-		if (written == len)
-			goto cmp;
 
-		/* Increment page address */
-		page++;
-
-		/* Have we hit a block boundary ? Then we have to verify and
-		 * if verify is ok, we have to setup the oob buffer for
-		 * the next pages.
-		*/
-		if (!(page & (ppblock - 1))){
-			int ofs;
-			this->data_poi = bufstart;
-			ret = nand_verify_pages (mtd, this, startpage,
-				page - startpage,
-				oobbuf, oobsel, chipnr, (eccbuf != NULL));
-			if (ret) {
-				MTDDEBUG (MTD_DEBUG_LEVEL0, "nand_write_ecc: "
-				          "verify_pages failed %d\n", ret);
-				goto out;
-			}
-			*retlen = written;
-			bufstart = (u_char*) &buf[written];
-
-			ofs = autoplace ? mtd->oobavail : mtd->oobsize;
-			if (eccbuf)
-				eccbuf += (page - startpage) * ofs;
-			totalpages -= page - startpage;
-			numpages = min (totalpages, ppblock);
-			page &= this->pagemask;
-			startpage = page;
-			oob = 0;
-			this->oobdirty = 1;
-			oobbuf = nand_prepare_oobbuf (mtd, eccbuf, oobsel,
-					autoplace, numpages);
-			/* Check, if we cross a chip boundary */
-			if (!page) {
-				chipnr++;
-				this->select_chip(mtd, -1);
-				this->select_chip(mtd, chipnr);
-			}
+		chip->ecc.calculate(mtd, p, oob);
+		chip->write_buf(mtd, oob, eccbytes);
+		oob += eccbytes;
+
+		if (chip->ecc.postpad) {
+			chip->write_buf(mtd, oob, chip->ecc.postpad);
+			oob += chip->ecc.postpad;
 		}
 	}
-	/* Verify the remaining pages */
-cmp:
-	this->data_poi = bufstart;
-	ret = nand_verify_pages (mtd, this, startpage, totalpages,
-		oobbuf, oobsel, chipnr, (eccbuf != NULL));
-	if (!ret)
-		*retlen = written;
+
+	/* Calculate remaining oob bytes */
+	i = mtd->oobsize - (oob - chip->oob_poi);
+	if (i)
+		chip->write_buf(mtd, oob, i);
+}
+
+/**
+ * nand_write_page - [REPLACEABLE] write one page
+ * @mtd:	MTD device structure
+ * @chip:	NAND chip descriptor
+ * @buf:	the data to write
+ * @page:	page number to write
+ * @cached:	cached programming
+ * @raw:	use _raw version of write_page
+ */
+static int nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
+			   const uint8_t *buf, int page, int cached, int raw)
+{
+	int status;
+
+	chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);
+
+	if (unlikely(raw))
+		chip->ecc.write_page_raw(mtd, chip, buf);
 	else
-		MTDDEBUG (MTD_DEBUG_LEVEL0,
-		          "nand_write_ecc: verify_pages failed %d\n", ret);
+		chip->ecc.write_page(mtd, chip, buf);
 
-out:
-	/* Deselect and wake up anyone waiting on the device */
-	nand_release_device(mtd);
+	/*
+	 * Cached progamming disabled for now, Not sure if its worth the
+	 * trouble. The speed gain is not very impressive. (2.3->2.6Mib/s)
+	 */
+	cached = 0;
 
-	return ret;
+	if (!cached || !(chip->options & NAND_CACHEPRG)) {
+
+		chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+		status = chip->waitfunc(mtd, chip);
+		/*
+		 * See if operation failed and additional status checks are
+		 * available
+		 */
+		if ((status & NAND_STATUS_FAIL) && (chip->errstat))
+			status = chip->errstat(mtd, chip, FL_WRITING, status,
+					       page);
+
+		if (status & NAND_STATUS_FAIL)
+			return -EIO;
+	} else {
+		chip->cmdfunc(mtd, NAND_CMD_CACHEDPROG, -1, -1);
+		status = chip->waitfunc(mtd, chip);
+	}
+
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+	/* Send command to read back the data */
+	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
+
+	if (chip->verify_buf(mtd, buf, mtd->writesize))
+		return -EIO;
+#endif
+	return 0;
+}
+
+/**
+ * nand_fill_oob - [Internal] Transfer client buffer to oob
+ * @chip:	nand chip structure
+ * @oob:	oob data buffer
+ * @ops:	oob ops structure
+ */
+static uint8_t *nand_fill_oob(struct nand_chip *chip, uint8_t *oob,
+				  struct mtd_oob_ops *ops)
+{
+	size_t len = ops->ooblen;
+
+	switch(ops->mode) {
+
+	case MTD_OOB_PLACE:
+	case MTD_OOB_RAW:
+		memcpy(chip->oob_poi + ops->ooboffs, oob, len);
+		return oob + len;
+
+	case MTD_OOB_AUTO: {
+		struct nand_oobfree *free = chip->ecc.layout->oobfree;
+		uint32_t boffs = 0, woffs = ops->ooboffs;
+		size_t bytes = 0;
+
+		for(; free->length && len; free++, len -= bytes) {
+			/* Write request not from offset 0 ? */
+			if (unlikely(woffs)) {
+				if (woffs >= free->length) {
+					woffs -= free->length;
+					continue;
+				}
+				boffs = free->offset + woffs;
+				bytes = min_t(size_t, len,
+					      (free->length - woffs));
+				woffs = 0;
+			} else {
+				bytes = min_t(size_t, len, free->length);
+				boffs = free->offset;
+			}
+			memcpy(chip->oob_poi + boffs, oob, bytes);
+			oob += bytes;
+		}
+		return oob;
+	}
+	default:
+		BUG();
+	}
+	return NULL;
 }
 
+#define NOTALIGNED(x)	(x & (chip->subpagesize - 1)) != 0
 
 /**
- * nand_write_oob - [MTD Interface] NAND write out-of-band
+ * nand_do_write_ops - [Internal] NAND write with ECC
  * @mtd:	MTD device structure
  * @to:		offset to write to
- * @len:	number of bytes to write
- * @retlen:	pointer to variable to store the number of written bytes
- * @buf:	the data to write
+ * @ops:	oob operations description structure
  *
- * NAND write out-of-band
+ * NAND write with ECC
  */
-static int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf)
+static int nand_do_write_ops(struct mtd_info *mtd, loff_t to,
+			     struct mtd_oob_ops *ops)
 {
-	int column, page, status, ret = -EIO, chipnr;
-	struct nand_chip *this = mtd->priv;
+	int chipnr, realpage, page, blockmask, column;
+	struct nand_chip *chip = mtd->priv;
+	uint32_t writelen = ops->len;
+	uint8_t *oob = ops->oobbuf;
+	uint8_t *buf = ops->datbuf;
+	int ret, subpage;
 
-	MTDDEBUG (MTD_DEBUG_LEVEL3, "nand_write_oob: to = 0x%08x, len = %i\n",
-	          (unsigned int) to, (int) len);
-
-	/* Shift to get page */
-	page = (int) (to >> this->page_shift);
-	chipnr = (int) (to >> this->chip_shift);
-
-	/* Mask to get column */
-	column = to & (mtd->oobsize - 1);
+	ops->retlen = 0;
+	if (!writelen)
+		return 0;
 
-	/* Initialize return length value */
-	*retlen = 0;
-
-	/* Do not allow write past end of page */
-	if ((column + len) > mtd->oobsize) {
-		MTDDEBUG (MTD_DEBUG_LEVEL0, "nand_write_oob: "
-		          "Attempt to write past end of page\n");
+	/* reject writes, which are not page aligned */
+	if (NOTALIGNED(to) || NOTALIGNED(ops->len)) {
+		printk(KERN_NOTICE "nand_write: "
+		       "Attempt to write not page aligned data\n");
 		return -EINVAL;
 	}
 
-	/* Grab the lock and see if the device is available */
-	nand_get_device (this, mtd, FL_WRITING);
+	column = to & (mtd->writesize - 1);
+	subpage = column || (writelen & (mtd->writesize - 1));
 
-	/* Select the NAND device */
-	this->select_chip(mtd, chipnr);
+	if (subpage && oob)
+		return -EINVAL;
 
-	/* Reset the chip. Some chips (like the Toshiba TC5832DC found
-	   in one of my DiskOnChip 2000 test units) will clear the whole
-	   data page too if we don't do this. I have no clue why, but
-	   I seem to have 'fixed' it in the doc2000 driver in
-	   August 1999.  dwmw2. */
-	this->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
+	chipnr = (int)(to >> chip->chip_shift);
+	chip->select_chip(mtd, chipnr);
 
 	/* Check, if it is write protected */
-	if (nand_check_wp(mtd))
-		goto out;
+	if (nand_check_wp(mtd)) {
+		printk (KERN_NOTICE "nand_do_write_ops: Device is write protected\n");
+		return -EIO;
+	}
 
-	/* Invalidate the page cache, if we write to the cached page */
-	if (page == this->pagebuf)
-		this->pagebuf = -1;
-
-	if (NAND_MUST_PAD(this)) {
-		/* Write out desired data */
-		this->cmdfunc (mtd, NAND_CMD_SEQIN, mtd->oobblock, page & this->pagemask);
-		if (!ffchars) {
-			if (!(ffchars = kmalloc (mtd->oobsize, GFP_KERNEL))) {
-				MTDDEBUG (MTD_DEBUG_LEVEL0, "nand_write_oob: "
-				          "No memory for padding array, "
-				          "need %d bytes", mtd->oobsize);
-				ret = -ENOMEM;
-				goto out;
-			}
-			memset(ffchars, 0xff, mtd->oobsize);
+	realpage = (int)(to >> chip->page_shift);
+	page = realpage & chip->pagemask;
+	blockmask = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;
+
+	/* Invalidate the page cache, when we write to the cached page */
+	if (to <= (chip->pagebuf << chip->page_shift) &&
+	    (chip->pagebuf << chip->page_shift) < (to + ops->len))
+		chip->pagebuf = -1;
+
+	/* If we're not given explicit OOB data, let it be 0xFF */
+	if (likely(!oob))
+		memset(chip->oob_poi, 0xff, mtd->oobsize);
+
+	while(1) {
+		int bytes = mtd->writesize;
+		int cached = writelen > bytes && page != blockmask;
+		uint8_t *wbuf = buf;
+
+		/* Partial page write ? */
+		if (unlikely(column || writelen < (mtd->writesize - 1))) {
+			cached = 0;
+			bytes = min_t(int, bytes - column, (int) writelen);
+			chip->pagebuf = -1;
+			memset(chip->buffers->databuf, 0xff, mtd->writesize);
+			memcpy(&chip->buffers->databuf[column], buf, bytes);
+			wbuf = chip->buffers->databuf;
 		}
-		/* prepad 0xff for partial programming */
-		this->write_buf(mtd, ffchars, column);
-		/* write data */
-		this->write_buf(mtd, buf, len);
-		/* postpad 0xff for partial programming */
-		this->write_buf(mtd, ffchars, mtd->oobsize - (len+column));
-	} else {
-		/* Write out desired data */
-		this->cmdfunc (mtd, NAND_CMD_SEQIN, mtd->oobblock + column, page & this->pagemask);
-		/* write data */
-		this->write_buf(mtd, buf, len);
-	}
-	/* Send command to program the OOB data */
-	this->cmdfunc (mtd, NAND_CMD_PAGEPROG, -1, -1);
 
-	status = this->waitfunc (mtd, this, FL_WRITING);
+		if (unlikely(oob))
+			oob = nand_fill_oob(chip, oob, ops);
 
-	/* See if device thinks it succeeded */
-	if (status & 0x01) {
-		MTDDEBUG (MTD_DEBUG_LEVEL0, "nand_write_oob: "
-		          "Failed write, page 0x%08x\n", page);
-		ret = -EIO;
-		goto out;
-	}
-	/* Return happy */
-	*retlen = len;
+		ret = chip->write_page(mtd, chip, wbuf, page, cached,
+				       (ops->mode == MTD_OOB_RAW));
+		if (ret)
+			break;
 
-#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
-	/* Send command to read back the data */
-	this->cmdfunc (mtd, NAND_CMD_READOOB, column, page & this->pagemask);
+		writelen -= bytes;
+		if (!writelen)
+			break;
 
-	if (this->verify_buf(mtd, buf, len)) {
-		MTDDEBUG (MTD_DEBUG_LEVEL0, "nand_write_oob: "
-		          "Failed write verify, page 0x%08x\n", page);
-		ret = -EIO;
-		goto out;
+		column = 0;
+		buf += bytes;
+		realpage++;
+
+		page = realpage & chip->pagemask;
+		/* Check, if we cross a chip boundary */
+		if (!page) {
+			chipnr++;
+			chip->select_chip(mtd, -1);
+			chip->select_chip(mtd, chipnr);
+		}
 	}
-#endif
-	ret = 0;
-out:
-	/* Deselect and wake up anyone waiting on the device */
-	nand_release_device(mtd);
 
+	ops->retlen = ops->len - writelen;
+	if (unlikely(oob))
+		ops->oobretlen = ops->ooblen;
 	return ret;
 }
 
-/* XXX U-BOOT XXX */
-#if 0
 /**
- * nand_writev - [MTD Interface] compabilty function for nand_writev_ecc
+ * nand_write - [MTD Interface] NAND write with ECC
  * @mtd:	MTD device structure
- * @vecs:	the iovectors to write
- * @count:	number of vectors
  * @to:		offset to write to
+ * @len:	number of bytes to write
  * @retlen:	pointer to variable to store the number of written bytes
+ * @buf:	the data to write
  *
- * NAND write with kvec. This just calls the ecc function
+ * NAND write with ECC
  */
-static int nand_writev (struct mtd_info *mtd, const struct kvec *vecs, unsigned long count,
-		loff_t to, size_t * retlen)
+static int nand_write(struct mtd_info *mtd, loff_t to, size_t len,
+			  size_t *retlen, const uint8_t *buf)
 {
-	return (nand_writev_ecc (mtd, vecs, count, to, retlen, NULL, NULL));
+	struct nand_chip *chip = mtd->priv;
+	int ret;
+
+	/* Do not allow reads past end of device */
+	if ((to + len) > mtd->size)
+		return -EINVAL;
+	if (!len)
+		return 0;
+
+	nand_get_device(chip, mtd, FL_WRITING);
+
+	chip->ops.len = len;
+	chip->ops.datbuf = (uint8_t *)buf;
+	chip->ops.oobbuf = NULL;
+
+	ret = nand_do_write_ops(mtd, to, &chip->ops);
+
+	*retlen = chip->ops.retlen;
+
+	nand_release_device(mtd);
+
+	return ret;
 }
 
 /**
- * nand_writev_ecc - [MTD Interface] write with iovec with ecc
+ * nand_do_write_oob - [MTD Interface] NAND write out-of-band
  * @mtd:	MTD device structure
- * @vecs:	the iovectors to write
- * @count:	number of vectors
  * @to:		offset to write to
- * @retlen:	pointer to variable to store the number of written bytes
- * @eccbuf:	filesystem supplied oob data buffer
- * @oobsel:	oob selection structure
+ * @ops:	oob operation description structure
  *
- * NAND write with iovec with ecc
+ * NAND write out-of-band
  */
-static int nand_writev_ecc (struct mtd_info *mtd, const struct kvec *vecs, unsigned long count,
-		loff_t to, size_t * retlen, u_char *eccbuf, struct nand_oobinfo *oobsel)
+static int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
+			     struct mtd_oob_ops *ops)
 {
-	int i, page, len, total_len, ret = -EIO, written = 0, chipnr;
-	int oob, numpages, autoplace = 0, startpage;
-	struct nand_chip *this = mtd->priv;
-	int	ppblock = (1 << (this->phys_erase_shift - this->page_shift));
-	u_char *oobbuf, *bufstart;
+	int chipnr, page, status, len;
+	struct nand_chip *chip = mtd->priv;
 
-	/* Preset written len for early exit */
-	*retlen = 0;
-
-	/* Calculate total length of data */
-	total_len = 0;
-	for (i = 0; i < count; i++)
-		total_len += (int) vecs[i].iov_len;
+	MTDDEBUG (MTD_DEBUG_LEVEL3, "nand_write_oob: to = 0x%08x, len = %i\n",
+	          (unsigned int)to, (int)ops->ooblen);
 
-	MTDDEBUG (MTD_DEBUG_LEVEL3,
-	          "nand_writev: to = 0x%08x, len = %i, count = %ld\n",
-	          (unsigned int) to, (unsigned int) total_len, count);
+	if (ops->mode == MTD_OOB_AUTO)
+		len = chip->ecc.layout->oobavail;
+	else
+		len = mtd->oobsize;
 
 	/* Do not allow write past end of page */
-	if ((to + total_len) > mtd->size) {
-		MTDDEBUG (MTD_DEBUG_LEVEL0,
-		          "nand_writev: Attempted write past end of device\n");
+	if ((ops->ooboffs + ops->ooblen) > len) {
+		MTDDEBUG (MTD_DEBUG_LEVEL0, "nand_write_oob: "
+		          "Attempt to write past end of page\n");
 		return -EINVAL;
 	}
 
-	/* reject writes, which are not page aligned */
-	if (NOTALIGNED (to) || NOTALIGNED(total_len)) {
-		printk (KERN_NOTICE "nand_write_ecc: Attempt to write not page aligned data\n");
+	if (unlikely(ops->ooboffs >= len)) {
+		MTDDEBUG (MTD_DEBUG_LEVEL0, "nand_read_oob: "
+		          "Attempt to start write outside oob\n");
 		return -EINVAL;
 	}
 
-	/* Grab the lock and see if the device is available */
-	nand_get_device (this, mtd, FL_WRITING);
+	/* Do not allow reads past end of device */
+	if (unlikely(to >= mtd->size ||
+		     ops->ooboffs + ops->ooblen >
+			((mtd->size >> chip->page_shift) -
+			 (to >> chip->page_shift)) * len)) {
+		MTDDEBUG (MTD_DEBUG_LEVEL0, "nand_read_oob: "
+		          "Attempt write beyond end of device\n");
+		return -EINVAL;
+	}
 
-	/* Get the current chip-nr */
-	chipnr = (int) (to >> this->chip_shift);
-	/* Select the NAND device */
-	this->select_chip(mtd, chipnr);
+	chipnr = (int)(to >> chip->chip_shift);
+	chip->select_chip(mtd, chipnr);
+
+	/* Shift to get page */
+	page = (int)(to >> chip->page_shift);
+
+	/*
+	 * Reset the chip. Some chips (like the Toshiba TC5832DC found in one
+	 * of my DiskOnChip 2000 test units) will clear the whole data page too
+	 * if we don't do this. I have no clue why, but I seem to have 'fixed'
+	 * it in the doc2000 driver in August 1999.  dwmw2.
+	 */
+	chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
 
 	/* Check, if it is write protected */
 	if (nand_check_wp(mtd))
-		goto out;
+		return -EROFS;
 
-	/* if oobsel is NULL, use chip defaults */
-	if (oobsel == NULL)
-		oobsel = &mtd->oobinfo;
+	/* Invalidate the page cache, if we write to the cached page */
+	if (page == chip->pagebuf)
+		chip->pagebuf = -1;
 
-	/* Autoplace of oob data ? Use the default placement scheme */
-	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE) {
-		oobsel = this->autooob;
-		autoplace = 1;
-	}
-	if (oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
-		autoplace = 1;
+	memset(chip->oob_poi, 0xff, mtd->oobsize);
+	nand_fill_oob(chip, ops->oobbuf, ops);
+	status = chip->ecc.write_oob(mtd, chip, page & chip->pagemask);
+	memset(chip->oob_poi, 0xff, mtd->oobsize);
 
-	/* Setup start page */
-	page = (int) (to >> this->page_shift);
-	/* Invalidate the page cache, if we write to the cached page */
-	if (page <= this->pagebuf && this->pagebuf < ((to + total_len) >> this->page_shift))
-		this->pagebuf = -1;
+	if (status)
+		return status;
 
-	startpage = page & this->pagemask;
+	ops->oobretlen = ops->ooblen;
 
-	/* Loop until all kvec' data has been written */
-	len = 0;
-	while (count) {
-		/* If the given tuple is >= pagesize then
-		 * write it out from the iov
-		 */
-		if ((vecs->iov_len - len) >= mtd->oobblock) {
-			/* Calc number of pages we can write
-			 * out of this iov in one go */
-			numpages = (vecs->iov_len - len) >> this->page_shift;
-			/* Do not cross block boundaries */
-			numpages = min (ppblock - (startpage & (ppblock - 1)), numpages);
-			oobbuf = nand_prepare_oobbuf (mtd, NULL, oobsel, autoplace, numpages);
-			bufstart = (u_char *)vecs->iov_base;
-			bufstart += len;
-			this->data_poi = bufstart;
-			oob = 0;
-			for (i = 1; i <= numpages; i++) {
-				/* Write one page. If this is the last page to write
-				 * then use the real pageprogram command, else select
-				 * cached programming if supported by the chip.
-				 */
-				ret = nand_write_page (mtd, this, page & this->pagemask,
-					&oobbuf[oob], oobsel, i != numpages);
-				if (ret)
-					goto out;
-				this->data_poi += mtd->oobblock;
-				len += mtd->oobblock;
-				oob += mtd->oobsize;
-				page++;
-			}
-			/* Check, if we have to switch to the next tuple */
-			if (len >= (int) vecs->iov_len) {
-				vecs++;
-				len = 0;
-				count--;
-			}
-		} else {
-			/* We must use the internal buffer, read data out of each
-			 * tuple until we have a full page to write
-			 */
-			int cnt = 0;
-			while (cnt < mtd->oobblock) {
-				if (vecs->iov_base != NULL && vecs->iov_len)
-					this->data_buf[cnt++] = ((u_char *) vecs->iov_base)[len++];
-				/* Check, if we have to switch to the next tuple */
-				if (len >= (int) vecs->iov_len) {
-					vecs++;
-					len = 0;
-					count--;
-				}
-			}
-			this->pagebuf = page;
-			this->data_poi = this->data_buf;
-			bufstart = this->data_poi;
-			numpages = 1;
-			oobbuf = nand_prepare_oobbuf (mtd, NULL, oobsel, autoplace, numpages);
-			ret = nand_write_page (mtd, this, page & this->pagemask,
-				oobbuf, oobsel, 0);
-			if (ret)
-				goto out;
-			page++;
-		}
+	return 0;
+}
 
-		this->data_poi = bufstart;
-		ret = nand_verify_pages (mtd, this, startpage, numpages, oobbuf, oobsel, chipnr, 0);
-		if (ret)
-			goto out;
+/**
+ * nand_write_oob - [MTD Interface] NAND write data and/or out-of-band
+ * @mtd:	MTD device structure
+ * @to:		offset to write to
+ * @ops:	oob operation description structure
+ */
+static int nand_write_oob(struct mtd_info *mtd, loff_t to,
+			  struct mtd_oob_ops *ops)
+{
+	struct nand_chip *chip = mtd->priv;
+	int ret = -ENOTSUPP;
 
-		written += mtd->oobblock * numpages;
-		/* All done ? */
-		if (!count)
-			break;
+	ops->retlen = 0;
 
-		startpage = page & this->pagemask;
-		/* Check, if we cross a chip boundary */
-		if (!startpage) {
-			chipnr++;
-			this->select_chip(mtd, -1);
-			this->select_chip(mtd, chipnr);
-		}
+	/* Do not allow writes past end of device */
+	if (ops->datbuf && (to + ops->len) > mtd->size) {
+		MTDDEBUG (MTD_DEBUG_LEVEL0, "nand_read_oob: "
+		          "Attempt read beyond end of device\n");
+		return -EINVAL;
 	}
-	ret = 0;
-out:
-	/* Deselect and wake up anyone waiting on the device */
-	nand_release_device(mtd);
 
-	*retlen = written;
+	nand_get_device(chip, mtd, FL_WRITING);
+
+	switch(ops->mode) {
+	case MTD_OOB_PLACE:
+	case MTD_OOB_AUTO:
+	case MTD_OOB_RAW:
+		break;
+
+	default:
+		goto out;
+	}
+
+	if (!ops->datbuf)
+		ret = nand_do_write_oob(mtd, to, ops);
+	else
+		ret = nand_do_write_ops(mtd, to, ops);
+
+ out:
+	nand_release_device(mtd);
 	return ret;
 }
-#endif
 
 /**
  * single_erease_cmd - [GENERIC] NAND standard block erase command function
@@ -2094,12 +2110,12 @@ out:
  *
  * Standard erase command for NAND chips
  */
-static void single_erase_cmd (struct mtd_info *mtd, int page)
+static void single_erase_cmd(struct mtd_info *mtd, int page)
 {
-	struct nand_chip *this = mtd->priv;
+	struct nand_chip *chip = mtd->priv;
 	/* Send commands to erase a block */
-	this->cmdfunc (mtd, NAND_CMD_ERASE1, -1, page);
-	this->cmdfunc (mtd, NAND_CMD_ERASE2, -1, -1);
+	chip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page);
+	chip->cmdfunc(mtd, NAND_CMD_ERASE2, -1, -1);
 }
 
 /**
@@ -2110,15 +2126,15 @@ static void single_erase_cmd (struct mtd_info *mtd, int page)
  * AND multi block erase command function
  * Erase 4 consecutive blocks
  */
-static void multi_erase_cmd (struct mtd_info *mtd, int page)
+static void multi_erase_cmd(struct mtd_info *mtd, int page)
 {
-	struct nand_chip *this = mtd->priv;
+	struct nand_chip *chip = mtd->priv;
 	/* Send commands to erase a block */
-	this->cmdfunc (mtd, NAND_CMD_ERASE1, -1, page++);
-	this->cmdfunc (mtd, NAND_CMD_ERASE1, -1, page++);
-	this->cmdfunc (mtd, NAND_CMD_ERASE1, -1, page++);
-	this->cmdfunc (mtd, NAND_CMD_ERASE1, -1, page);
-	this->cmdfunc (mtd, NAND_CMD_ERASE2, -1, -1);
+	chip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page++);
+	chip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page++);
+	chip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page++);
+	chip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page);
+	chip->cmdfunc(mtd, NAND_CMD_ERASE2, -1, -1);
 }
 
 /**
@@ -2128,35 +2144,39 @@ static void multi_erase_cmd (struct mtd_info *mtd, int page)
  *
  * Erase one ore more blocks
  */
-static int nand_erase (struct mtd_info *mtd, struct erase_info *instr)
+static int nand_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
-	return nand_erase_nand (mtd, instr, 0);
+	return nand_erase_nand(mtd, instr, 0);
 }
 
+#define BBT_PAGE_MASK	0xffffff3f
 /**
- * nand_erase_intern - [NAND Interface] erase block(s)
+ * nand_erase_nand - [Internal] erase block(s)
  * @mtd:	MTD device structure
  * @instr:	erase instruction
  * @allowbbt:	allow erasing the bbt area
  *
  * Erase one ore more blocks
  */
-int nand_erase_nand (struct mtd_info *mtd, struct erase_info *instr, int allowbbt)
+int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
+		    int allowbbt)
 {
 	int page, len, status, pages_per_block, ret, chipnr;
-	struct nand_chip *this = mtd->priv;
+	struct nand_chip *chip = mtd->priv;
+	int rewrite_bbt[CONFIG_SYS_NAND_MAX_CHIPS]={0};
+	unsigned int bbt_masked_page = 0xffffffff;
 
 	MTDDEBUG (MTD_DEBUG_LEVEL3, "nand_erase: start = 0x%08x, len = %i\n",
 	          (unsigned int) instr->addr, (unsigned int) instr->len);
 
 	/* Start address must align on block boundary */
-	if (instr->addr & ((1 << this->phys_erase_shift) - 1)) {
+	if (instr->addr & ((1 << chip->phys_erase_shift) - 1)) {
 		MTDDEBUG (MTD_DEBUG_LEVEL0, "nand_erase: Unaligned address\n");
 		return -EINVAL;
 	}
 
 	/* Length must align on block boundary */
-	if (instr->len & ((1 << this->phys_erase_shift) - 1)) {
+	if (instr->len & ((1 << chip->phys_erase_shift) - 1)) {
 		MTDDEBUG (MTD_DEBUG_LEVEL0,
 		          "nand_erase: Length not block aligned\n");
 		return -EINVAL;
@@ -2172,19 +2192,18 @@ int nand_erase_nand (struct mtd_info *mtd, struct erase_info *instr, int allowbb
 	instr->fail_addr = 0xffffffff;
 
 	/* Grab the lock and see if the device is available */
-	nand_get_device (this, mtd, FL_ERASING);
+	nand_get_device(chip, mtd, FL_ERASING);
 
 	/* Shift to get first page */
-	page = (int) (instr->addr >> this->page_shift);
-	chipnr = (int) (instr->addr >> this->chip_shift);
+	page = (int)(instr->addr >> chip->page_shift);
+	chipnr = (int)(instr->addr >> chip->chip_shift);
 
 	/* Calculate pages in each block */
-	pages_per_block = 1 << (this->phys_erase_shift - this->page_shift);
+	pages_per_block = 1 << (chip->phys_erase_shift - chip->page_shift);
 
 	/* Select the NAND device */
-	this->select_chip(mtd, chipnr);
+	chip->select_chip(mtd, chipnr);
 
-	/* Check the WP bit */
 	/* Check, if it is write protected */
 	if (nand_check_wp(mtd)) {
 		MTDDEBUG (MTD_DEBUG_LEVEL0,
@@ -2193,60 +2212,118 @@ int nand_erase_nand (struct mtd_info *mtd, struct erase_info *instr, int allowbb
 		goto erase_exit;
 	}
 
+	/*
+	 * If BBT requires refresh, set the BBT page mask to see if the BBT
+	 * should be rewritten. Otherwise the mask is set to 0xffffffff which
+	 * can not be matched. This is also done when the bbt is actually
+	 * erased to avoid recusrsive updates
+	 */
+	if (chip->options & BBT_AUTO_REFRESH && !allowbbt)
+		bbt_masked_page = chip->bbt_td->pages[chipnr] & BBT_PAGE_MASK;
+
 	/* Loop through the pages */
 	len = instr->len;
 
 	instr->state = MTD_ERASING;
 
 	while (len) {
-#ifndef NAND_ALLOW_ERASE_ALL
-		/* Check if we have a bad block, we do not erase bad blocks ! */
-		if (nand_block_checkbad(mtd, ((loff_t) page) << this->page_shift, 0, allowbbt)) {
-			printk (KERN_WARNING "nand_erase: attempt to erase a bad block at page 0x%08x\n", page);
+		/*
+		 * heck if we have a bad block, we do not erase bad blocks !
+		 */
+		if (nand_block_checkbad(mtd, ((loff_t) page) <<
+					chip->page_shift, 0, allowbbt)) {
+			printk(KERN_WARNING "nand_erase: attempt to erase a "
+			       "bad block at page 0x%08x\n", page);
 			instr->state = MTD_ERASE_FAILED;
 			goto erase_exit;
 		}
-#endif
-		/* Invalidate the page cache, if we erase the block which contains
-		   the current cached page */
-		if (page <= this->pagebuf && this->pagebuf < (page + pages_per_block))
-			this->pagebuf = -1;
 
-		this->erase_cmd (mtd, page & this->pagemask);
+		/*
+		 * Invalidate the page cache, if we erase the block which
+		 * contains the current cached page
+		 */
+		if (page <= chip->pagebuf && chip->pagebuf <
+		    (page + pages_per_block))
+			chip->pagebuf = -1;
+
+		chip->erase_cmd(mtd, page & chip->pagemask);
 
-		status = this->waitfunc (mtd, this, FL_ERASING);
+		status = chip->waitfunc(mtd, chip);
+
+		/*
+		 * See if operation failed and additional status checks are
+		 * available
+		 */
+		if ((status & NAND_STATUS_FAIL) && (chip->errstat))
+			status = chip->errstat(mtd, chip, FL_ERASING,
+					       status, page);
 
 		/* See if block erase succeeded */
-		if (status & 0x01) {
+		if (status & NAND_STATUS_FAIL) {
 			MTDDEBUG (MTD_DEBUG_LEVEL0, "nand_erase: "
 			          "Failed erase, page 0x%08x\n", page);
 			instr->state = MTD_ERASE_FAILED;
-			instr->fail_addr = (page << this->page_shift);
+			instr->fail_addr = (page << chip->page_shift);
 			goto erase_exit;
 		}
 
+		/*
+		 * If BBT requires refresh, set the BBT rewrite flag to the
+		 * page being erased
+		 */
+		if (bbt_masked_page != 0xffffffff &&
+		    (page & BBT_PAGE_MASK) == bbt_masked_page)
+			    rewrite_bbt[chipnr] = (page << chip->page_shift);
+
 		/* Increment page address and decrement length */
-		len -= (1 << this->phys_erase_shift);
+		len -= (1 << chip->phys_erase_shift);
 		page += pages_per_block;
 
 		/* Check, if we cross a chip boundary */
-		if (len && !(page & this->pagemask)) {
+		if (len && !(page & chip->pagemask)) {
 			chipnr++;
-			this->select_chip(mtd, -1);
-			this->select_chip(mtd, chipnr);
+			chip->select_chip(mtd, -1);
+			chip->select_chip(mtd, chipnr);
+
+			/*
+			 * If BBT requires refresh and BBT-PERCHIP, set the BBT
+			 * page mask to see if this BBT should be rewritten
+			 */
+			if (bbt_masked_page != 0xffffffff &&
+			    (chip->bbt_td->options & NAND_BBT_PERCHIP))
+				bbt_masked_page = chip->bbt_td->pages[chipnr] &
+					BBT_PAGE_MASK;
 		}
 	}
 	instr->state = MTD_ERASE_DONE;
 
-erase_exit:
+ erase_exit:
 
 	ret = instr->state == MTD_ERASE_DONE ? 0 : -EIO;
+
+	/* Deselect and wake up anyone waiting on the device */
+	nand_release_device(mtd);
+
 	/* Do call back function */
 	if (!ret)
 		mtd_erase_callback(instr);
 
-	/* Deselect and wake up anyone waiting on the device */
-	nand_release_device(mtd);
+	/*
+	 * If BBT requires refresh and erase was successful, rewrite any
+	 * selected bad block tables
+	 */
+	if (bbt_masked_page == 0xffffffff || ret)
+		return ret;
+
+	for (chipnr = 0; chipnr < chip->numchips; chipnr++) {
+		if (!rewrite_bbt[chipnr])
+			continue;
+		/* update the BBT for chip */
+		MTDDEBUG (MTD_DEBUG_LEVEL0, "nand_erase_nand: nand_update_bbt "
+		          "(%d:0x%0x 0x%0x)\n", chipnr, rewrite_bbt[chipnr],
+		          chip->bbt_td->pages[chipnr]);
+		nand_update_bbt(mtd, rewrite_bbt[chipnr]);
+	}
 
 	/* Return more or less happy */
 	return ret;
@@ -2258,41 +2335,40 @@ erase_exit:
  *
  * Sync is actually a wait for chip ready function
  */
-static void nand_sync (struct mtd_info *mtd)
+static void nand_sync(struct mtd_info *mtd)
 {
-	struct nand_chip *this = mtd->priv;
+	struct nand_chip *chip = mtd->priv;
 
 	MTDDEBUG (MTD_DEBUG_LEVEL3, "nand_sync: called\n");
 
 	/* Grab the lock and see if the device is available */
-	nand_get_device (this, mtd, FL_SYNCING);
+	nand_get_device(chip, mtd, FL_SYNCING);
 	/* Release it and go back */
-	nand_release_device (mtd);
+	nand_release_device(mtd);
 }
 
-
 /**
- * nand_block_isbad - [MTD Interface] Check whether the block at the given offset is bad
+ * nand_block_isbad - [MTD Interface] Check if block at offset is bad
  * @mtd:	MTD device structure
- * @ofs:	offset relative to mtd start
+ * @offs:	offset relative to mtd start
  */
-static int nand_block_isbad (struct mtd_info *mtd, loff_t ofs)
+static int nand_block_isbad(struct mtd_info *mtd, loff_t offs)
 {
 	/* Check for invalid offset */
-	if (ofs > mtd->size)
+	if (offs > mtd->size)
 		return -EINVAL;
 
-	return nand_block_checkbad (mtd, ofs, 1, 0);
+	return nand_block_checkbad(mtd, offs, 1, 0);
 }
 
 /**
- * nand_block_markbad - [MTD Interface] Mark the block at the given offset as bad
+ * nand_block_markbad - [MTD Interface] Mark block at the given offset as bad
  * @mtd:	MTD device structure
  * @ofs:	offset relative to mtd start
  */
-static int nand_block_markbad (struct mtd_info *mtd, loff_t ofs)
+static int nand_block_markbad(struct mtd_info *mtd, loff_t ofs)
 {
-	struct nand_chip *this = mtd->priv;
+	struct nand_chip *chip = mtd->priv;
 	int ret;
 
 	if ((ret = nand_block_isbad(mtd, ofs))) {
@@ -2302,419 +2378,587 @@ static int nand_block_markbad (struct mtd_info *mtd, loff_t ofs)
 		return ret;
 	}
 
-	return this->block_markbad(mtd, ofs);
+	return chip->block_markbad(mtd, ofs);
 }
 
 /**
- * nand_scan - [NAND Interface] Scan for the NAND device
+ * nand_suspend - [MTD Interface] Suspend the NAND flash
  * @mtd:	MTD device structure
- * @maxchips:	Number of chips to scan for
- *
- * This fills out all the not initialized function pointers
- * with the defaults.
- * The flash ID is read and the mtd/chip structures are
- * filled with the appropriate values. Buffers are allocated if
- * they are not provided by the board driver
- *
  */
-int nand_scan (struct mtd_info *mtd, int maxchips)
+static int nand_suspend(struct mtd_info *mtd)
 {
-	int i, j, nand_maf_id, nand_dev_id, busw;
-	struct nand_chip *this = mtd->priv;
+	struct nand_chip *chip = mtd->priv;
 
-	/* Get buswidth to select the correct functions*/
-	busw = this->options & NAND_BUSWIDTH_16;
+	return nand_get_device(chip, mtd, FL_PM_SUSPENDED);
+}
+
+/**
+ * nand_resume - [MTD Interface] Resume the NAND flash
+ * @mtd:	MTD device structure
+ */
+static void nand_resume(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	if (chip->state == FL_PM_SUSPENDED)
+		nand_release_device(mtd);
+	else
+		printk(KERN_ERR "nand_resume() called for a chip which is not "
+		       "in suspended state\n");
+}
 
+/*
+ * Set default functions
+ */
+static void nand_set_defaults(struct nand_chip *chip, int busw)
+{
 	/* check for proper chip_delay setup, set 20us if not */
-	if (!this->chip_delay)
-		this->chip_delay = 20;
+	if (!chip->chip_delay)
+		chip->chip_delay = 20;
 
 	/* check, if a user supplied command function given */
-	if (this->cmdfunc == NULL)
-		this->cmdfunc = nand_command;
+	if (chip->cmdfunc == NULL)
+		chip->cmdfunc = nand_command;
 
 	/* check, if a user supplied wait function given */
-	if (this->waitfunc == NULL)
-		this->waitfunc = nand_wait;
-
-	if (!this->select_chip)
-		this->select_chip = nand_select_chip;
-	if (!this->write_byte)
-		this->write_byte = busw ? nand_write_byte16 : nand_write_byte;
-	if (!this->read_byte)
-		this->read_byte = busw ? nand_read_byte16 : nand_read_byte;
-	if (!this->write_word)
-		this->write_word = nand_write_word;
-	if (!this->read_word)
-		this->read_word = nand_read_word;
-	if (!this->block_bad)
-		this->block_bad = nand_block_bad;
-	if (!this->block_markbad)
-		this->block_markbad = nand_default_block_markbad;
-	if (!this->write_buf)
-		this->write_buf = busw ? nand_write_buf16 : nand_write_buf;
-	if (!this->read_buf)
-		this->read_buf = busw ? nand_read_buf16 : nand_read_buf;
-	if (!this->verify_buf)
-		this->verify_buf = busw ? nand_verify_buf16 : nand_verify_buf;
-	if (!this->scan_bbt)
-		this->scan_bbt = nand_default_bbt;
+	if (chip->waitfunc == NULL)
+		chip->waitfunc = nand_wait;
+
+	if (!chip->select_chip)
+		chip->select_chip = nand_select_chip;
+	if (!chip->read_byte)
+		chip->read_byte = busw ? nand_read_byte16 : nand_read_byte;
+	if (!chip->read_word)
+		chip->read_word = nand_read_word;
+	if (!chip->block_bad)
+		chip->block_bad = nand_block_bad;
+	if (!chip->block_markbad)
+		chip->block_markbad = nand_default_block_markbad;
+	if (!chip->write_buf)
+		chip->write_buf = busw ? nand_write_buf16 : nand_write_buf;
+	if (!chip->read_buf)
+		chip->read_buf = busw ? nand_read_buf16 : nand_read_buf;
+	if (!chip->verify_buf)
+		chip->verify_buf = busw ? nand_verify_buf16 : nand_verify_buf;
+	if (!chip->scan_bbt)
+		chip->scan_bbt = nand_default_bbt;
+
+	if (!chip->controller) {
+		chip->controller = &chip->hwcontrol;
+
+		/* XXX U-BOOT XXX */
+#if 0
+		spin_lock_init(&chip->controller->lock);
+		init_waitqueue_head(&chip->controller->wq);
+#endif
+	}
+
+}
+
+/*
+ * Get the flash and manufacturer id and lookup if the type is supported
+ */
+static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
+						  struct nand_chip *chip,
+						  int busw, int *maf_id)
+{
+	struct nand_flash_dev *type = NULL;
+	int i, dev_id, maf_idx;
+	int tmp_id, tmp_manf;
 
 	/* Select the device */
-	this->select_chip(mtd, 0);
+	chip->select_chip(mtd, 0);
+
+	/*
+	 * Reset the chip, required by some chips (e.g. Micron MT29FxGxxxxx)
+	 * after power-up
+	 */
+	chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
 
 	/* Send the command for reading device ID */
-	this->cmdfunc (mtd, NAND_CMD_READID, 0x00, -1);
+	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
 
 	/* Read manufacturer and device IDs */
-	nand_maf_id = this->read_byte(mtd);
-	nand_dev_id = this->read_byte(mtd);
+	*maf_id = chip->read_byte(mtd);
+	dev_id = chip->read_byte(mtd);
 
-	/* Print and store flash device information */
-	for (i = 0; nand_flash_ids[i].name != NULL; i++) {
+	/* Try again to make sure, as some systems the bus-hold or other
+	 * interface concerns can cause random data which looks like a
+	 * possibly credible NAND flash to appear. If the two results do
+	 * not match, ignore the device completely.
+	 */
 
-		if (nand_dev_id != nand_flash_ids[i].id)
-			continue;
+	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
 
-		if (!mtd->name) mtd->name = nand_flash_ids[i].name;
-		this->chipsize = nand_flash_ids[i].chipsize << 20;
-
-		/* New devices have all the information in additional id bytes */
-		if (!nand_flash_ids[i].pagesize) {
-			int extid;
-			/* The 3rd id byte contains non relevant data ATM */
-			extid = this->read_byte(mtd);
-			/* The 4th id byte is the important one */
-			extid = this->read_byte(mtd);
-			/* Calc pagesize */
-			mtd->oobblock = 1024 << (extid & 0x3);
-			extid >>= 2;
-			/* Calc oobsize */
-			mtd->oobsize = (8 << (extid & 0x01)) * (mtd->oobblock / 512);
-			extid >>= 2;
-			/* Calc blocksize. Blocksize is multiples of 64KiB */
-			mtd->erasesize = (64 * 1024)  << (extid & 0x03);
-			extid >>= 2;
-			/* Get buswidth information */
-			busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;
+	/* Read manufacturer and device IDs */
 
-		} else {
-			/* Old devices have this data hardcoded in the
-			 * device id table */
-			mtd->erasesize = nand_flash_ids[i].erasesize;
-			mtd->oobblock = nand_flash_ids[i].pagesize;
-			mtd->oobsize = mtd->oobblock / 32;
-			busw = nand_flash_ids[i].options & NAND_BUSWIDTH_16;
-		}
+	tmp_manf = chip->read_byte(mtd);
+	tmp_id = chip->read_byte(mtd);
+
+	if (tmp_manf != *maf_id || tmp_id != dev_id) {
+		printk(KERN_INFO "%s: second ID read did not match "
+		       "%02x,%02x against %02x,%02x\n", __func__,
+		       *maf_id, dev_id, tmp_manf, tmp_id);
+		return ERR_PTR(-ENODEV);
+	}
 
-		/* Check, if buswidth is correct. Hardware drivers should set
-		 * this correct ! */
-		if (busw != (this->options & NAND_BUSWIDTH_16)) {
-			printk (KERN_INFO "NAND device: Manufacturer ID:"
-				" 0x%02x, Chip ID: 0x%02x (%s %s)\n", nand_maf_id, nand_dev_id,
-				nand_manuf_ids[i].name , mtd->name);
-			printk (KERN_WARNING
-				"NAND bus width %d instead %d bit\n",
-					(this->options & NAND_BUSWIDTH_16) ? 16 : 8,
-					busw ? 16 : 8);
-			this->select_chip(mtd, -1);
-			return 1;
+	/* Lookup the flash id */
+	for (i = 0; nand_flash_ids[i].name != NULL; i++) {
+		if (dev_id == nand_flash_ids[i].id) {
+			type =  &nand_flash_ids[i];
+			break;
 		}
+	}
 
-		/* Calculate the address shift from the page size */
-		this->page_shift = ffs(mtd->oobblock) - 1;
-		this->bbt_erase_shift = this->phys_erase_shift = ffs(mtd->erasesize) - 1;
-		this->chip_shift = ffs(this->chipsize) - 1;
-
-		/* Set the bad block position */
-		this->badblockpos = mtd->oobblock > 512 ?
-			NAND_LARGE_BADBLOCK_POS : NAND_SMALL_BADBLOCK_POS;
-
-		/* Get chip options, preserve non chip based options */
-		this->options &= ~NAND_CHIPOPTIONS_MSK;
-		this->options |= nand_flash_ids[i].options & NAND_CHIPOPTIONS_MSK;
-		/* Set this as a default. Board drivers can override it, if neccecary */
-		this->options |= NAND_NO_AUTOINCR;
-		/* Check if this is a not a samsung device. Do not clear the options
-		 * for chips which are not having an extended id.
-		 */
-		if (nand_maf_id != NAND_MFR_SAMSUNG && !nand_flash_ids[i].pagesize)
-			this->options &= ~NAND_SAMSUNG_LP_OPTIONS;
+	if (!type)
+		return ERR_PTR(-ENODEV);
+
+	if (!mtd->name)
+		mtd->name = type->name;
+
+	chip->chipsize = type->chipsize << 20;
+
+	/* Newer devices have all the information in additional id bytes */
+	if (!type->pagesize) {
+		int extid;
+		/* The 3rd id byte holds MLC / multichip data */
+		chip->cellinfo = chip->read_byte(mtd);
+		/* The 4th id byte is the important one */
+		extid = chip->read_byte(mtd);
+		/* Calc pagesize */
+		mtd->writesize = 1024 << (extid & 0x3);
+		extid >>= 2;
+		/* Calc oobsize */
+		mtd->oobsize = (8 << (extid & 0x01)) * (mtd->writesize >> 9);
+		extid >>= 2;
+		/* Calc blocksize. Blocksize is multiples of 64KiB */
+		mtd->erasesize = (64 * 1024) << (extid & 0x03);
+		extid >>= 2;
+		/* Get buswidth information */
+		busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;
 
-		/* Check for AND chips with 4 page planes */
-		if (this->options & NAND_4PAGE_ARRAY)
-			this->erase_cmd = multi_erase_cmd;
-		else
-			this->erase_cmd = single_erase_cmd;
+	} else {
+		/*
+		 * Old devices have chip data hardcoded in the device id table
+		 */
+		mtd->erasesize = type->erasesize;
+		mtd->writesize = type->pagesize;
+		mtd->oobsize = mtd->writesize / 32;
+		busw = type->options & NAND_BUSWIDTH_16;
+	}
 
-		/* Do not replace user supplied command function ! */
-		if (mtd->oobblock > 512 && this->cmdfunc == nand_command)
-			this->cmdfunc = nand_command_lp;
+	/* Try to identify manufacturer */
+	for (maf_idx = 0; nand_manuf_ids[maf_idx].id != 0x0; maf_idx++) {
+		if (nand_manuf_ids[maf_idx].id == *maf_id)
+			break;
+	}
 
-		/* Try to identify manufacturer */
-		for (j = 0; nand_manuf_ids[j].id != 0x0; j++) {
-			if (nand_manuf_ids[j].id == nand_maf_id)
-				break;
-		}
-		break;
+	/*
+	 * Check, if buswidth is correct. Hardware drivers should set
+	 * chip correct !
+	 */
+	if (busw != (chip->options & NAND_BUSWIDTH_16)) {
+		printk(KERN_INFO "NAND device: Manufacturer ID:"
+		       " 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id,
+		       dev_id, nand_manuf_ids[maf_idx].name, mtd->name);
+		printk(KERN_WARNING "NAND bus width %d instead %d bit\n",
+		       (chip->options & NAND_BUSWIDTH_16) ? 16 : 8,
+		       busw ? 16 : 8);
+		return ERR_PTR(-EINVAL);
 	}
 
-	if (!nand_flash_ids[i].name) {
-#ifndef CFG_NAND_QUIET_TEST
-		printk (KERN_WARNING "No NAND device found!!!\n");
+	/* Calculate the address shift from the page size */
+	chip->page_shift = ffs(mtd->writesize) - 1;
+	/* Convert chipsize to number of pages per chip -1. */
+	chip->pagemask = (chip->chipsize >> chip->page_shift) - 1;
+
+	chip->bbt_erase_shift = chip->phys_erase_shift =
+		ffs(mtd->erasesize) - 1;
+	chip->chip_shift = ffs(chip->chipsize) - 1;
+
+	/* Set the bad block position */
+	chip->badblockpos = mtd->writesize > 512 ?
+		NAND_LARGE_BADBLOCK_POS : NAND_SMALL_BADBLOCK_POS;
+
+	/* Get chip options, preserve non chip based options */
+	chip->options &= ~NAND_CHIPOPTIONS_MSK;
+	chip->options |= type->options & NAND_CHIPOPTIONS_MSK;
+
+	/*
+	 * Set chip as a default. Board drivers can override it, if necessary
+	 */
+	chip->options |= NAND_NO_AUTOINCR;
+
+	/* Check if chip is a not a samsung device. Do not clear the
+	 * options for chips which are not having an extended id.
+	 */
+	if (*maf_id != NAND_MFR_SAMSUNG && !type->pagesize)
+		chip->options &= ~NAND_SAMSUNG_LP_OPTIONS;
+
+	/* Check for AND chips with 4 page planes */
+	if (chip->options & NAND_4PAGE_ARRAY)
+		chip->erase_cmd = multi_erase_cmd;
+	else
+		chip->erase_cmd = single_erase_cmd;
+
+	/* Do not replace user supplied command function ! */
+	if (mtd->writesize > 512 && chip->cmdfunc == nand_command)
+		chip->cmdfunc = nand_command_lp;
+
+	MTDDEBUG (MTD_DEBUG_LEVEL0, "NAND device: Manufacturer ID:"
+	          " 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id, dev_id,
+	          nand_manuf_ids[maf_idx].name, type->name);
+
+	return type;
+}
+
+/**
+ * nand_scan_ident - [NAND Interface] Scan for the NAND device
+ * @mtd:	     MTD device structure
+ * @maxchips:	     Number of chips to scan for
+ *
+ * This is the first phase of the normal nand_scan() function. It
+ * reads the flash ID and sets up MTD fields accordingly.
+ *
+ * The mtd->owner field must be set to the module of the caller.
+ */
+int nand_scan_ident(struct mtd_info *mtd, int maxchips)
+{
+	int i, busw, nand_maf_id;
+	struct nand_chip *chip = mtd->priv;
+	struct nand_flash_dev *type;
+
+	/* Get buswidth to select the correct functions */
+	busw = chip->options & NAND_BUSWIDTH_16;
+	/* Set the default functions */
+	nand_set_defaults(chip, busw);
+
+	/* Read the flash type */
+	type = nand_get_flash_type(mtd, chip, busw, &nand_maf_id);
+
+	if (IS_ERR(type)) {
+#ifndef CONFIG_SYS_NAND_QUIET_TEST
+		printk(KERN_WARNING "No NAND device found!!!\n");
 #endif
-		this->select_chip(mtd, -1);
-		return 1;
+		chip->select_chip(mtd, -1);
+		return PTR_ERR(type);
 	}
 
-	for (i=1; i < maxchips; i++) {
-		this->select_chip(mtd, i);
-
+	/* Check for a chip array */
+	for (i = 1; i < maxchips; i++) {
+		chip->select_chip(mtd, i);
+		/* See comment in nand_get_flash_type for reset */
+		chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
 		/* Send the command for reading device ID */
-		this->cmdfunc (mtd, NAND_CMD_READID, 0x00, -1);
-
+		chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
 		/* Read manufacturer and device IDs */
-		if (nand_maf_id != this->read_byte(mtd) ||
-		    nand_dev_id != this->read_byte(mtd))
+		if (nand_maf_id != chip->read_byte(mtd) ||
+		    type->id != chip->read_byte(mtd))
 			break;
 	}
+#ifdef DEBUG
 	if (i > 1)
 		printk(KERN_INFO "%d NAND chips detected\n", i);
-
-	/* Allocate buffers, if neccecary */
-	if (!this->oob_buf) {
-		size_t len;
-		len = mtd->oobsize << (this->phys_erase_shift - this->page_shift);
-		this->oob_buf = kmalloc (len, GFP_KERNEL);
-		if (!this->oob_buf) {
-			printk (KERN_ERR "nand_scan(): Cannot allocate oob_buf\n");
-			return -ENOMEM;
-		}
-		this->options |= NAND_OOBBUF_ALLOC;
-	}
-
-	if (!this->data_buf) {
-		size_t len;
-		len = mtd->oobblock + mtd->oobsize;
-		this->data_buf = kmalloc (len, GFP_KERNEL);
-		if (!this->data_buf) {
-			if (this->options & NAND_OOBBUF_ALLOC)
-				kfree (this->oob_buf);
-			printk (KERN_ERR "nand_scan(): Cannot allocate data_buf\n");
-			return -ENOMEM;
-		}
-		this->options |= NAND_DATABUF_ALLOC;
-	}
+#endif
 
 	/* Store the number of chips and calc total size for mtd */
-	this->numchips = i;
-	mtd->size = i * this->chipsize;
-	/* Convert chipsize to number of pages per chip -1. */
-	this->pagemask = (this->chipsize >> this->page_shift) - 1;
-	/* Preset the internal oob buffer */
-	memset(this->oob_buf, 0xff, mtd->oobsize << (this->phys_erase_shift - this->page_shift));
-
-	/* If no default placement scheme is given, select an
-	 * appropriate one */
-	if (!this->autooob) {
-		/* Select the appropriate default oob placement scheme for
-		 * placement agnostic filesystems */
+	chip->numchips = i;
+	mtd->size = i * chip->chipsize;
+
+	return 0;
+}
+
+
+/**
+ * nand_scan_tail - [NAND Interface] Scan for the NAND device
+ * @mtd:	    MTD device structure
+ * @maxchips:	    Number of chips to scan for
+ *
+ * This is the second phase of the normal nand_scan() function. It
+ * fills out all the uninitialized function pointers with the defaults
+ * and scans for a bad block table if appropriate.
+ */
+int nand_scan_tail(struct mtd_info *mtd)
+{
+	int i;
+	struct nand_chip *chip = mtd->priv;
+
+	if (!(chip->options & NAND_OWN_BUFFERS))
+		chip->buffers = kmalloc(sizeof(*chip->buffers), GFP_KERNEL);
+	if (!chip->buffers)
+		return -ENOMEM;
+
+	/* Set the internal oob buffer location, just after the page data */
+	chip->oob_poi = chip->buffers->databuf + mtd->writesize;
+
+	/*
+	 * If no default placement scheme is given, select an appropriate one
+	 */
+	if (!chip->ecc.layout) {
 		switch (mtd->oobsize) {
 		case 8:
-			this->autooob = &nand_oob_8;
+			chip->ecc.layout = &nand_oob_8;
 			break;
 		case 16:
-			this->autooob = &nand_oob_16;
+			chip->ecc.layout = &nand_oob_16;
 			break;
 		case 64:
-			this->autooob = &nand_oob_64;
+			chip->ecc.layout = &nand_oob_64;
 			break;
 		case 128:
-			this->autooob = &nand_oob_128;
+			chip->ecc.layout = &nand_oob_128;
 			break;
 		default:
-			printk (KERN_WARNING "No oob scheme defined for oobsize %d\n",
-				mtd->oobsize);
+			printk(KERN_WARNING "No oob scheme defined for "
+			       "oobsize %d\n", mtd->oobsize);
 /*			BUG(); */
 		}
 	}
 
-	/* The number of bytes available for the filesystem to place fs dependend
-	 * oob data */
-	mtd->oobavail = 0;
-	for (i=0; this->autooob->oobfree[i][1]; i++)
-		mtd->oobavail += this->autooob->oobfree[i][1];
+	if (!chip->write_page)
+		chip->write_page = nand_write_page;
 
 	/*
-	 * check ECC mode, default to software
-	 * if 3byte/512byte hardware ECC is selected and we have 256 byte pagesize
-	 * fallback to software ECC
-	*/
-	this->eccsize = 256;	/* set default eccsize */
-	this->eccbytes = 3;
-
-	switch (this->eccmode) {
-	case NAND_ECC_HW12_2048:
-		if (mtd->oobblock < 2048) {
-			printk(KERN_WARNING "2048 byte HW ECC not possible on %d byte page size, fallback to SW ECC\n",
-			       mtd->oobblock);
-			this->eccmode = NAND_ECC_SOFT;
-			this->calculate_ecc = nand_calculate_ecc;
-			this->correct_data = nand_correct_data;
-		} else
-			this->eccsize = 2048;
-		break;
-
-	case NAND_ECC_HW3_512:
-	case NAND_ECC_HW6_512:
-	case NAND_ECC_HW8_512:
-		if (mtd->oobblock == 256) {
-			printk (KERN_WARNING "512 byte HW ECC not possible on 256 Byte pagesize, fallback to SW ECC \n");
-			this->eccmode = NAND_ECC_SOFT;
-			this->calculate_ecc = nand_calculate_ecc;
-			this->correct_data = nand_correct_data;
-		} else
-			this->eccsize = 512; /* set eccsize to 512 */
-		break;
+	 * check ECC mode, default to software if 3byte/512byte hardware ECC is
+	 * selected and we have 256 byte pagesize fallback to software ECC
+	 */
+	if (!chip->ecc.read_page_raw)
+		chip->ecc.read_page_raw = nand_read_page_raw;
+	if (!chip->ecc.write_page_raw)
+		chip->ecc.write_page_raw = nand_write_page_raw;
+
+	switch (chip->ecc.mode) {
+	case NAND_ECC_HW:
+		/* Use standard hwecc read page function ? */
+		if (!chip->ecc.read_page)
+			chip->ecc.read_page = nand_read_page_hwecc;
+		if (!chip->ecc.write_page)
+			chip->ecc.write_page = nand_write_page_hwecc;
+		if (!chip->ecc.read_oob)
+			chip->ecc.read_oob = nand_read_oob_std;
+		if (!chip->ecc.write_oob)
+			chip->ecc.write_oob = nand_write_oob_std;
+
+	case NAND_ECC_HW_SYNDROME:
+		if ((!chip->ecc.calculate || !chip->ecc.correct ||
+		     !chip->ecc.hwctl) &&
+		    (!chip->ecc.read_page ||
+		     chip->ecc.read_page == nand_read_page_hwecc ||
+		     !chip->ecc.write_page ||
+		     chip->ecc.write_page == nand_write_page_hwecc)) {
+			printk(KERN_WARNING "No ECC functions supplied, "
+			       "Hardware ECC not possible\n");
+			BUG();
+		}
+		/* Use standard syndrome read/write page function ? */
+		if (!chip->ecc.read_page)
+			chip->ecc.read_page = nand_read_page_syndrome;
+		if (!chip->ecc.write_page)
+			chip->ecc.write_page = nand_write_page_syndrome;
+		if (!chip->ecc.read_oob)
+			chip->ecc.read_oob = nand_read_oob_syndrome;
+		if (!chip->ecc.write_oob)
+			chip->ecc.write_oob = nand_write_oob_syndrome;
+
+		if (mtd->writesize >= chip->ecc.size)
+			break;
+		printk(KERN_WARNING "%d byte HW ECC not possible on "
+		       "%d byte page size, fallback to SW ECC\n",
+		       chip->ecc.size, mtd->writesize);
+		chip->ecc.mode = NAND_ECC_SOFT;
 
-	case NAND_ECC_HW3_256:
+	case NAND_ECC_SOFT:
+		chip->ecc.calculate = nand_calculate_ecc;
+		chip->ecc.correct = nand_correct_data;
+		chip->ecc.read_page = nand_read_page_swecc;
+		chip->ecc.read_subpage = nand_read_subpage;
+		chip->ecc.write_page = nand_write_page_swecc;
+		chip->ecc.read_oob = nand_read_oob_std;
+		chip->ecc.write_oob = nand_write_oob_std;
+		chip->ecc.size = 256;
+		chip->ecc.bytes = 3;
 		break;
 
 	case NAND_ECC_NONE:
-		printk (KERN_WARNING "NAND_ECC_NONE selected by board driver. This is not recommended !!\n");
-		this->eccmode = NAND_ECC_NONE;
-		break;
-
-	case NAND_ECC_SOFT:
-		this->calculate_ecc = nand_calculate_ecc;
-		this->correct_data = nand_correct_data;
+		printk(KERN_WARNING "NAND_ECC_NONE selected by board driver. "
+		       "This is not recommended !!\n");
+		chip->ecc.read_page = nand_read_page_raw;
+		chip->ecc.write_page = nand_write_page_raw;
+		chip->ecc.read_oob = nand_read_oob_std;
+		chip->ecc.write_oob = nand_write_oob_std;
+		chip->ecc.size = mtd->writesize;
+		chip->ecc.bytes = 0;
 		break;
 
 	default:
-		printk (KERN_WARNING "Invalid NAND_ECC_MODE %d\n", this->eccmode);
-/*		BUG(); */
-	}
-
-	/* Check hardware ecc function availability and adjust number of ecc bytes per
-	 * calculation step
-	*/
-	switch (this->eccmode) {
-	case NAND_ECC_HW12_2048:
-		this->eccbytes += 4;
-	case NAND_ECC_HW8_512:
-		this->eccbytes += 2;
-	case NAND_ECC_HW6_512:
-		this->eccbytes += 3;
-	case NAND_ECC_HW3_512:
-	case NAND_ECC_HW3_256:
-		if (this->calculate_ecc && this->correct_data && this->enable_hwecc)
-			break;
-		printk (KERN_WARNING "No ECC functions supplied, Hardware ECC not possible\n");
-/*		BUG();	*/
+		printk(KERN_WARNING "Invalid NAND_ECC_MODE %d\n",
+		       chip->ecc.mode);
+		BUG();
 	}
 
-	mtd->eccsize = this->eccsize;
+	/*
+	 * The number of bytes available for a client to place data into
+	 * the out of band area
+	 */
+	chip->ecc.layout->oobavail = 0;
+	for (i = 0; chip->ecc.layout->oobfree[i].length; i++)
+		chip->ecc.layout->oobavail +=
+			chip->ecc.layout->oobfree[i].length;
+	mtd->oobavail = chip->ecc.layout->oobavail;
 
-	/* Set the number of read / write steps for one page to ensure ECC generation */
-	switch (this->eccmode) {
-	case NAND_ECC_HW12_2048:
-		this->eccsteps = mtd->oobblock / 2048;
-		break;
-	case NAND_ECC_HW3_512:
-	case NAND_ECC_HW6_512:
-	case NAND_ECC_HW8_512:
-		this->eccsteps = mtd->oobblock / 512;
-		break;
-	case NAND_ECC_HW3_256:
-	case NAND_ECC_SOFT:
-		this->eccsteps = mtd->oobblock / 256;
-		break;
+	/*
+	 * Set the number of read / write steps for one page depending on ECC
+	 * mode
+	 */
+	chip->ecc.steps = mtd->writesize / chip->ecc.size;
+	if(chip->ecc.steps * chip->ecc.size != mtd->writesize) {
+		printk(KERN_WARNING "Invalid ecc parameters\n");
+		BUG();
+	}
+	chip->ecc.total = chip->ecc.steps * chip->ecc.bytes;
 
-	case NAND_ECC_NONE:
-		this->eccsteps = 1;
-		break;
+	/*
+	 * Allow subpage writes up to ecc.steps. Not possible for MLC
+	 * FLASH.
+	 */
+	if (!(chip->options & NAND_NO_SUBPAGE_WRITE) &&
+	    !(chip->cellinfo & NAND_CI_CELLTYPE_MSK)) {
+		switch(chip->ecc.steps) {
+		case 2:
+			mtd->subpage_sft = 1;
+			break;
+		case 4:
+		case 8:
+			mtd->subpage_sft = 2;
+			break;
+		}
 	}
+	chip->subpagesize = mtd->writesize >> mtd->subpage_sft;
 
-/* XXX U-BOOT XXX */
-#if 0
-	/* Initialize state, waitqueue and spinlock */
-	this->state = FL_READY;
-	init_waitqueue_head (&this->wq);
-	spin_lock_init (&this->chip_lock);
-#endif
+	/* Initialize state */
+	chip->state = FL_READY;
 
 	/* De-select the device */
-	this->select_chip(mtd, -1);
+	chip->select_chip(mtd, -1);
 
 	/* Invalidate the pagebuffer reference */
-	this->pagebuf = -1;
+	chip->pagebuf = -1;
 
 	/* Fill in remaining MTD driver data */
 	mtd->type = MTD_NANDFLASH;
-	mtd->flags = MTD_CAP_NANDFLASH | MTD_ECC;
-	mtd->ecctype = MTD_ECC_SW;
+	mtd->flags = MTD_CAP_NANDFLASH;
 	mtd->erase = nand_erase;
 	mtd->point = NULL;
 	mtd->unpoint = NULL;
 	mtd->read = nand_read;
 	mtd->write = nand_write;
-	mtd->read_ecc = nand_read_ecc;
-	mtd->write_ecc = nand_write_ecc;
 	mtd->read_oob = nand_read_oob;
 	mtd->write_oob = nand_write_oob;
-/* XXX U-BOOT XXX */
-#if 0
-	mtd->readv = NULL;
-	mtd->writev = nand_writev;
-	mtd->writev_ecc = nand_writev_ecc;
-#endif
 	mtd->sync = nand_sync;
-/* XXX U-BOOT XXX */
-#if 0
 	mtd->lock = NULL;
 	mtd->unlock = NULL;
-	mtd->suspend = NULL;
-	mtd->resume = NULL;
-#endif
+	mtd->suspend = nand_suspend;
+	mtd->resume = nand_resume;
 	mtd->block_isbad = nand_block_isbad;
 	mtd->block_markbad = nand_block_markbad;
 
-	/* and make the autooob the default one */
-	memcpy(&mtd->oobinfo, this->autooob, sizeof(mtd->oobinfo));
-/* XXX U-BOOT XXX */
+	/* propagate ecc.layout to mtd_info */
+	mtd->ecclayout = chip->ecc.layout;
+
+	/* Check, if we should skip the bad block table scan */
+	if (chip->options & NAND_SKIP_BBTSCAN)
+		chip->options |= NAND_BBT_SCANNED;
+
+	return 0;
+}
+
+/* module_text_address() isn't exported, and it's mostly a pointless
+   test if this is a module _anyway_ -- they'd have to try _really_ hard
+   to call us from in-kernel code if the core NAND support is modular. */
+#ifdef MODULE
+#define caller_is_module() (1)
+#else
+#define caller_is_module() \
+	module_text_address((unsigned long)__builtin_return_address(0))
+#endif
+
+/**
+ * nand_scan - [NAND Interface] Scan for the NAND device
+ * @mtd:	MTD device structure
+ * @maxchips:	Number of chips to scan for
+ *
+ * This fills out all the uninitialized function pointers
+ * with the defaults.
+ * The flash ID is read and the mtd/chip structures are
+ * filled with the appropriate values.
+ * The mtd->owner field must be set to the module of the caller
+ *
+ */
+int nand_scan(struct mtd_info *mtd, int maxchips)
+{
+	int ret;
+
+	/* Many callers got this wrong, so check for it for a while... */
+	/* XXX U-BOOT XXX */
 #if 0
-	mtd->owner = THIS_MODULE;
+	if (!mtd->owner && caller_is_module()) {
+		printk(KERN_CRIT "nand_scan() called with NULL mtd->owner!\n");
+		BUG();
+	}
 #endif
-	/* Build bad block table */
-	return this->scan_bbt (mtd);
+
+	ret = nand_scan_ident(mtd, maxchips);
+	if (!ret)
+		ret = nand_scan_tail(mtd);
+	return ret;
 }
 
 /**
  * nand_release - [NAND Interface] Free resources held by the NAND device
  * @mtd:	MTD device structure
- */
-void nand_release (struct mtd_info *mtd)
+*/
+void nand_release(struct mtd_info *mtd)
 {
-	struct nand_chip *this = mtd->priv;
+	struct nand_chip *chip = mtd->priv;
 
 #ifdef CONFIG_MTD_PARTITIONS
 	/* Deregister partitions */
-	del_mtd_partitions (mtd);
+	del_mtd_partitions(mtd);
 #endif
 	/* Deregister the device */
-/* XXX U-BOOT XXX */
+	/* XXX U-BOOT XXX */
 #if 0
-	del_mtd_device (mtd);
+	del_mtd_device(mtd);
 #endif
-	/* Free bad block table memory, if allocated */
-	if (this->bbt)
-		kfree (this->bbt);
-	/* Buffer allocated by nand_scan ? */
-	if (this->options & NAND_OOBBUF_ALLOC)
-		kfree (this->oob_buf);
-	/* Buffer allocated by nand_scan ? */
-	if (this->options & NAND_DATABUF_ALLOC)
-		kfree (this->data_buf);
+
+	/* Free bad block table memory */
+	kfree(chip->bbt);
+	if (!(chip->options & NAND_OWN_BUFFERS))
+		kfree(chip->buffers);
 }
 
+/* XXX U-BOOT XXX */
+#if 0
+EXPORT_SYMBOL_GPL(nand_scan);
+EXPORT_SYMBOL_GPL(nand_scan_ident);
+EXPORT_SYMBOL_GPL(nand_scan_tail);
+EXPORT_SYMBOL_GPL(nand_release);
+
+static int __init nand_base_init(void)
+{
+	led_trigger_register_simple("nand-disk", &nand_led_trigger);
+	return 0;
+}
+
+static void __exit nand_base_exit(void)
+{
+	led_trigger_unregister_simple(nand_led_trigger);
+}
+
+module_init(nand_base_init);
+module_exit(nand_base_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Steven J. Hill <sjhill@realitydiluted.com>, Thomas Gleixner <tglx@linutronix.de>");
+MODULE_DESCRIPTION("Generic NAND flash driver code");
 #endif
diff --git a/drivers/mtd/nand/nand_bbt.c b/drivers/mtd/nand/nand_bbt.c
index a97743b..d68a315 100644
--- a/drivers/mtd/nand/nand_bbt.c
+++ b/drivers/mtd/nand/nand_bbt.c
@@ -6,8 +6,6 @@
  *
  *  Copyright (C) 2004 Thomas Gleixner (tglx@linutronix.de)
  *
- * $Id: nand_bbt.c,v 1.28 2004/11/13 10:19:09 gleixner Exp $
- *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
@@ -48,14 +46,11 @@
  *
  * Following assumptions are made:
  * - bbts start at a page boundary, if autolocated on a block boundary
- * - the space neccecary for a bbt in FLASH does not exceed a block boundary
+ * - the space necessary for a bbt in FLASH does not exceed a block boundary
  *
  */
 
 #include <common.h>
-
-#if defined(CONFIG_CMD_NAND) && !defined(CFG_NAND_LEGACY)
-
 #include <malloc.h>
 #include <linux/mtd/compat.h>
 #include <linux/mtd/mtd.h>
@@ -63,6 +58,19 @@
 
 #include <asm/errno.h>
 
+/* XXX U-BOOT XXX */
+#if 0
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+#include <linux/mtd/compatmac.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/vmalloc.h>
+#endif
+
 /**
  * check_pattern - [GENERIC] check if a pattern is in the buffer
  * @buf:	the buffer to search
@@ -76,9 +84,9 @@
  * pattern area contain 0xff
  *
 */
-static int check_pattern (uint8_t *buf, int len, int paglen, struct nand_bbt_descr *td)
+static int check_pattern(uint8_t *buf, int len, int paglen, struct nand_bbt_descr *td)
 {
-	int i, end;
+	int i, end = 0;
 	uint8_t *p = buf;
 
 	end = paglen + td->offs;
@@ -96,9 +104,9 @@ static int check_pattern (uint8_t *buf, int len, int paglen, struct nand_bbt_des
 			return -1;
 	}
 
-	p += td->len;
-	end += td->len;
 	if (td->options & NAND_BBT_SCANEMPTY) {
+		p += td->len;
+		end += td->len;
 		for (i = end; i < len; i++) {
 			if (*p++ != 0xff)
 				return -1;
@@ -108,6 +116,29 @@ static int check_pattern (uint8_t *buf, int len, int paglen, struct nand_bbt_des
 }
 
 /**
+ * check_short_pattern - [GENERIC] check if a pattern is in the buffer
+ * @buf:	the buffer to search
+ * @td:		search pattern descriptor
+ *
+ * Check for a pattern at the given place. Used to search bad block
+ * tables and good / bad block identifiers. Same as check_pattern, but
+ * no optional empty check
+ *
+*/
+static int check_short_pattern(uint8_t *buf, struct nand_bbt_descr *td)
+{
+	int i;
+	uint8_t *p = buf;
+
+	/* Compare the pattern */
+	for (i = 0; i < td->len; i++) {
+		if (p[td->offs + i] != td->pattern[i])
+			return -1;
+	}
+	return 0;
+}
+
+/**
  * read_bbt - [GENERIC] Read the bad block table starting from page
  * @mtd:	MTD device structure
  * @buf:	temporary buffer
@@ -120,8 +151,8 @@ static int check_pattern (uint8_t *buf, int len, int paglen, struct nand_bbt_des
  * Read the bad block table starting from page.
  *
  */
-static int read_bbt (struct mtd_info *mtd, uint8_t *buf, int page, int num,
-	int bits, int offs, int reserved_block_code)
+static int read_bbt(struct mtd_info *mtd, uint8_t *buf, int page, int num,
+		    int bits, int offs, int reserved_block_code)
 {
 	int res, i, j, act = 0;
 	struct nand_chip *this = mtd->priv;
@@ -130,17 +161,17 @@ static int read_bbt (struct mtd_info *mtd, uint8_t *buf, int page, int num,
 	uint8_t msk = (uint8_t) ((1 << bits) - 1);
 
 	totlen = (num * bits) >> 3;
-	from = ((loff_t)page) << this->page_shift;
+	from = ((loff_t) page) << this->page_shift;
 
 	while (totlen) {
-		len = min (totlen, (size_t) (1 << this->bbt_erase_shift));
-		res = mtd->read_ecc (mtd, from, len, &retlen, buf, NULL, this->autooob);
+		len = min(totlen, (size_t) (1 << this->bbt_erase_shift));
+		res = mtd->read(mtd, from, len, &retlen, buf);
 		if (res < 0) {
 			if (retlen != len) {
-				printk (KERN_INFO "nand_bbt: Error reading bad block table\n");
+				printk(KERN_INFO "nand_bbt: Error reading bad block table\n");
 				return res;
 			}
-			printk (KERN_WARNING "nand_bbt: ECC error while reading bad block table\n");
+			printk(KERN_WARNING "nand_bbt: ECC error while reading bad block table\n");
 		}
 
 		/* Analyse data */
@@ -150,22 +181,23 @@ static int read_bbt (struct mtd_info *mtd, uint8_t *buf, int page, int num,
 				uint8_t tmp = (dat >> j) & msk;
 				if (tmp == msk)
 					continue;
-				if (reserved_block_code &&
-				    (tmp == reserved_block_code)) {
-					printk (KERN_DEBUG "nand_read_bbt: Reserved block at 0x%08x\n",
-						((offs << 2) + (act >> 1)) << this->bbt_erase_shift);
+				if (reserved_block_code && (tmp == reserved_block_code)) {
+					printk(KERN_DEBUG "nand_read_bbt: Reserved block at 0x%08x\n",
+					       ((offs << 2) + (act >> 1)) << this->bbt_erase_shift);
 					this->bbt[offs + (act >> 3)] |= 0x2 << (act & 0x06);
+					mtd->ecc_stats.bbtblocks++;
 					continue;
 				}
 				/* Leave it for now, if its matured we can move this
 				 * message to MTD_DEBUG_LEVEL0 */
-				printk (KERN_DEBUG "nand_read_bbt: Bad block at 0x%08x\n",
-					((offs << 2) + (act >> 1)) << this->bbt_erase_shift);
+				printk(KERN_DEBUG "nand_read_bbt: Bad block at 0x%08x\n",
+				       ((offs << 2) + (act >> 1)) << this->bbt_erase_shift);
 				/* Factory marked bad or worn out ? */
 				if (tmp == 0)
 					this->bbt[offs + (act >> 3)] |= 0x3 << (act & 0x06);
 				else
 					this->bbt[offs + (act >> 3)] |= 0x1 << (act & 0x06);
+				mtd->ecc_stats.badblocks++;
 			}
 		}
 		totlen -= len;
@@ -185,7 +217,7 @@ static int read_bbt (struct mtd_info *mtd, uint8_t *buf, int page, int num,
  * Read the bad block table for all chips starting at a given page
  * We assume that the bbt bits are in consecutive order.
 */
-static int read_abs_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td, int chip)
+static int read_abs_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td, int chip)
 {
 	struct nand_chip *this = mtd->priv;
 	int res = 0, i;
@@ -209,6 +241,42 @@ static int read_abs_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_des
 	return 0;
 }
 
+/*
+ * Scan read raw data from flash
+ */
+static int scan_read_raw(struct mtd_info *mtd, uint8_t *buf, loff_t offs,
+			 size_t len)
+{
+	struct mtd_oob_ops ops;
+
+	ops.mode = MTD_OOB_RAW;
+	ops.ooboffs = 0;
+	ops.ooblen = mtd->oobsize;
+	ops.oobbuf = buf;
+	ops.datbuf = buf;
+	ops.len = len;
+
+	return mtd->read_oob(mtd, offs, &ops);
+}
+
+/*
+ * Scan write data with oob to flash
+ */
+static int scan_write_bbt(struct mtd_info *mtd, loff_t offs, size_t len,
+			  uint8_t *buf, uint8_t *oob)
+{
+	struct mtd_oob_ops ops;
+
+	ops.mode = MTD_OOB_PLACE;
+	ops.ooboffs = 0;
+	ops.ooblen = mtd->oobsize;
+	ops.datbuf = buf;
+	ops.oobbuf = oob;
+	ops.len = len;
+
+	return mtd->write_oob(mtd, offs, &ops);
+}
+
 /**
  * read_abs_bbts - [GENERIC] Read the bad block table(s) for all chips starting at a given page
  * @mtd:	MTD device structure
@@ -220,28 +288,84 @@ static int read_abs_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_des
  * We assume that the bbt bits are in consecutive order.
  *
 */
-static int read_abs_bbts (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td,
-	struct nand_bbt_descr *md)
+static int read_abs_bbts(struct mtd_info *mtd, uint8_t *buf,
+			 struct nand_bbt_descr *td, struct nand_bbt_descr *md)
 {
 	struct nand_chip *this = mtd->priv;
 
 	/* Read the primary version, if available */
 	if (td->options & NAND_BBT_VERSION) {
-		nand_read_raw (mtd, buf, td->pages[0] << this->page_shift, mtd->oobblock, mtd->oobsize);
-		td->version[0] = buf[mtd->oobblock + td->veroffs];
-		printk (KERN_DEBUG "Bad block table at page %d, version 0x%02X\n", td->pages[0], td->version[0]);
+		scan_read_raw(mtd, buf, td->pages[0] << this->page_shift,
+			      mtd->writesize);
+		td->version[0] = buf[mtd->writesize + td->veroffs];
+		printk(KERN_DEBUG "Bad block table at page %d, version 0x%02X\n",
+		       td->pages[0], td->version[0]);
 	}
 
 	/* Read the mirror version, if available */
 	if (md && (md->options & NAND_BBT_VERSION)) {
-		nand_read_raw (mtd, buf, md->pages[0] << this->page_shift, mtd->oobblock, mtd->oobsize);
-		md->version[0] = buf[mtd->oobblock + md->veroffs];
-		printk (KERN_DEBUG "Bad block table at page %d, version 0x%02X\n", md->pages[0], md->version[0]);
+		scan_read_raw(mtd, buf, md->pages[0] << this->page_shift,
+			      mtd->writesize);
+		md->version[0] = buf[mtd->writesize + md->veroffs];
+		printk(KERN_DEBUG "Bad block table at page %d, version 0x%02X\n",
+		       md->pages[0], md->version[0]);
 	}
-
 	return 1;
 }
 
+/*
+ * Scan a given block full
+ */
+static int scan_block_full(struct mtd_info *mtd, struct nand_bbt_descr *bd,
+			   loff_t offs, uint8_t *buf, size_t readlen,
+			   int scanlen, int len)
+{
+	int ret, j;
+
+	ret = scan_read_raw(mtd, buf, offs, readlen);
+	if (ret)
+		return ret;
+
+	for (j = 0; j < len; j++, buf += scanlen) {
+		if (check_pattern(buf, scanlen, mtd->writesize, bd))
+			return 1;
+	}
+	return 0;
+}
+
+/*
+ * Scan a given block partially
+ */
+static int scan_block_fast(struct mtd_info *mtd, struct nand_bbt_descr *bd,
+			   loff_t offs, uint8_t *buf, int len)
+{
+	struct mtd_oob_ops ops;
+	int j, ret;
+
+	ops.ooblen = mtd->oobsize;
+	ops.oobbuf = buf;
+	ops.ooboffs = 0;
+	ops.datbuf = NULL;
+	ops.mode = MTD_OOB_PLACE;
+
+	for (j = 0; j < len; j++) {
+		/*
+		 * Read the full oob until read_oob is fixed to
+		 * handle single byte reads for 16 bit
+		 * buswidth
+		 */
+		ret = mtd->read_oob(mtd, offs, &ops);
+		if (ret)
+			return ret;
+
+		if (check_short_pattern(buf, bd))
+			return 1;
+
+		offs += mtd->writesize;
+	}
+	return 0;
+}
+
 /**
  * create_bbt - [GENERIC] Create a bad block table by scanning the device
  * @mtd:	MTD device structure
@@ -253,13 +377,16 @@ static int read_abs_bbts (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_de
  * Create a bad block table by scanning the device
  * for the given good/bad block identify pattern
  */
-static void create_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *bd, int chip)
+static int create_bbt(struct mtd_info *mtd, uint8_t *buf,
+	struct nand_bbt_descr *bd, int chip)
 {
 	struct nand_chip *this = mtd->priv;
-	int i, j, numblocks, len, scanlen;
+	int i, numblocks, len, scanlen;
 	int startblock;
 	loff_t from;
-	size_t readlen, ooblen;
+	size_t readlen;
+
+	MTDDEBUG (MTD_DEBUG_LEVEL0, "Scanning device for bad blocks\n");
 
 	if (bd->options & NAND_BBT_SCANALLPAGES)
 		len = 1 << (this->bbt_erase_shift - this->page_shift);
@@ -269,21 +396,28 @@ static void create_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_desc
 		else
 			len = 1;
 	}
-	scanlen	= mtd->oobblock + mtd->oobsize;
-	readlen = len * mtd->oobblock;
-	ooblen = len * mtd->oobsize;
+
+	if (!(bd->options & NAND_BBT_SCANEMPTY)) {
+		/* We need only read few bytes from the OOB area */
+		scanlen = 0;
+		readlen = bd->len;
+	} else {
+		/* Full page content should be read */
+		scanlen = mtd->writesize + mtd->oobsize;
+		readlen = len * mtd->writesize;
+	}
 
 	if (chip == -1) {
-		/* Note that numblocks is 2 * (real numblocks) here, see i+=2 below as it
-		 * makes shifting and masking less painful */
+		/* Note that numblocks is 2 * (real numblocks) here, see i+=2
+		 * below as it makes shifting and masking less painful */
 		numblocks = mtd->size >> (this->bbt_erase_shift - 1);
 		startblock = 0;
 		from = 0;
 	} else {
 		if (chip >= this->numchips) {
-			printk (KERN_WARNING "create_bbt(): chipnr (%d) > available chips (%d)\n",
-				chip + 1, this->numchips);
-			return;
+			printk(KERN_WARNING "create_bbt(): chipnr (%d) > available chips (%d)\n",
+			       chip + 1, this->numchips);
+			return -EINVAL;
 		}
 		numblocks = this->chipsize >> (this->bbt_erase_shift - 1);
 		startblock = chip * numblocks;
@@ -292,16 +426,29 @@ static void create_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_desc
 	}
 
 	for (i = startblock; i < numblocks;) {
-		nand_read_raw (mtd, buf, from, readlen, ooblen);
-		for (j = 0; j < len; j++) {
-			if (check_pattern (&buf[j * scanlen], scanlen, mtd->oobblock, bd)) {
-				this->bbt[i >> 3] |= 0x03 << (i & 0x6);
-				break;
-			}
+		int ret;
+
+		if (bd->options & NAND_BBT_SCANALLPAGES)
+			ret = scan_block_full(mtd, bd, from, buf, readlen,
+					      scanlen, len);
+		else
+			ret = scan_block_fast(mtd, bd, from, buf, len);
+
+		if (ret < 0)
+			return ret;
+
+		if (ret) {
+			this->bbt[i >> 3] |= 0x03 << (i & 0x6);
+			MTDDEBUG (MTD_DEBUG_LEVEL0,
+			          "Bad eraseblock %d at 0x%08x\n",
+			          i >> 1, (unsigned int)from);
+			mtd->ecc_stats.badblocks++;
 		}
+
 		i += 2;
 		from += (1 << this->bbt_erase_shift);
 	}
+	return 0;
 }
 
 /**
@@ -316,22 +463,23 @@ static void create_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_desc
  * block.
  * If the option NAND_BBT_PERCHIP is given, each chip is searched
  * for a bbt, which contains the bad block information of this chip.
- * This is neccecary to provide support for certain DOC devices.
+ * This is necessary to provide support for certain DOC devices.
  *
  * The bbt ident pattern resides in the oob area of the first page
  * in a block.
  */
-static int search_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td)
+static int search_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td)
 {
 	struct nand_chip *this = mtd->priv;
 	int i, chips;
 	int bits, startblock, block, dir;
-	int scanlen = mtd->oobblock + mtd->oobsize;
+	int scanlen = mtd->writesize + mtd->oobsize;
 	int bbtblocks;
+	int blocktopage = this->bbt_erase_shift - this->page_shift;
 
 	/* Search direction top -> down ? */
 	if (td->options & NAND_BBT_LASTBLOCK) {
-		startblock = (mtd->size >> this->bbt_erase_shift) -1;
+		startblock = (mtd->size >> this->bbt_erase_shift) - 1;
 		dir = -1;
 	} else {
 		startblock = 0;
@@ -357,13 +505,16 @@ static int search_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr
 		td->pages[i] = -1;
 		/* Scan the maximum number of blocks */
 		for (block = 0; block < td->maxblocks; block++) {
+
 			int actblock = startblock + dir * block;
+			loff_t offs = actblock << this->bbt_erase_shift;
+
 			/* Read first page */
-			nand_read_raw (mtd, buf, actblock << this->bbt_erase_shift, mtd->oobblock, mtd->oobsize);
-			if (!check_pattern(buf, scanlen, mtd->oobblock, td)) {
-				td->pages[i] = actblock << (this->bbt_erase_shift - this->page_shift);
+			scan_read_raw(mtd, buf, offs, mtd->writesize);
+			if (!check_pattern(buf, scanlen, mtd->writesize, td)) {
+				td->pages[i] = actblock << blocktopage;
 				if (td->options & NAND_BBT_VERSION) {
-					td->version[i] = buf[mtd->oobblock + td->veroffs];
+					td->version[i] = buf[mtd->writesize + td->veroffs];
 				}
 				break;
 			}
@@ -373,9 +524,10 @@ static int search_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr
 	/* Check, if we found a bbt for each requested chip */
 	for (i = 0; i < chips; i++) {
 		if (td->pages[i] == -1)
-			printk (KERN_WARNING "Bad block table not found for chip %d\n", i);
+			printk(KERN_WARNING "Bad block table not found for chip %d\n", i);
 		else
-			printk (KERN_DEBUG "Bad block table found at page %d, version 0x%02X\n", td->pages[i], td->version[i]);
+			printk(KERN_DEBUG "Bad block table found at page %d, version 0x%02X\n", td->pages[i],
+			       td->version[i]);
 	}
 	return 0;
 }
@@ -389,21 +541,19 @@ static int search_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr
  *
  * Search and read the bad block table(s)
 */
-static int search_read_bbts (struct mtd_info *mtd, uint8_t *buf,
-	struct nand_bbt_descr *td, struct nand_bbt_descr *md)
+static int search_read_bbts(struct mtd_info *mtd, uint8_t * buf, struct nand_bbt_descr *td, struct nand_bbt_descr *md)
 {
 	/* Search the primary table */
-	search_bbt (mtd, buf, td);
+	search_bbt(mtd, buf, td);
 
 	/* Search the mirror table */
 	if (md)
-		search_bbt (mtd, buf, md);
+		search_bbt(mtd, buf, md);
 
 	/* Force result check */
 	return 1;
 }
 
-
 /**
  * write_bbt - [GENERIC] (Re)write the bad block table
  *
@@ -416,25 +566,31 @@ static int search_read_bbts (struct mtd_info *mtd, uint8_t *buf,
  * (Re)write the bad block table
  *
 */
-static int write_bbt (struct mtd_info *mtd, uint8_t *buf,
-	struct nand_bbt_descr *td, struct nand_bbt_descr *md, int chipsel)
+static int write_bbt(struct mtd_info *mtd, uint8_t *buf,
+		     struct nand_bbt_descr *td, struct nand_bbt_descr *md,
+		     int chipsel)
 {
 	struct nand_chip *this = mtd->priv;
-	struct nand_oobinfo oobinfo;
 	struct erase_info einfo;
 	int i, j, res, chip = 0;
 	int bits, startblock, dir, page, offs, numblocks, sft, sftmsk;
-	int nrchips, bbtoffs, pageoffs;
+	int nrchips, bbtoffs, pageoffs, ooboffs;
 	uint8_t msk[4];
 	uint8_t rcode = td->reserved_block_code;
 	size_t retlen, len = 0;
 	loff_t to;
+	struct mtd_oob_ops ops;
+
+	ops.ooblen = mtd->oobsize;
+	ops.ooboffs = 0;
+	ops.datbuf = NULL;
+	ops.mode = MTD_OOB_PLACE;
 
 	if (!rcode)
 		rcode = 0xff;
 	/* Write bad block table per chip rather than per device ? */
 	if (td->options & NAND_BBT_PERCHIP) {
-		numblocks = (int) (this->chipsize >> this->bbt_erase_shift);
+		numblocks = (int)(this->chipsize >> this->bbt_erase_shift);
 		/* Full device write or specific chip ? */
 		if (chipsel == -1) {
 			nrchips = this->numchips;
@@ -443,7 +599,7 @@ static int write_bbt (struct mtd_info *mtd, uint8_t *buf,
 			chip = chipsel;
 		}
 	} else {
-		numblocks = (int) (mtd->size >> this->bbt_erase_shift);
+		numblocks = (int)(mtd->size >> this->bbt_erase_shift);
 		nrchips = 1;
 	}
 
@@ -472,27 +628,38 @@ static int write_bbt (struct mtd_info *mtd, uint8_t *buf,
 		for (i = 0; i < td->maxblocks; i++) {
 			int block = startblock + dir * i;
 			/* Check, if the block is bad */
-			switch ((this->bbt[block >> 2] >> (2 * (block & 0x03))) & 0x03) {
+			switch ((this->bbt[block >> 2] >>
+				 (2 * (block & 0x03))) & 0x03) {
 			case 0x01:
 			case 0x03:
 				continue;
 			}
-			page = block << (this->bbt_erase_shift - this->page_shift);
+			page = block <<
+				(this->bbt_erase_shift - this->page_shift);
 			/* Check, if the block is used by the mirror table */
 			if (!md || md->pages[chip] != page)
 				goto write;
 		}
-		printk (KERN_ERR "No space left to write bad block table\n");
+		printk(KERN_ERR "No space left to write bad block table\n");
 		return -ENOSPC;
-write:
+	write:
 
 		/* Set up shift count and masks for the flash table */
 		bits = td->options & NAND_BBT_NRBITS_MSK;
+		msk[2] = ~rcode;
 		switch (bits) {
-		case 1: sft = 3; sftmsk = 0x07; msk[0] = 0x00; msk[1] = 0x01; msk[2] = ~rcode; msk[3] = 0x01; break;
-		case 2: sft = 2; sftmsk = 0x06; msk[0] = 0x00; msk[1] = 0x01; msk[2] = ~rcode; msk[3] = 0x03; break;
-		case 4: sft = 1; sftmsk = 0x04; msk[0] = 0x00; msk[1] = 0x0C; msk[2] = ~rcode; msk[3] = 0x0f; break;
-		case 8: sft = 0; sftmsk = 0x00; msk[0] = 0x00; msk[1] = 0x0F; msk[2] = ~rcode; msk[3] = 0xff; break;
+		case 1: sft = 3; sftmsk = 0x07; msk[0] = 0x00; msk[1] = 0x01;
+			msk[3] = 0x01;
+			break;
+		case 2: sft = 2; sftmsk = 0x06; msk[0] = 0x00; msk[1] = 0x01;
+			msk[3] = 0x03;
+			break;
+		case 4: sft = 1; sftmsk = 0x04; msk[0] = 0x00; msk[1] = 0x0C;
+			msk[3] = 0x0f;
+			break;
+		case 8: sft = 0; sftmsk = 0x00; msk[0] = 0x00; msk[1] = 0x0F;
+			msk[3] = 0xff;
+			break;
 		default: return -EINVAL;
 		}
 
@@ -500,82 +667,92 @@ write:
 
 		to = ((loff_t) page) << this->page_shift;
 
-		memcpy (&oobinfo, this->autooob, sizeof(oobinfo));
-		oobinfo.useecc = MTD_NANDECC_PLACEONLY;
-
 		/* Must we save the block contents ? */
 		if (td->options & NAND_BBT_SAVECONTENT) {
 			/* Make it block aligned */
 			to &= ~((loff_t) ((1 << this->bbt_erase_shift) - 1));
 			len = 1 << this->bbt_erase_shift;
-			res = mtd->read_ecc (mtd, to, len, &retlen, buf, &buf[len], &oobinfo);
+			res = mtd->read(mtd, to, len, &retlen, buf);
 			if (res < 0) {
 				if (retlen != len) {
-					printk (KERN_INFO "nand_bbt: Error reading block for writing the bad block table\n");
+					printk(KERN_INFO "nand_bbt: Error "
+					       "reading block for writing "
+					       "the bad block table\n");
 					return res;
 				}
-				printk (KERN_WARNING "nand_bbt: ECC error while reading block for writing bad block table\n");
+				printk(KERN_WARNING "nand_bbt: ECC error "
+				       "while reading block for writing "
+				       "bad block table\n");
 			}
+			/* Read oob data */
+			ops.ooblen = (len >> this->page_shift) * mtd->oobsize;
+			ops.oobbuf = &buf[len];
+			res = mtd->read_oob(mtd, to + mtd->writesize, &ops);
+			if (res < 0 || ops.oobretlen != ops.ooblen)
+				goto outerr;
+
 			/* Calc the byte offset in the buffer */
 			pageoffs = page - (int)(to >> this->page_shift);
 			offs = pageoffs << this->page_shift;
 			/* Preset the bbt area with 0xff */
-			memset (&buf[offs], 0xff, (size_t)(numblocks >> sft));
-			/* Preset the bbt's oob area with 0xff */
-			memset (&buf[len + pageoffs * mtd->oobsize], 0xff,
-				((len >> this->page_shift) - pageoffs) * mtd->oobsize);
-			if (td->options & NAND_BBT_VERSION) {
-				buf[len + (pageoffs * mtd->oobsize) + td->veroffs] = td->version[chip];
-			}
+			memset(&buf[offs], 0xff, (size_t) (numblocks >> sft));
+			ooboffs = len + (pageoffs * mtd->oobsize);
+
 		} else {
 			/* Calc length */
 			len = (size_t) (numblocks >> sft);
 			/* Make it page aligned ! */
-			len = (len + (mtd->oobblock-1)) & ~(mtd->oobblock-1);
+			len = (len + (mtd->writesize - 1)) &
+				~(mtd->writesize - 1);
 			/* Preset the buffer with 0xff */
-			memset (buf, 0xff, len + (len >> this->page_shift) * mtd->oobsize);
+			memset(buf, 0xff, len +
+			       (len >> this->page_shift)* mtd->oobsize);
 			offs = 0;
+			ooboffs = len;
 			/* Pattern is located in oob area of first page */
-			memcpy (&buf[len + td->offs], td->pattern, td->len);
-			if (td->options & NAND_BBT_VERSION) {
-				buf[len + td->veroffs] = td->version[chip];
-			}
+			memcpy(&buf[ooboffs + td->offs], td->pattern, td->len);
 		}
 
+		if (td->options & NAND_BBT_VERSION)
+			buf[ooboffs + td->veroffs] = td->version[chip];
+
 		/* walk through the memory table */
-		for (i = 0; i < numblocks; ) {
+		for (i = 0; i < numblocks;) {
 			uint8_t dat;
 			dat = this->bbt[bbtoffs + (i >> 2)];
-			for (j = 0; j < 4; j++ , i++) {
+			for (j = 0; j < 4; j++, i++) {
 				int sftcnt = (i << (3 - sft)) & sftmsk;
 				/* Do not store the reserved bbt blocks ! */
-				buf[offs + (i >> sft)] &= ~(msk[dat & 0x03] << sftcnt);
+				buf[offs + (i >> sft)] &=
+					~(msk[dat & 0x03] << sftcnt);
 				dat >>= 2;
 			}
 		}
 
-		memset (&einfo, 0, sizeof (einfo));
+		memset(&einfo, 0, sizeof(einfo));
 		einfo.mtd = mtd;
-		einfo.addr = (unsigned long) to;
+		einfo.addr = (unsigned long)to;
 		einfo.len = 1 << this->bbt_erase_shift;
-		res = nand_erase_nand (mtd, &einfo, 1);
-		if (res < 0) {
-			printk (KERN_WARNING "nand_bbt: Error during block erase: %d\n", res);
-			return res;
-		}
+		res = nand_erase_nand(mtd, &einfo, 1);
+		if (res < 0)
+			goto outerr;
 
-		res = mtd->write_ecc (mtd, to, len, &retlen, buf, &buf[len], &oobinfo);
-		if (res < 0) {
-			printk (KERN_WARNING "nand_bbt: Error while writing bad block table %d\n", res);
-			return res;
-		}
-		printk (KERN_DEBUG "Bad block table written to 0x%08x, version 0x%02X\n",
-			(unsigned int) to, td->version[chip]);
+		res = scan_write_bbt(mtd, to, len, buf, &buf[len]);
+		if (res < 0)
+			goto outerr;
+
+		printk(KERN_DEBUG "Bad block table written to 0x%08x, version "
+		       "0x%02X\n", (unsigned int)to, td->version[chip]);
 
 		/* Mark it as used */
 		td->pages[chip] = page;
 	}
 	return 0;
+
+ outerr:
+	printk(KERN_WARNING
+	       "nand_bbt: Error while writing bad block table %d\n", res);
+	return res;
 }
 
 /**
@@ -586,29 +763,27 @@ write:
  * The function creates a memory based bbt by scanning the device
  * for manufacturer / software marked good / bad blocks
 */
-static int nand_memory_bbt (struct mtd_info *mtd, struct nand_bbt_descr *bd)
+static inline int nand_memory_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
 {
 	struct nand_chip *this = mtd->priv;
 
-	/* Ensure that we only scan for the pattern and nothing else */
-	bd->options = 0;
-	create_bbt (mtd, this->data_buf, bd, -1);
-	return 0;
+	bd->options &= ~NAND_BBT_SCANEMPTY;
+	return create_bbt(mtd, this->buffers->databuf, bd, -1);
 }
 
 /**
- * check_create - [GENERIC] create and write bbt(s) if neccecary
+ * check_create - [GENERIC] create and write bbt(s) if necessary
  * @mtd:	MTD device structure
  * @buf:	temporary buffer
  * @bd:		descriptor for the good/bad block search pattern
  *
  * The function checks the results of the previous call to read_bbt
- * and creates / updates the bbt(s) if neccecary
- * Creation is neccecary if no bbt was found for the chip/device
- * Update is neccecary if one of the tables is missing or the
+ * and creates / updates the bbt(s) if necessary
+ * Creation is necessary if no bbt was found for the chip/device
+ * Update is necessary if one of the tables is missing or the
  * version nr. of one table is less than the other
 */
-static int check_create (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *bd)
+static int check_create(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *bd)
 {
 	int i, chips, writeops, chipsel, res;
 	struct nand_chip *this = mtd->priv;
@@ -676,35 +851,35 @@ static int check_create (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_des
 			rd = td;
 			goto writecheck;
 		}
-create:
+	create:
 		/* Create the bad block table by scanning the device ? */
 		if (!(td->options & NAND_BBT_CREATE))
 			continue;
 
 		/* Create the table in memory by scanning the chip(s) */
-		create_bbt (mtd, buf, bd, chipsel);
+		create_bbt(mtd, buf, bd, chipsel);
 
 		td->version[i] = 1;
 		if (md)
 			md->version[i] = 1;
-writecheck:
+	writecheck:
 		/* read back first ? */
 		if (rd)
-			read_abs_bbt (mtd, buf, rd, chipsel);
+			read_abs_bbt(mtd, buf, rd, chipsel);
 		/* If they weren't versioned, read both. */
 		if (rd2)
-			read_abs_bbt (mtd, buf, rd2, chipsel);
+			read_abs_bbt(mtd, buf, rd2, chipsel);
 
 		/* Write the bad block table to the device ? */
 		if ((writeops & 0x01) && (td->options & NAND_BBT_WRITE)) {
-			res = write_bbt (mtd, buf, td, md, chipsel);
+			res = write_bbt(mtd, buf, td, md, chipsel);
 			if (res < 0)
 				return res;
 		}
 
 		/* Write the mirror bad block table to the device ? */
 		if ((writeops & 0x02) && md && (md->options & NAND_BBT_WRITE)) {
-			res = write_bbt (mtd, buf, md, td, chipsel);
+			res = write_bbt(mtd, buf, md, td, chipsel);
 			if (res < 0)
 				return res;
 		}
@@ -721,7 +896,7 @@ writecheck:
  * accidental erasures / writes. The regions are identified by
  * the mark 0x02.
 */
-static void mark_bbt_region (struct mtd_info *mtd, struct nand_bbt_descr *td)
+static void mark_bbt_region(struct mtd_info *mtd, struct nand_bbt_descr *td)
 {
 	struct nand_chip *this = mtd->priv;
 	int i, j, chips, block, nrblocks, update;
@@ -739,7 +914,8 @@ static void mark_bbt_region (struct mtd_info *mtd, struct nand_bbt_descr *td)
 	for (i = 0; i < chips; i++) {
 		if ((td->options & NAND_BBT_ABSPAGE) ||
 		    !(td->options & NAND_BBT_WRITE)) {
-			if (td->pages[i] == -1) continue;
+			if (td->pages[i] == -1)
+				continue;
 			block = td->pages[i] >> (this->bbt_erase_shift - this->page_shift);
 			block <<= 1;
 			oldval = this->bbt[(block >> 3)];
@@ -759,7 +935,8 @@ static void mark_bbt_region (struct mtd_info *mtd, struct nand_bbt_descr *td)
 			oldval = this->bbt[(block >> 3)];
 			newval = oldval | (0x2 << (block & 0x06));
 			this->bbt[(block >> 3)] = newval;
-			if (oldval != newval) update = 1;
+			if (oldval != newval)
+				update = 1;
 			block += 2;
 		}
 		/* If we want reserved blocks to be recorded to flash, and some
@@ -784,7 +961,7 @@ static void mark_bbt_region (struct mtd_info *mtd, struct nand_bbt_descr *td)
  * by calling the nand_free_bbt function.
  *
 */
-int nand_scan_bbt (struct mtd_info *mtd, struct nand_bbt_descr *bd)
+int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
 {
 	struct nand_chip *this = mtd->priv;
 	int len, res = 0;
@@ -793,53 +970,56 @@ int nand_scan_bbt (struct mtd_info *mtd, struct nand_bbt_descr *bd)
 	struct nand_bbt_descr *md = this->bbt_md;
 
 	len = mtd->size >> (this->bbt_erase_shift + 2);
-	/* Allocate memory (2bit per block) */
-	this->bbt = kmalloc (len, GFP_KERNEL);
+	/* Allocate memory (2bit per block) and clear the memory bad block table */
+	this->bbt = kzalloc(len, GFP_KERNEL);
 	if (!this->bbt) {
-		printk (KERN_ERR "nand_scan_bbt: Out of memory\n");
+		printk(KERN_ERR "nand_scan_bbt: Out of memory\n");
 		return -ENOMEM;
 	}
-	/* Clear the memory bad block table */
-	memset (this->bbt, 0x00, len);
 
 	/* If no primary table decriptor is given, scan the device
 	 * to build a memory based bad block table
 	 */
-	if (!td)
-		return nand_memory_bbt(mtd, bd);
+	if (!td) {
+		if ((res = nand_memory_bbt(mtd, bd))) {
+			printk(KERN_ERR "nand_bbt: Can't scan flash and build the RAM-based BBT\n");
+			kfree(this->bbt);
+			this->bbt = NULL;
+		}
+		return res;
+	}
 
 	/* Allocate a temporary buffer for one eraseblock incl. oob */
 	len = (1 << this->bbt_erase_shift);
 	len += (len >> this->page_shift) * mtd->oobsize;
-	buf = kmalloc (len, GFP_KERNEL);
+	buf = vmalloc(len);
 	if (!buf) {
-		printk (KERN_ERR "nand_bbt: Out of memory\n");
-		kfree (this->bbt);
+		printk(KERN_ERR "nand_bbt: Out of memory\n");
+		kfree(this->bbt);
 		this->bbt = NULL;
 		return -ENOMEM;
 	}
 
 	/* Is the bbt at a given page ? */
 	if (td->options & NAND_BBT_ABSPAGE) {
-		res = read_abs_bbts (mtd, buf, td, md);
+		res = read_abs_bbts(mtd, buf, td, md);
 	} else {
 		/* Search the bad block table using a pattern in oob */
-		res = search_read_bbts (mtd, buf, td, md);
+		res = search_read_bbts(mtd, buf, td, md);
 	}
 
 	if (res)
-		res = check_create (mtd, buf, bd);
+		res = check_create(mtd, buf, bd);
 
 	/* Prevent the bbt regions from erasing / writing */
-	mark_bbt_region (mtd, td);
+	mark_bbt_region(mtd, td);
 	if (md)
-		mark_bbt_region (mtd, md);
+		mark_bbt_region(mtd, md);
 
-	kfree (buf);
+	vfree(buf);
 	return res;
 }
 
-
 /**
  * nand_update_bbt - [NAND Interface] update bad block table(s)
  * @mtd:	MTD device structure
@@ -847,7 +1027,7 @@ int nand_scan_bbt (struct mtd_info *mtd, struct nand_bbt_descr *bd)
  *
  * The function updates the bad block table(s)
 */
-int nand_update_bbt (struct mtd_info *mtd, loff_t offs)
+int nand_update_bbt(struct mtd_info *mtd, loff_t offs)
 {
 	struct nand_chip *this = mtd->priv;
 	int len, res = 0, writeops = 0;
@@ -863,9 +1043,9 @@ int nand_update_bbt (struct mtd_info *mtd, loff_t offs)
 	/* Allocate a temporary buffer for one eraseblock incl. oob */
 	len = (1 << this->bbt_erase_shift);
 	len += (len >> this->page_shift) * mtd->oobsize;
-	buf = kmalloc (len, GFP_KERNEL);
+	buf = kmalloc(len, GFP_KERNEL);
 	if (!buf) {
-		printk (KERN_ERR "nand_update_bbt: Out of memory\n");
+		printk(KERN_ERR "nand_update_bbt: Out of memory\n");
 		return -ENOMEM;
 	}
 
@@ -873,7 +1053,7 @@ int nand_update_bbt (struct mtd_info *mtd, loff_t offs)
 
 	/* Do we have a bbt per chip ? */
 	if (td->options & NAND_BBT_PERCHIP) {
-		chip = (int) (offs >> this->chip_shift);
+		chip = (int)(offs >> this->chip_shift);
 		chipsel = chip;
 	} else {
 		chip = 0;
@@ -886,29 +1066,26 @@ int nand_update_bbt (struct mtd_info *mtd, loff_t offs)
 
 	/* Write the bad block table to the device ? */
 	if ((writeops & 0x01) && (td->options & NAND_BBT_WRITE)) {
-		res = write_bbt (mtd, buf, td, md, chipsel);
+		res = write_bbt(mtd, buf, td, md, chipsel);
 		if (res < 0)
 			goto out;
 	}
 	/* Write the mirror bad block table to the device ? */
 	if ((writeops & 0x02) && md && (md->options & NAND_BBT_WRITE)) {
-		res = write_bbt (mtd, buf, md, td, chipsel);
+		res = write_bbt(mtd, buf, md, td, chipsel);
 	}
 
-out:
-	kfree (buf);
+ out:
+	kfree(buf);
 	return res;
 }
 
 /* Define some generic bad / good block scan pattern which are used
- * while scanning a device for factory marked good / bad blocks
- *
- * The memory based patterns just
- */
+ * while scanning a device for factory marked good / bad blocks. */
 static uint8_t scan_ff_pattern[] = { 0xff, 0xff };
 
 static struct nand_bbt_descr smallpage_memorybased = {
-	.options = 0,
+	.options = NAND_BBT_SCAN2NDPAGE,
 	.offs = 5,
 	.len = 1,
 	.pattern = scan_ff_pattern
@@ -922,14 +1099,14 @@ static struct nand_bbt_descr largepage_memorybased = {
 };
 
 static struct nand_bbt_descr smallpage_flashbased = {
-	.options = NAND_BBT_SCANEMPTY | NAND_BBT_SCANALLPAGES,
+	.options = NAND_BBT_SCAN2NDPAGE,
 	.offs = 5,
 	.len = 1,
 	.pattern = scan_ff_pattern
 };
 
 static struct nand_bbt_descr largepage_flashbased = {
-	.options = NAND_BBT_SCANEMPTY | NAND_BBT_SCANALLPAGES,
+	.options = NAND_BBT_SCAN2NDPAGE,
 	.offs = 0,
 	.len = 2,
 	.pattern = scan_ff_pattern
@@ -977,7 +1154,7 @@ static struct nand_bbt_descr bbt_mirror_descr = {
  * support for the device and calls the nand_scan_bbt function
  *
 */
-int nand_default_bbt (struct mtd_info *mtd)
+int nand_default_bbt(struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
 
@@ -987,7 +1164,7 @@ int nand_default_bbt (struct mtd_info *mtd)
 	 * of the good / bad information, so we _must_ store
 	 * this information in a good / bad table during
 	 * startup
-	*/
+	 */
 	if (this->options & NAND_IS_AND) {
 		/* Use the default pattern descriptors */
 		if (!this->bbt_td) {
@@ -995,10 +1172,9 @@ int nand_default_bbt (struct mtd_info *mtd)
 			this->bbt_md = &bbt_mirror_descr;
 		}
 		this->options |= NAND_USE_FLASH_BBT;
-		return nand_scan_bbt (mtd, &agand_flashbased);
+		return nand_scan_bbt(mtd, &agand_flashbased);
 	}
 
-
 	/* Is a flash based bad block table requested ? */
 	if (this->options & NAND_USE_FLASH_BBT) {
 		/* Use the default pattern descriptors */
@@ -1007,18 +1183,17 @@ int nand_default_bbt (struct mtd_info *mtd)
 			this->bbt_md = &bbt_mirror_descr;
 		}
 		if (!this->badblock_pattern) {
-			this->badblock_pattern = (mtd->oobblock > 512) ?
-				&largepage_flashbased : &smallpage_flashbased;
+			this->badblock_pattern = (mtd->writesize > 512) ? &largepage_flashbased : &smallpage_flashbased;
 		}
 	} else {
 		this->bbt_td = NULL;
 		this->bbt_md = NULL;
 		if (!this->badblock_pattern) {
-			this->badblock_pattern = (mtd->oobblock > 512) ?
-				&largepage_memorybased : &smallpage_memorybased;
+			this->badblock_pattern = (mtd->writesize > 512) ?
+			    &largepage_memorybased : &smallpage_memorybased;
 		}
 	}
-	return nand_scan_bbt (mtd, this->badblock_pattern);
+	return nand_scan_bbt(mtd, this->badblock_pattern);
 }
 
 /**
@@ -1027,26 +1202,33 @@ int nand_default_bbt (struct mtd_info *mtd)
  * @offs:	offset in the device
  * @allowbbt:	allow access to bad block table region
  *
- */
-int nand_isbad_bbt (struct mtd_info *mtd, loff_t offs, int allowbbt)
+*/
+int nand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt)
 {
 	struct nand_chip *this = mtd->priv;
 	int block;
-	uint8_t	res;
+	uint8_t res;
 
 	/* Get block number * 2 */
-	block = (int) (offs >> (this->bbt_erase_shift - 1));
+	block = (int)(offs >> (this->bbt_erase_shift - 1));
 	res = (this->bbt[block >> 3] >> (block & 0x06)) & 0x03;
 
 	MTDDEBUG (MTD_DEBUG_LEVEL2, "nand_isbad_bbt(): bbt info for offs 0x%08x: "
 	          "(block %d) 0x%02x\n", (unsigned int)offs, res, block >> 1);
 
 	switch ((int)res) {
-	case 0x00:	return 0;
-	case 0x01:	return 1;
-	case 0x02:	return allowbbt ? 0 : 1;
+	case 0x00:
+		return 0;
+	case 0x01:
+		return 1;
+	case 0x02:
+		return allowbbt ? 0 : 1;
 	}
 	return 1;
 }
 
+/* XXX U-BOOT XXX */
+#if 0
+EXPORT_SYMBOL(nand_scan_bbt);
+EXPORT_SYMBOL(nand_default_bbt);
 #endif
diff --git a/drivers/mtd/nand/nand_ecc.c b/drivers/mtd/nand/nand_ecc.c
index 4c532b0..463f9cb 100644
--- a/drivers/mtd/nand/nand_ecc.c
+++ b/drivers/mtd/nand/nand_ecc.c
@@ -7,7 +7,7 @@
  * Copyright (C) 2000-2004 Steven J. Hill (sjhill@realitydiluted.com)
  *                         Toshiba America Electronics Components, Inc.
  *
- * $Id: nand_ecc.c,v 1.14 2004/06/16 15:34:37 gleixner Exp $
+ * Copyright (C) 2006 Thomas Gleixner <tglx@linutronix.de>
  *
  * This file is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -37,9 +37,21 @@
 
 #include <common.h>
 
-#if defined(CONFIG_CMD_NAND) && !defined(CFG_NAND_LEGACY)
+/* XXX U-BOOT XXX */
+#if 0
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mtd/nand_ecc.h>
+#endif
+
+#include <asm/errno.h>
+#include <linux/mtd/mtd.h>
 
-#include<linux/mtd/mtd.h>
+/* The PPC4xx NDFC uses Smart Media (SMC) bytes order */
+#ifdef CONFIG_NAND_NDFC
+#define CONFIG_MTD_NAND_ECC_SMC
+#endif
 
 /*
  * NAND-SPL has no sofware ECC for now, so don't include nand_calculate_ecc(),
@@ -128,6 +140,10 @@ int nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
 
 	return 0;
 }
+/* XXX U-BOOT XXX */
+#if 0
+EXPORT_SYMBOL(nand_calculate_ecc);
+#endif
 #endif /* CONFIG_NAND_SPL */
 
 static inline int countbits(uint32_t byte)
@@ -194,7 +210,10 @@ int nand_correct_data(struct mtd_info *mtd, u_char *dat,
 	if(countbits(s0 | ((uint32_t)s1 << 8) | ((uint32_t)s2 <<16)) == 1)
 		return 1;
 
-	return -1;
+	return -EBADMSG;
 }
 
+/* XXX U-BOOT XXX */
+#if 0
+EXPORT_SYMBOL(nand_correct_data);
 #endif
diff --git a/drivers/mtd/nand/nand_ids.c b/drivers/mtd/nand/nand_ids.c
index 7363490..077c305 100644
--- a/drivers/mtd/nand/nand_ids.c
+++ b/drivers/mtd/nand/nand_ids.c
@@ -2,8 +2,6 @@
  *  drivers/mtd/nandids.c
  *
  *  Copyright (C) 2002 Thomas Gleixner (tglx@linutronix.de)
-  *
- * $Id: nand_ids.c,v 1.10 2004/05/26 13:40:12 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -12,11 +10,7 @@
  */
 
 #include <common.h>
-
-#if defined(CONFIG_CMD_NAND) && !defined(CFG_NAND_LEGACY)
-
 #include <linux/mtd/nand.h>
-
 /*
 *	Chip ID list
 *
@@ -29,13 +23,15 @@
 *	512	512 Byte page size
 */
 struct nand_flash_dev nand_flash_ids[] = {
+
+#ifdef CONFIG_MTD_NAND_MUSEUM_IDS
 	{"NAND 1MiB 5V 8-bit",		0x6e, 256, 1, 0x1000, 0},
 	{"NAND 2MiB 5V 8-bit",		0x64, 256, 2, 0x1000, 0},
 	{"NAND 4MiB 5V 8-bit",		0x6b, 512, 4, 0x2000, 0},
 	{"NAND 1MiB 3,3V 8-bit",	0xe8, 256, 1, 0x1000, 0},
 	{"NAND 1MiB 3,3V 8-bit",	0xec, 256, 1, 0x1000, 0},
 	{"NAND 2MiB 3,3V 8-bit",	0xea, 256, 2, 0x1000, 0},
-	{"NAND 4MiB 3,3V 8-bit",	0xd5, 512, 4, 0x2000, 0},
+	{"NAND 4MiB 3,3V 8-bit", 	0xd5, 512, 4, 0x2000, 0},
 	{"NAND 4MiB 3,3V 8-bit",	0xe3, 512, 4, 0x2000, 0},
 	{"NAND 4MiB 3,3V 8-bit",	0xe5, 512, 4, 0x2000, 0},
 	{"NAND 8MiB 3,3V 8-bit",	0xd6, 512, 8, 0x2000, 0},
@@ -44,6 +40,7 @@ struct nand_flash_dev nand_flash_ids[] = {
 	{"NAND 8MiB 3,3V 8-bit",	0xe6, 512, 8, 0x2000, 0},
 	{"NAND 8MiB 1,8V 16-bit",	0x49, 512, 8, 0x2000, NAND_BUSWIDTH_16},
 	{"NAND 8MiB 3,3V 16-bit",	0x59, 512, 8, 0x2000, NAND_BUSWIDTH_16},
+#endif
 
 	{"NAND 16MiB 1,8V 8-bit",	0x33, 512, 16, 0x4000, 0},
 	{"NAND 16MiB 3,3V 8-bit",	0x73, 512, 16, 0x4000, 0},
@@ -61,52 +58,72 @@ struct nand_flash_dev nand_flash_ids[] = {
 	{"NAND 64MiB 3,3V 16-bit",	0x56, 512, 64, 0x4000, NAND_BUSWIDTH_16},
 
 	{"NAND 128MiB 1,8V 8-bit",	0x78, 512, 128, 0x4000, 0},
+	{"NAND 128MiB 1,8V 8-bit",	0x39, 512, 128, 0x4000, 0},
 	{"NAND 128MiB 3,3V 8-bit",	0x79, 512, 128, 0x4000, 0},
 	{"NAND 128MiB 1,8V 16-bit",	0x72, 512, 128, 0x4000, NAND_BUSWIDTH_16},
+	{"NAND 128MiB 1,8V 16-bit",	0x49, 512, 128, 0x4000, NAND_BUSWIDTH_16},
 	{"NAND 128MiB 3,3V 16-bit",	0x74, 512, 128, 0x4000, NAND_BUSWIDTH_16},
+	{"NAND 128MiB 3,3V 16-bit",	0x59, 512, 128, 0x4000, NAND_BUSWIDTH_16},
 
 	{"NAND 256MiB 3,3V 8-bit",	0x71, 512, 256, 0x4000, 0},
 
-	/* These are the new chips with large page size. The pagesize
-	* and the erasesize is determined from the extended id bytes
-	*/
+	/*
+	 * These are the new chips with large page size. The pagesize and the
+	 * erasesize is determined from the extended id bytes
+	 */
+#define LP_OPTIONS (NAND_SAMSUNG_LP_OPTIONS | NAND_NO_READRDY | NAND_NO_AUTOINCR)
+#define LP_OPTIONS16 (LP_OPTIONS | NAND_BUSWIDTH_16)
+
+	/*512 Megabit */
+	{"NAND 64MiB 1,8V 8-bit",	0xA2, 0,  64, 0, LP_OPTIONS},
+	{"NAND 64MiB 3,3V 8-bit",	0xF2, 0,  64, 0, LP_OPTIONS},
+	{"NAND 64MiB 1,8V 16-bit",	0xB2, 0,  64, 0, LP_OPTIONS16},
+	{"NAND 64MiB 3,3V 16-bit",	0xC2, 0,  64, 0, LP_OPTIONS16},
+
 	/* 1 Gigabit */
-	{"NAND 128MiB 1,8V 8-bit",	0xA1, 0, 128, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
-	{"NAND 128MiB 3,3V 8-bit",	0xF1, 0, 128, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
-	{"NAND 128MiB 1,8V 16-bit",	0xB1, 0, 128, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_BUSWIDTH_16 | NAND_NO_AUTOINCR},
-	{"NAND 128MiB 3,3V 16-bit",	0xC1, 0, 128, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_BUSWIDTH_16 | NAND_NO_AUTOINCR},
+	{"NAND 128MiB 1,8V 8-bit",	0xA1, 0, 128, 0, LP_OPTIONS},
+	{"NAND 128MiB 3,3V 8-bit",	0xF1, 0, 128, 0, LP_OPTIONS},
+	{"NAND 128MiB 1,8V 16-bit",	0xB1, 0, 128, 0, LP_OPTIONS16},
+	{"NAND 128MiB 3,3V 16-bit",	0xC1, 0, 128, 0, LP_OPTIONS16},
 
 	/* 2 Gigabit */
-	{"NAND 256MiB 1,8V 8-bit",	0xAA, 0, 256, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
-	{"NAND 256MiB 3,3V 8-bit",	0xDA, 0, 256, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
-	{"NAND 256MiB 1,8V 16-bit",	0xBA, 0, 256, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_BUSWIDTH_16 | NAND_NO_AUTOINCR},
-	{"NAND 256MiB 3,3V 16-bit",	0xCA, 0, 256, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_BUSWIDTH_16 | NAND_NO_AUTOINCR},
+	{"NAND 256MiB 1,8V 8-bit",	0xAA, 0, 256, 0, LP_OPTIONS},
+	{"NAND 256MiB 3,3V 8-bit",	0xDA, 0, 256, 0, LP_OPTIONS},
+	{"NAND 256MiB 1,8V 16-bit",	0xBA, 0, 256, 0, LP_OPTIONS16},
+	{"NAND 256MiB 3,3V 16-bit",	0xCA, 0, 256, 0, LP_OPTIONS16},
 
 	/* 4 Gigabit */
-	{"NAND 512MiB 1,8V 8-bit",	0xAC, 0, 512, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
-	{"NAND 512MiB 3,3V 8-bit",	0xDC, 0, 512, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
-	{"NAND 512MiB 1,8V 16-bit",	0xBC, 0, 512, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_BUSWIDTH_16 | NAND_NO_AUTOINCR},
-	{"NAND 512MiB 3,3V 16-bit",	0xCC, 0, 512, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_BUSWIDTH_16 | NAND_NO_AUTOINCR},
+	{"NAND 512MiB 1,8V 8-bit",	0xAC, 0, 512, 0, LP_OPTIONS},
+	{"NAND 512MiB 3,3V 8-bit",	0xDC, 0, 512, 0, LP_OPTIONS},
+	{"NAND 512MiB 1,8V 16-bit",	0xBC, 0, 512, 0, LP_OPTIONS16},
+	{"NAND 512MiB 3,3V 16-bit",	0xCC, 0, 512, 0, LP_OPTIONS16},
 
 	/* 8 Gigabit */
-	{"NAND 1GiB 1,8V 8-bit",	0xA3, 0, 1024, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
-	{"NAND 1GiB 3,3V 8-bit",	0xD3, 0, 1024, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
-	{"NAND 1GiB 1,8V 16-bit",	0xB3, 0, 1024, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_BUSWIDTH_16 | NAND_NO_AUTOINCR},
-	{"NAND 1GiB 3,3V 16-bit",	0xC3, 0, 1024, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_BUSWIDTH_16 | NAND_NO_AUTOINCR},
+	{"NAND 1GiB 1,8V 8-bit",	0xA3, 0, 1024, 0, LP_OPTIONS},
+	{"NAND 1GiB 3,3V 8-bit",	0xD3, 0, 1024, 0, LP_OPTIONS},
+	{"NAND 1GiB 1,8V 16-bit",	0xB3, 0, 1024, 0, LP_OPTIONS16},
+	{"NAND 1GiB 3,3V 16-bit",	0xC3, 0, 1024, 0, LP_OPTIONS16},
 
 	/* 16 Gigabit */
-	{"NAND 2GiB 1,8V 8-bit",	0xA5, 0, 2048, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
-	{"NAND 2GiB 3,3V 8-bit",	0xD5, 0, 2048, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
-	{"NAND 2GiB 1,8V 16-bit",	0xB5, 0, 2048, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_BUSWIDTH_16 | NAND_NO_AUTOINCR},
-	{"NAND 2GiB 3,3V 16-bit",	0xC5, 0, 2048, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_BUSWIDTH_16 | NAND_NO_AUTOINCR},
-
-	/* Renesas AND 1 Gigabit. Those chips do not support extended id and have a strange page/block layout !
-	 * The chosen minimum erasesize is 4 * 2 * 2048 = 16384 Byte, as those chips have an array of 4 page planes
-	 * 1 block = 2 pages, but due to plane arrangement the blocks 0-3 consists of page 0 + 4,1 + 5, 2 + 6, 3 + 7
-	 * Anyway JFFS2 would increase the eraseblock size so we chose a combined one which can be erased in one go
-	 * There are more speed improvements for reads and writes possible, but not implemented now
+	{"NAND 2GiB 1,8V 8-bit",	0xA5, 0, 2048, 0, LP_OPTIONS},
+	{"NAND 2GiB 3,3V 8-bit",	0xD5, 0, 2048, 0, LP_OPTIONS},
+	{"NAND 2GiB 1,8V 16-bit",	0xB5, 0, 2048, 0, LP_OPTIONS16},
+	{"NAND 2GiB 3,3V 16-bit",	0xC5, 0, 2048, 0, LP_OPTIONS16},
+
+	/*
+	 * Renesas AND 1 Gigabit. Those chips do not support extended id and
+	 * have a strange page/block layout !  The chosen minimum erasesize is
+	 * 4 * 2 * 2048 = 16384 Byte, as those chips have an array of 4 page
+	 * planes 1 block = 2 pages, but due to plane arrangement the blocks
+	 * 0-3 consists of page 0 + 4,1 + 5, 2 + 6, 3 + 7 Anyway JFFS2 would
+	 * increase the eraseblock size so we chose a combined one which can be
+	 * erased in one go There are more speed improvements for reads and
+	 * writes possible, but not implemented now
 	 */
-	{"AND 128MiB 3,3V 8-bit",	0x01, 2048, 128, 0x4000, NAND_IS_AND | NAND_NO_AUTOINCR | NAND_4PAGE_ARRAY},
+	{"AND 128MiB 3,3V 8-bit",	0x01, 2048, 128, 0x4000,
+	 NAND_IS_AND | NAND_NO_AUTOINCR |NAND_NO_READRDY | NAND_4PAGE_ARRAY |
+	 BBT_AUTO_REFRESH
+	},
 
 	{NULL,}
 };
@@ -121,7 +138,8 @@ struct nand_manufacturers nand_manuf_ids[] = {
 	{NAND_MFR_NATIONAL, "National"},
 	{NAND_MFR_RENESAS, "Renesas"},
 	{NAND_MFR_STMICRO, "ST Micro"},
+	{NAND_MFR_HYNIX, "Hynix"},
 	{NAND_MFR_MICRON, "Micron"},
+	{NAND_MFR_AMD, "AMD"},
 	{0x0, "Unknown"}
 };
-#endif
diff --git a/drivers/mtd/nand/nand_util.c b/drivers/mtd/nand/nand_util.c
index 828cc33..6ba52b3 100644
--- a/drivers/mtd/nand/nand_util.c
+++ b/drivers/mtd/nand/nand_util.c
@@ -31,14 +31,14 @@
  */
 
 #include <common.h>
-
-#if defined(CONFIG_CMD_NAND) && !defined(CFG_NAND_LEGACY)
-
 #include <command.h>
 #include <watchdog.h>
 #include <malloc.h>
 #include <div64.h>
 
+
+#include <asm/errno.h>
+#include <linux/mtd/mtd.h>
 #include <nand.h>
 #include <jffs2/jffs2.h>
 
@@ -69,71 +69,27 @@ static int nand_block_bad_scrub(struct mtd_info *mtd, loff_t ofs, int getchip)
 int nand_erase_opts(nand_info_t *meminfo, const nand_erase_options_t *opts)
 {
 	struct jffs2_unknown_node cleanmarker;
-	int clmpos = 0;
-	int clmlen = 8;
 	erase_info_t erase;
 	ulong erase_length;
-	int isNAND;
 	int bbtest = 1;
 	int result;
 	int percent_complete = -1;
 	int (*nand_block_bad_old)(struct mtd_info *, loff_t, int) = NULL;
 	const char *mtd_device = meminfo->name;
+	struct mtd_oob_ops oob_opts;
+	struct nand_chip *chip = meminfo->priv;
 
 	memset(&erase, 0, sizeof(erase));
+	memset(&oob_opts, 0, sizeof(oob_opts));
 
 	erase.mtd = meminfo;
 	erase.len  = meminfo->erasesize;
 	erase.addr = opts->offset;
 	erase_length = opts->length;
 
-	isNAND = meminfo->type == MTD_NANDFLASH ? 1 : 0;
-
-	if (opts->jffs2) {
-		cleanmarker.magic = cpu_to_je16 (JFFS2_MAGIC_BITMASK);
-		cleanmarker.nodetype = cpu_to_je16 (JFFS2_NODETYPE_CLEANMARKER);
-		if (isNAND) {
-			struct nand_oobinfo *oobinfo = &meminfo->oobinfo;
-
-			/* check for autoplacement */
-			if (oobinfo->useecc == MTD_NANDECC_AUTOPLACE) {
-				/* get the position of the free bytes */
-				if (!oobinfo->oobfree[0][1]) {
-					printf(" Eeep. Autoplacement selected "
-					       "and no empty space in oob\n");
-					return -1;
-				}
-				clmpos = oobinfo->oobfree[0][0];
-				clmlen = oobinfo->oobfree[0][1];
-				if (clmlen > 8)
-					clmlen = 8;
-			} else {
-				/* legacy mode */
-				switch (meminfo->oobsize) {
-				case 8:
-					clmpos = 6;
-					clmlen = 2;
-					break;
-				case 16:
-					clmpos = 8;
-					clmlen = 8;
-					break;
-				case 64:
-					clmpos = 16;
-					clmlen = 8;
-					break;
-				}
-			}
-
-			cleanmarker.totlen = cpu_to_je32(8);
-		} else {
-			cleanmarker.totlen =
-				cpu_to_je32(sizeof(struct jffs2_unknown_node));
-		}
-		cleanmarker.hdr_crc =  cpu_to_je32(
-			crc32_no_comp(0, (unsigned char *) &cleanmarker,
-				      sizeof(struct jffs2_unknown_node) - 4));
-	}
+	cleanmarker.magic = cpu_to_je16 (JFFS2_MAGIC_BITMASK);
+	cleanmarker.nodetype = cpu_to_je16 (JFFS2_NODETYPE_CLEANMARKER);
+	cleanmarker.totlen = cpu_to_je32(8);
 
 	/* scrub option allows to erase badblock. To prevent internal
 	 * check from erase() method, set block check method to dummy
@@ -192,26 +148,20 @@ int nand_erase_opts(nand_info_t *meminfo, const nand_erase_options_t *opts)
 		}
 
 		/* format for JFFS2 ? */
-		if (opts->jffs2) {
-
-			/* write cleanmarker */
-			if (isNAND) {
-				size_t written;
-				result = meminfo->write_oob(meminfo,
-							    erase.addr + clmpos,
-							    clmlen,
-							    &written,
-							    (unsigned char *)
-							    &cleanmarker);
-				if (result != 0) {
-					printf("\n%s: MTD writeoob failure: %d\n",
-					       mtd_device, result);
-					continue;
-				}
-			} else {
-				printf("\n%s: this erase routine only supports"
-				       " NAND devices!\n",
-				       mtd_device);
+		if (opts->jffs2 && chip->ecc.layout->oobavail >= 8) {
+			chip->ops.ooblen = 8;
+			chip->ops.datbuf = NULL;
+			chip->ops.oobbuf = (uint8_t *)&cleanmarker;
+			chip->ops.ooboffs = 0;
+			chip->ops.mode = MTD_OOB_AUTO;
+
+			result = meminfo->write_oob(meminfo,
+			                            erase.addr,
+			                            &chip->ops);
+			if (result != 0) {
+				printf("\n%s: MTD writeoob failure: %d\n",
+				       mtd_device, result);
+				continue;
 			}
 		}
 
@@ -253,6 +203,9 @@ int nand_erase_opts(nand_info_t *meminfo, const nand_erase_options_t *opts)
 	return 0;
 }
 
+/* XXX U-BOOT XXX */
+#if 0
+
 #define MAX_PAGE_SIZE	2048
 #define MAX_OOB_SIZE	64
 
@@ -263,442 +216,29 @@ static unsigned char data_buf[MAX_PAGE_SIZE];
 static unsigned char oob_buf[MAX_OOB_SIZE];
 
 /* OOB layouts to pass into the kernel as default */
-static struct nand_oobinfo none_oobinfo = {
+static struct nand_ecclayout none_ecclayout = {
 	.useecc = MTD_NANDECC_OFF,
 };
 
-static struct nand_oobinfo jffs2_oobinfo = {
+static struct nand_ecclayout jffs2_ecclayout = {
 	.useecc = MTD_NANDECC_PLACE,
 	.eccbytes = 6,
 	.eccpos = { 0, 1, 2, 3, 6, 7 }
 };
 
-static struct nand_oobinfo yaffs_oobinfo = {
+static struct nand_ecclayout yaffs_ecclayout = {
 	.useecc = MTD_NANDECC_PLACE,
 	.eccbytes = 6,
 	.eccpos = { 8, 9, 10, 13, 14, 15}
 };
 
-static struct nand_oobinfo autoplace_oobinfo = {
+static struct nand_ecclayout autoplace_ecclayout = {
 	.useecc = MTD_NANDECC_AUTOPLACE
 };
+#endif
 
-/**
- * nand_write_opts: - write image to NAND flash with support for various options
- *
- * @param meminfo	NAND device to erase
- * @param opts		write options (@see nand_write_options)
- * @return		0 in case of success
- *
- * This code is ported from nandwrite.c from Linux mtd utils by
- * Steven J. Hill and Thomas Gleixner.
- */
-int nand_write_opts(nand_info_t *meminfo, const nand_write_options_t *opts)
-{
-	int imglen = 0;
-	int pagelen;
-	int baderaseblock;
-	int blockstart = -1;
-	loff_t offs;
-	int readlen;
-	int oobinfochanged = 0;
-	int percent_complete = -1;
-	struct nand_oobinfo old_oobinfo;
-	ulong mtdoffset = opts->offset;
-	ulong erasesize_blockalign;
-	u_char *buffer = opts->buffer;
-	size_t written;
-	int result;
-
-	if (opts->pad && opts->writeoob) {
-		printf("Can't pad when oob data is present.\n");
-		return -1;
-	}
-
-	/* set erasesize to specified number of blocks - to match
-	 * jffs2 (virtual) block size */
-	if (opts->blockalign == 0) {
-		erasesize_blockalign = meminfo->erasesize;
-	} else {
-		erasesize_blockalign = meminfo->erasesize * opts->blockalign;
-	}
-
-	/* make sure device page sizes are valid */
-	if (!(meminfo->oobsize == 16 && meminfo->oobblock == 512)
-	    && !(meminfo->oobsize == 8 && meminfo->oobblock == 256)
-	    && !(meminfo->oobsize == 64 && meminfo->oobblock == 2048)) {
-		printf("Unknown flash (not normal NAND)\n");
-		return -1;
-	}
-
-	/* read the current oob info */
-	memcpy(&old_oobinfo, &meminfo->oobinfo, sizeof(old_oobinfo));
-
-	/* write without ecc? */
-	if (opts->noecc) {
-		memcpy(&meminfo->oobinfo, &none_oobinfo,
-		       sizeof(meminfo->oobinfo));
-		oobinfochanged = 1;
-	}
-
-	/* autoplace ECC? */
-	if (opts->autoplace && (old_oobinfo.useecc != MTD_NANDECC_AUTOPLACE)) {
-
-		memcpy(&meminfo->oobinfo, &autoplace_oobinfo,
-		       sizeof(meminfo->oobinfo));
-		oobinfochanged = 1;
-	}
-
-	/* force OOB layout for jffs2 or yaffs? */
-	if (opts->forcejffs2 || opts->forceyaffs) {
-		struct nand_oobinfo *oobsel =
-			opts->forcejffs2 ? &jffs2_oobinfo : &yaffs_oobinfo;
-
-		if (meminfo->oobsize == 8) {
-			if (opts->forceyaffs) {
-				printf("YAFSS cannot operate on "
-				       "256 Byte page size\n");
-				goto restoreoob;
-			}
-			/* Adjust number of ecc bytes */
-			jffs2_oobinfo.eccbytes = 3;
-		}
-
-		memcpy(&meminfo->oobinfo, oobsel, sizeof(meminfo->oobinfo));
-	}
-
-	/* get image length */
-	imglen = opts->length;
-	pagelen = meminfo->oobblock
-		+ ((opts->writeoob != 0) ? meminfo->oobsize : 0);
-
-	/* check, if file is pagealigned */
-	if ((!opts->pad) && ((imglen % pagelen) != 0)) {
-		printf("Input block length is not page aligned\n");
-		goto restoreoob;
-	}
-
-	/* check, if length fits into device */
-	if (((imglen / pagelen) * meminfo->oobblock)
-	     > (meminfo->size - opts->offset)) {
-		printf("Image %d bytes, NAND page %d bytes, "
-		       "OOB area %u bytes, device size %u bytes\n",
-		       imglen, pagelen, meminfo->oobblock, meminfo->size);
-		printf("Input block does not fit into device\n");
-		goto restoreoob;
-	}
-
-	if (!opts->quiet)
-		printf("\n");
-
-	/* get data from input and write to the device */
-	while (imglen && (mtdoffset < meminfo->size)) {
-
-		WATCHDOG_RESET ();
-
-		/*
-		 * new eraseblock, check for bad block(s). Stay in the
-		 * loop to be sure if the offset changes because of
-		 * a bad block, that the next block that will be
-		 * written to is also checked. Thus avoiding errors if
-		 * the block(s) after the skipped block(s) is also bad
-		 * (number of blocks depending on the blockalign
-		 */
-		while (blockstart != (mtdoffset & (~erasesize_blockalign+1))) {
-			blockstart = mtdoffset & (~erasesize_blockalign+1);
-			offs = blockstart;
-			baderaseblock = 0;
-
-			/* check all the blocks in an erase block for
-			 * bad blocks */
-			do {
-				int ret = meminfo->block_isbad(meminfo, offs);
-
-				if (ret < 0) {
-					printf("Bad block check failed\n");
-					goto restoreoob;
-				}
-				if (ret == 1) {
-					baderaseblock = 1;
-					if (!opts->quiet)
-						printf("\rBad block at 0x%lx "
-						       "in erase block from "
-						       "0x%x will be skipped\n",
-						       (long) offs,
-						       blockstart);
-				}
-
-				if (baderaseblock) {
-					mtdoffset = blockstart
-						+ erasesize_blockalign;
-				}
-				offs +=	 erasesize_blockalign
-					/ opts->blockalign;
-			} while (offs < blockstart + erasesize_blockalign);
-		}
-
-		readlen = meminfo->oobblock;
-		if (opts->pad && (imglen < readlen)) {
-			readlen = imglen;
-			memset(data_buf + readlen, 0xff,
-			       meminfo->oobblock - readlen);
-		}
-
-		/* read page data from input memory buffer */
-		memcpy(data_buf, buffer, readlen);
-		buffer += readlen;
-
-		if (opts->writeoob) {
-			/* read OOB data from input memory block, exit
-			 * on failure */
-			memcpy(oob_buf, buffer, meminfo->oobsize);
-			buffer += meminfo->oobsize;
-
-			/* write OOB data first, as ecc will be placed
-			 * in there*/
-			result = meminfo->write_oob(meminfo,
-						    mtdoffset,
-						    meminfo->oobsize,
-						    &written,
-						    (unsigned char *)
-						    &oob_buf);
-
-			if (result != 0) {
-				printf("\nMTD writeoob failure: %d\n",
-				       result);
-				goto restoreoob;
-			}
-			imglen -= meminfo->oobsize;
-		}
-
-		/* write out the page data */
-		result = meminfo->write(meminfo,
-					mtdoffset,
-					meminfo->oobblock,
-					&written,
-					(unsigned char *) &data_buf);
-
-		if (result != 0) {
-			printf("writing NAND page at offset 0x%lx failed\n",
-			       mtdoffset);
-			goto restoreoob;
-		}
-		imglen -= readlen;
-
-		if (!opts->quiet) {
-			unsigned long long n = (unsigned long long)
-				 (opts->length-imglen) * 100;
-			int percent;
-
-			do_div(n, opts->length);
-			percent = (int)n;
-
-			/* output progress message only at whole percent
-			 * steps to reduce the number of messages printed
-			 * on (slow) serial consoles
-			 */
-			if (percent != percent_complete) {
-				printf("\rWriting data at 0x%lx "
-				       "-- %3d%% complete.",
-				       mtdoffset, percent);
-				percent_complete = percent;
-			}
-		}
-
-		mtdoffset += meminfo->oobblock;
-	}
-
-	if (!opts->quiet)
-		printf("\n");
-
-restoreoob:
-	if (oobinfochanged) {
-		memcpy(&meminfo->oobinfo, &old_oobinfo,
-		       sizeof(meminfo->oobinfo));
-	}
-
-	if (imglen > 0) {
-		printf("Data did not fit into device, due to bad blocks\n");
-		return -1;
-	}
-
-	/* return happy */
-	return 0;
-}
-
-/**
- * nand_read_opts: - read image from NAND flash with support for various options
- *
- * @param meminfo	NAND device to erase
- * @param opts		read options (@see struct nand_read_options)
- * @return		0 in case of success
- *
- */
-int nand_read_opts(nand_info_t *meminfo, const nand_read_options_t *opts)
-{
-	int imglen = opts->length;
-	int pagelen;
-	int baderaseblock;
-	int blockstart = -1;
-	int percent_complete = -1;
-	loff_t offs;
-	size_t readlen;
-	ulong mtdoffset = opts->offset;
-	u_char *buffer = opts->buffer;
-	int result;
-
-	/* make sure device page sizes are valid */
-	if (!(meminfo->oobsize == 16 && meminfo->oobblock == 512)
-	    && !(meminfo->oobsize == 8 && meminfo->oobblock == 256)
-	    && !(meminfo->oobsize == 64 && meminfo->oobblock == 2048)) {
-		printf("Unknown flash (not normal NAND)\n");
-		return -1;
-	}
-
-	pagelen = meminfo->oobblock
-		+ ((opts->readoob != 0) ? meminfo->oobsize : 0);
-
-	/* check, if length is not larger than device */
-	if (((imglen / pagelen) * meminfo->oobblock)
-	     > (meminfo->size - opts->offset)) {
-		printf("Image %d bytes, NAND page %d bytes, "
-		       "OOB area %u bytes, device size %u bytes\n",
-		       imglen, pagelen, meminfo->oobblock, meminfo->size);
-		printf("Input block is larger than device\n");
-		return -1;
-	}
-
-	if (!opts->quiet)
-		printf("\n");
-
-	/* get data from input and write to the device */
-	while (imglen && (mtdoffset < meminfo->size)) {
-
-		WATCHDOG_RESET ();
-
-		/*
-		 * new eraseblock, check for bad block(s). Stay in the
-		 * loop to be sure if the offset changes because of
-		 * a bad block, that the next block that will be
-		 * written to is also checked. Thus avoiding errors if
-		 * the block(s) after the skipped block(s) is also bad
-		 * (number of blocks depending on the blockalign
-		 */
-		while (blockstart != (mtdoffset & (~meminfo->erasesize+1))) {
-			blockstart = mtdoffset & (~meminfo->erasesize+1);
-			offs = blockstart;
-			baderaseblock = 0;
-
-			/* check all the blocks in an erase block for
-			 * bad blocks */
-			do {
-				int ret = meminfo->block_isbad(meminfo, offs);
-
-				if (ret < 0) {
-					printf("Bad block check failed\n");
-					return -1;
-				}
-				if (ret == 1) {
-					baderaseblock = 1;
-					if (!opts->quiet)
-						printf("\rBad block at 0x%lx "
-						       "in erase block from "
-						       "0x%x will be skipped\n",
-						       (long) offs,
-						       blockstart);
-				}
-
-				if (baderaseblock) {
-					mtdoffset = blockstart
-						+ meminfo->erasesize;
-				}
-				offs +=	 meminfo->erasesize;
-
-			} while (offs < blockstart + meminfo->erasesize);
-		}
-
-
-		/* read page data to memory buffer */
-		result = meminfo->read(meminfo,
-				       mtdoffset,
-				       meminfo->oobblock,
-				       &readlen,
-				       (unsigned char *) &data_buf);
-
-		if (result != 0) {
-			printf("reading NAND page at offset 0x%lx failed\n",
-			       mtdoffset);
-			return -1;
-		}
-
-		if (imglen < readlen) {
-			readlen = imglen;
-		}
-
-		memcpy(buffer, data_buf, readlen);
-		buffer += readlen;
-		imglen -= readlen;
-
-		if (opts->readoob) {
-			result = meminfo->read_oob(meminfo,
-						   mtdoffset,
-						   meminfo->oobsize,
-						   &readlen,
-						   (unsigned char *)
-						   &oob_buf);
-
-			if (result != 0) {
-				printf("\nMTD readoob failure: %d\n",
-				       result);
-				return -1;
-			}
-
-
-			if (imglen < readlen) {
-				readlen = imglen;
-			}
-
-			memcpy(buffer, oob_buf, readlen);
-
-			buffer += readlen;
-			imglen -= readlen;
-		}
-
-		if (!opts->quiet) {
-			unsigned long long n = (unsigned long long)
-				 (opts->length-imglen) * 100;
-			int percent;
-
-			do_div(n, opts->length);
-			percent = (int)n;
-
-			/* output progress message only at whole percent
-			 * steps to reduce the number of messages printed
-			 * on (slow) serial consoles
-			 */
-			if (percent != percent_complete) {
-			if (!opts->quiet)
-				printf("\rReading data from 0x%lx "
-				       "-- %3d%% complete.",
-				       mtdoffset, percent);
-				percent_complete = percent;
-			}
-		}
-
-		mtdoffset += meminfo->oobblock;
-	}
-
-	if (!opts->quiet)
-		printf("\n");
-
-	if (imglen > 0) {
-		printf("Could not read entire image due to bad blocks\n");
-		return -1;
-	}
-
-	/* return happy */
-	return 0;
-}
+/* XXX U-BOOT XXX */
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
 
 /******************************************************************************
  * Support for locking / unlocking operations of some NAND devices
@@ -714,7 +254,7 @@ int nand_read_opts(nand_info_t *meminfo, const nand_read_options_t *opts)
  * nand_lock: Set all pages of NAND flash chip to the LOCK or LOCK-TIGHT
  *	      state
  *
- * @param meminfo	nand mtd instance
+ * @param mtd		nand mtd instance
  * @param tight		bring device in lock tight mode
  *
  * @return		0 on success, -1 in case of error
@@ -731,21 +271,21 @@ int nand_read_opts(nand_info_t *meminfo, const nand_read_options_t *opts)
  *   calls will fail. It is only posible to leave lock-tight state by
  *   an hardware signal (low pulse on _WP pin) or by power down.
  */
-int nand_lock(nand_info_t *meminfo, int tight)
+int nand_lock(struct mtd_info *mtd, int tight)
 {
 	int ret = 0;
 	int status;
-	struct nand_chip *this = meminfo->priv;
+	struct nand_chip *chip = mtd->priv;
 
 	/* select the NAND device */
-	this->select_chip(meminfo, 0);
+	chip->select_chip(mtd, 0);
 
-	this->cmdfunc(meminfo,
+	chip->cmdfunc(mtd,
 		      (tight ? NAND_CMD_LOCK_TIGHT : NAND_CMD_LOCK),
 		      -1, -1);
 
 	/* call wait ready function */
-	status = this->waitfunc(meminfo, this, FL_WRITING);
+	status = chip->waitfunc(mtd, chip);
 
 	/* see if device thinks it succeeded */
 	if (status & 0x01) {
@@ -753,7 +293,7 @@ int nand_lock(nand_info_t *meminfo, int tight)
 	}
 
 	/* de-select the NAND device */
-	this->select_chip(meminfo, -1);
+	chip->select_chip(mtd, -1);
 	return ret;
 }
 
@@ -761,7 +301,7 @@ int nand_lock(nand_info_t *meminfo, int tight)
  * nand_get_lock_status: - query current lock state from one page of NAND
  *			   flash
  *
- * @param meminfo	nand mtd instance
+ * @param mtd		nand mtd instance
  * @param offset	page address to query (muss be page aligned!)
  *
  * @return		-1 in case of error
@@ -772,19 +312,19 @@ int nand_lock(nand_info_t *meminfo, int tight)
  *			  NAND_LOCK_STATUS_UNLOCK: page unlocked
  *
  */
-int nand_get_lock_status(nand_info_t *meminfo, ulong offset)
+int nand_get_lock_status(struct mtd_info *mtd, ulong offset)
 {
 	int ret = 0;
 	int chipnr;
 	int page;
-	struct nand_chip *this = meminfo->priv;
+	struct nand_chip *chip = mtd->priv;
 
 	/* select the NAND device */
-	chipnr = (int)(offset >> this->chip_shift);
-	this->select_chip(meminfo, chipnr);
+	chipnr = (int)(offset >> chip->chip_shift);
+	chip->select_chip(mtd, chipnr);
 
 
-	if ((offset & (meminfo->oobblock - 1)) != 0) {
+	if ((offset & (mtd->writesize - 1)) != 0) {
 		printf ("nand_get_lock_status: "
 			"Start address must be beginning of "
 			"nand page!\n");
@@ -793,16 +333,16 @@ int nand_get_lock_status(nand_info_t *meminfo, ulong offset)
 	}
 
 	/* check the Lock Status */
-	page = (int)(offset >> this->page_shift);
-	this->cmdfunc(meminfo, NAND_CMD_LOCK_STATUS, -1, page & this->pagemask);
+	page = (int)(offset >> chip->page_shift);
+	chip->cmdfunc(mtd, NAND_CMD_LOCK_STATUS, -1, page & chip->pagemask);
 
-	ret = this->read_byte(meminfo) & (NAND_LOCK_STATUS_TIGHT
+	ret = chip->read_byte(mtd) & (NAND_LOCK_STATUS_TIGHT
 					  | NAND_LOCK_STATUS_LOCK
 					  | NAND_LOCK_STATUS_UNLOCK);
 
  out:
 	/* de-select the NAND device */
-	this->select_chip(meminfo, -1);
+	chip->select_chip(mtd, -1);
 	return ret;
 }
 
@@ -810,59 +350,65 @@ int nand_get_lock_status(nand_info_t *meminfo, ulong offset)
  * nand_unlock: - Unlock area of NAND pages
  *		  only one consecutive area can be unlocked at one time!
  *
- * @param meminfo	nand mtd instance
+ * @param mtd		nand mtd instance
  * @param start		start byte address
  * @param length	number of bytes to unlock (must be a multiple of
- *			page size nand->oobblock)
+ *			page size nand->writesize)
  *
  * @return		0 on success, -1 in case of error
  */
-int nand_unlock(nand_info_t *meminfo, ulong start, ulong length)
+int nand_unlock(struct mtd_info *mtd, ulong start, ulong length)
 {
 	int ret = 0;
 	int chipnr;
 	int status;
 	int page;
-	struct nand_chip *this = meminfo->priv;
+	struct nand_chip *chip = mtd->priv;
 	printf ("nand_unlock: start: %08x, length: %d!\n",
 		(int)start, (int)length);
 
 	/* select the NAND device */
-	chipnr = (int)(start >> this->chip_shift);
-	this->select_chip(meminfo, chipnr);
+	chipnr = (int)(start >> chip->chip_shift);
+	chip->select_chip(mtd, chipnr);
 
 	/* check the WP bit */
-	this->cmdfunc(meminfo, NAND_CMD_STATUS, -1, -1);
-	if ((this->read_byte(meminfo) & 0x80) == 0) {
+	chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
+	if (!(chip->read_byte(mtd) & NAND_STATUS_WP)) {
 		printf ("nand_unlock: Device is write protected!\n");
 		ret = -1;
 		goto out;
 	}
 
-	if ((start & (meminfo->oobblock - 1)) != 0) {
+	if ((start & (mtd->erasesize - 1)) != 0) {
 		printf ("nand_unlock: Start address must be beginning of "
-			"nand page!\n");
+			"nand block!\n");
 		ret = -1;
 		goto out;
 	}
 
-	if (length == 0 || (length & (meminfo->oobblock - 1)) != 0) {
-		printf ("nand_unlock: Length must be a multiple of nand page "
-			"size!\n");
+	if (length == 0 || (length & (mtd->erasesize - 1)) != 0) {
+		printf ("nand_unlock: Length must be a multiple of nand block "
+			"size %08x!\n", mtd->erasesize);
 		ret = -1;
 		goto out;
 	}
 
+	/*
+	 * Set length so that the last address is set to the
+	 * starting address of the last block
+	 */
+	length -= mtd->erasesize;
+
 	/* submit address of first page to unlock */
-	page = (int)(start >> this->page_shift);
-	this->cmdfunc(meminfo, NAND_CMD_UNLOCK1, -1, page & this->pagemask);
+	page = (int)(start >> chip->page_shift);
+	chip->cmdfunc(mtd, NAND_CMD_UNLOCK1, -1, page & chip->pagemask);
 
 	/* submit ADDRESS of LAST page to unlock */
-	page += (int)(length >> this->page_shift) - 1;
-	this->cmdfunc(meminfo, NAND_CMD_UNLOCK2, -1, page & this->pagemask);
+	page += (int)(length >> chip->page_shift);
+	chip->cmdfunc(mtd, NAND_CMD_UNLOCK2, -1, page & chip->pagemask);
 
 	/* call wait ready function */
-	status = this->waitfunc(meminfo, this, FL_WRITING);
+	status = chip->waitfunc(mtd, chip);
 	/* see if device thinks it succeeded */
 	if (status & 0x01) {
 		/* there was an error */
@@ -872,8 +418,187 @@ int nand_unlock(nand_info_t *meminfo, ulong start, ulong length)
 
  out:
 	/* de-select the NAND device */
-	this->select_chip(meminfo, -1);
+	chip->select_chip(mtd, -1);
 	return ret;
 }
-
 #endif
+
+/**
+ * get_len_incl_bad
+ *
+ * Check if length including bad blocks fits into device.
+ *
+ * @param nand NAND device
+ * @param offset offset in flash
+ * @param length image length
+ * @return image length including bad blocks
+ */
+static size_t get_len_incl_bad (nand_info_t *nand, size_t offset,
+				const size_t length)
+{
+	size_t len_incl_bad = 0;
+	size_t len_excl_bad = 0;
+	size_t block_len;
+
+	while (len_excl_bad < length) {
+		block_len = nand->erasesize - (offset & (nand->erasesize - 1));
+
+		if (!nand_block_isbad (nand, offset & ~(nand->erasesize - 1)))
+			len_excl_bad += block_len;
+
+		len_incl_bad += block_len;
+		offset       += block_len;
+
+		if ((offset + len_incl_bad) >= nand->size)
+			break;
+	}
+
+	return len_incl_bad;
+}
+
+/**
+ * nand_write_skip_bad:
+ *
+ * Write image to NAND flash.
+ * Blocks that are marked bad are skipped and the is written to the next
+ * block instead as long as the image is short enough to fit even after
+ * skipping the bad blocks.
+ *
+ * @param nand  	NAND device
+ * @param offset	offset in flash
+ * @param length	buffer length
+ * @param buf           buffer to read from
+ * @return		0 in case of success
+ */
+int nand_write_skip_bad(nand_info_t *nand, size_t offset, size_t *length,
+			u_char *buffer)
+{
+	int rval;
+	size_t left_to_write = *length;
+	size_t len_incl_bad;
+	u_char *p_buffer = buffer;
+
+	/* Reject writes, which are not page aligned */
+	if ((offset & (nand->writesize - 1)) != 0 ||
+	    (*length & (nand->writesize - 1)) != 0) {
+		printf ("Attempt to write non page aligned data\n");
+		return -EINVAL;
+	}
+
+	len_incl_bad = get_len_incl_bad (nand, offset, *length);
+
+	if ((offset + len_incl_bad) >= nand->size) {
+		printf ("Attempt to write outside the flash area\n");
+		return -EINVAL;
+	}
+
+	if (len_incl_bad == *length) {
+		rval = nand_write (nand, offset, length, buffer);
+		if (rval != 0)
+			printf ("NAND write to offset %zx failed %d\n",
+				offset, rval);
+
+		return rval;
+	}
+
+	while (left_to_write > 0) {
+		size_t block_offset = offset & (nand->erasesize - 1);
+		size_t write_size;
+
+		if (nand_block_isbad (nand, offset & ~(nand->erasesize - 1))) {
+			printf ("Skip bad block 0x%08zx\n",
+				offset & ~(nand->erasesize - 1));
+			offset += nand->erasesize - block_offset;
+			continue;
+		}
+
+		if (left_to_write < (nand->erasesize - block_offset))
+			write_size = left_to_write;
+		else
+			write_size = nand->erasesize - block_offset;
+
+		rval = nand_write (nand, offset, &write_size, p_buffer);
+		if (rval != 0) {
+			printf ("NAND write to offset %zx failed %d\n",
+				offset, rval);
+			*length -= left_to_write;
+			return rval;
+		}
+
+		left_to_write -= write_size;
+		offset        += write_size;
+		p_buffer      += write_size;
+	}
+
+	return 0;
+}
+
+/**
+ * nand_read_skip_bad:
+ *
+ * Read image from NAND flash.
+ * Blocks that are marked bad are skipped and the next block is readen
+ * instead as long as the image is short enough to fit even after skipping the
+ * bad blocks.
+ *
+ * @param nand NAND device
+ * @param offset offset in flash
+ * @param length buffer length, on return holds remaining bytes to read
+ * @param buffer buffer to write to
+ * @return 0 in case of success
+ */
+int nand_read_skip_bad(nand_info_t *nand, size_t offset, size_t *length,
+		       u_char *buffer)
+{
+	int rval;
+	size_t left_to_read = *length;
+	size_t len_incl_bad;
+	u_char *p_buffer = buffer;
+
+	len_incl_bad = get_len_incl_bad (nand, offset, *length);
+
+	if ((offset + len_incl_bad) >= nand->size) {
+		printf ("Attempt to read outside the flash area\n");
+		return -EINVAL;
+	}
+
+	if (len_incl_bad == *length) {
+		rval = nand_read (nand, offset, length, buffer);
+		if (rval != 0)
+			printf ("NAND read from offset %zx failed %d\n",
+				offset, rval);
+
+		return rval;
+	}
+
+	while (left_to_read > 0) {
+		size_t block_offset = offset & (nand->erasesize - 1);
+		size_t read_length;
+
+		if (nand_block_isbad (nand, offset & ~(nand->erasesize - 1))) {
+			printf ("Skipping bad block 0x%08zx\n",
+				offset & ~(nand->erasesize - 1));
+			offset += nand->erasesize - block_offset;
+			continue;
+		}
+
+		if (left_to_read < (nand->erasesize - block_offset))
+			read_length = left_to_read;
+		else
+			read_length = nand->erasesize - block_offset;
+
+		rval = nand_read (nand, offset, &read_length, p_buffer);
+		if (rval != 0) {
+			printf ("NAND read from offset %zx failed %d\n",
+				offset, rval);
+			*length -= left_to_read;
+			return rval;
+		}
+
+		left_to_read -= read_length;
+		offset       += read_length;
+		p_buffer     += read_length;
+	}
+
+	return 0;
+}
diff --git a/drivers/mtd/nand/nomadik.c b/drivers/mtd/nand/nomadik.c
new file mode 100644
index 0000000..b76f4cb
--- /dev/null
+++ b/drivers/mtd/nand/nomadik.c
@@ -0,0 +1,221 @@
+/*
+ * (C) Copyright 2007 STMicroelectronics, <www.st.com>
+ * (C) Copyright 2009 Alessandro Rubini <rubini@unipv.it>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+#include <asm/io.h>
+
+static inline int parity(int b) /* b is really a byte; returns 0 or ~0 */
+{
+	__asm__ __volatile__(
+		"eor   %0, %0, %0, lsr #4\n\t"
+		"eor   %0, %0, %0, lsr #2\n\t"
+		"eor   %0, %0, %0, lsr #1\n\t"
+		"ands  %0, %0, #1\n\t"
+		"subne %0, %0, #2\t"
+		: "=r" (b) : "0" (b));
+	return b;
+}
+
+/*
+ * This is the ECC routine used in hardware, according to the manual.
+ * HW claims to make the calculation but not the correction; so we must
+ * recalculate the bytes for a comparison.
+ */
+static int ecc512(const unsigned char *data, unsigned char *ecc)
+{
+	int gpar = 0;
+	int i, val, par;
+	int pbits = 0;		/* P8, P16, ... P2048 */
+	int pprime = 0;		/* P8', P16', ... P2048' */
+	int lowbits;		/* P1, P2, P4 and primes */
+
+	for (i = 0; i < 512; i++) {
+		par = parity((val = data[i]));
+		gpar ^= val;
+		pbits ^= (i & par);
+	}
+	/*
+	 * Ok, now gpar is global parity (xor of all bytes)
+	 * pbits are all the parity bits (non-prime ones)
+	 */
+	par = parity(gpar);
+	pprime = pbits ^ par;
+	/* Put low bits in the right position for ecc[2] (bits 7..2) */
+	lowbits = 0
+		| (parity(gpar & 0xf0) & 0x80)	/* P4  */
+		| (parity(gpar & 0x0f) & 0x40)	/* P4' */
+		| (parity(gpar & 0xcc) & 0x20)	/* P2  */
+		| (parity(gpar & 0x33) & 0x10)	/* P2' */
+		| (parity(gpar & 0xaa) & 0x08)	/* P1  */
+		| (parity(gpar & 0x55) & 0x04);	/* P1' */
+
+	ecc[2] = ~(lowbits | ((pbits & 0x100) >> 7) | ((pprime & 0x100) >> 8));
+	/* now intermix bits for ecc[1] (P1024..P128') and ecc[0] (P64..P8') */
+	ecc[1] = ~(    (pbits & 0x80) >> 0  | ((pprime & 0x80) >> 1)
+		    | ((pbits & 0x40) >> 1) | ((pprime & 0x40) >> 2)
+		    | ((pbits & 0x20) >> 2) | ((pprime & 0x20) >> 3)
+		    | ((pbits & 0x10) >> 3) | ((pprime & 0x10) >> 4));
+
+	ecc[0] = ~(    (pbits & 0x8) << 4  | ((pprime & 0x8) << 3)
+		    | ((pbits & 0x4) << 3) | ((pprime & 0x4) << 2)
+		    | ((pbits & 0x2) << 2) | ((pprime & 0x2) << 1)
+		    | ((pbits & 0x1) << 1) | ((pprime & 0x1) << 0));
+	return 0;
+}
+
+/* This is the method in the chip->ecc field */
+static int nomadik_ecc_calculate(struct mtd_info *mtd, const uint8_t *dat,
+				 uint8_t *ecc_code)
+{
+	return ecc512(dat, ecc_code);
+}
+
+static int nomadik_ecc_correct(struct mtd_info *mtd, uint8_t *dat,
+				uint8_t *r_ecc, uint8_t *c_ecc)
+{
+	struct nand_chip *chip = mtd->priv;
+	uint32_t r, c, d, diff; /*read, calculated, xor of them */
+
+	if (!memcmp(r_ecc, c_ecc, chip->ecc.bytes))
+		return 0;
+
+	/* Reorder the bytes into ascending-order 24 bits -- see manual */
+	r = r_ecc[2] << 22 | r_ecc[1] << 14 | r_ecc[0] << 6 | r_ecc[2] >> 2;
+	c = c_ecc[2] << 22 | c_ecc[1] << 14 | c_ecc[0] << 6 | c_ecc[2] >> 2;
+	diff = (r ^ c) & ((1<<24)-1); /* use 24 bits only */
+
+	/* If 12 bits are different, one per pair, it's correctable */
+	if (((diff | (diff>>1)) & 0x555555) == 0x555555) {
+		int bit = ((diff & 2) >> 1)
+			| ((diff & 0x8) >> 2) | ((diff & 0x20) >> 3);
+		int byte;
+
+		d = diff >> 6; /* remove bit-order info */
+		byte =  ((d & 2) >> 1)
+			| ((d & 0x8) >> 2) | ((d & 0x20) >> 3)
+			| ((d & 0x80) >> 4) | ((d & 0x200) >> 5)
+			| ((d & 0x800) >> 6) | ((d & 0x2000) >> 7)
+			| ((d & 0x8000) >> 8) | ((d & 0x20000) >> 9);
+		/* correct the single bit */
+		dat[byte] ^= 1<<bit;
+		return 0;
+	}
+	/* If 1 bit only differs, it's one bit error in ECC, ignore */
+	if ((diff ^ (1 << (ffs(diff) - 1))) == 0)
+		return 0;
+	/* Otherwise, uncorrectable */
+	return -1;
+}
+
+static void nomadik_ecc_hwctl(struct mtd_info *mtd, int mode)
+{ /* mandatory in the structure but not used here */ }
+
+
+/* This is the layout used by older installations, we keep compatible */
+struct nand_ecclayout nomadik_ecc_layout = {
+	.eccbytes = 3 * 4,
+	.eccpos = { /* each subpage has 16 bytes: pos 2,3,4 hosts ECC */
+		0x02, 0x03, 0x04,
+		0x12, 0x13, 0x14,
+		0x22, 0x23, 0x24,
+		0x32, 0x33, 0x34},
+	.oobfree = { {0x08, 0x08}, {0x18, 0x08}, {0x28, 0x08}, {0x38, 0x08} },
+};
+
+#define MASK_ALE	(1 << 24)	/* our ALE is AD21 */
+#define MASK_CLE	(1 << 23)	/* our CLE is AD22 */
+
+/* This is copied from the AT91SAM9 devices (Stelian Pop, Lead Tech Design) */
+static void nomadik_nand_hwcontrol(struct mtd_info *mtd,
+				   int cmd, unsigned int ctrl)
+{
+	struct nand_chip *this = mtd->priv;
+	u32 pcr0 = readl(REG_FSMC_PCR0);
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		ulong IO_ADDR_W = (ulong) this->IO_ADDR_W;
+		IO_ADDR_W &= ~(MASK_ALE | MASK_CLE);
+
+		if (ctrl & NAND_CLE)
+			IO_ADDR_W |= MASK_CLE;
+		if (ctrl & NAND_ALE)
+			IO_ADDR_W |= MASK_ALE;
+
+		if (ctrl & NAND_NCE)
+			writel(pcr0 | 0x4, REG_FSMC_PCR0);
+		else
+			writel(pcr0 & ~0x4, REG_FSMC_PCR0);
+
+		this->IO_ADDR_W = (void *) IO_ADDR_W;
+		this->IO_ADDR_R = (void *) IO_ADDR_W;
+	}
+
+	if (cmd != NAND_CMD_NONE)
+		writeb(cmd, this->IO_ADDR_W);
+}
+
+/* Returns 1 when ready; upper layers timeout at 20ms with timer routines */
+static int nomadik_nand_ready(struct mtd_info *mtd)
+{
+	return 1; /* The ready bit is handled in hardware */
+}
+
+/* Copy a buffer 32bits at a time: faster than defualt method which is 8bit */
+static void nomadik_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	int i;
+	struct nand_chip *chip = mtd->priv;
+	u32 *p = (u32 *) buf;
+
+	len >>= 2;
+	writel(0, REG_FSMC_ECCR0);
+	for (i = 0; i < len; i++)
+		p[i] = readl(chip->IO_ADDR_R);
+}
+
+int board_nand_init(struct nand_chip *chip)
+{
+	/* Set up the FSMC_PCR0 for nand access*/
+	writel(0x0000004a, REG_FSMC_PCR0);
+	/* Set up FSMC_PMEM0, FSMC_PATT0 with timing data for access */
+	writel(0x00020401, REG_FSMC_PMEM0);
+	writel(0x00020404, REG_FSMC_PATT0);
+
+	chip->options = NAND_COPYBACK |	NAND_CACHEPRG | NAND_NO_PADDING;
+	chip->cmd_ctrl = nomadik_nand_hwcontrol;
+	chip->dev_ready = nomadik_nand_ready;
+	/* The chip allows 32bit reads, so avoid the default 8bit copy */
+	chip->read_buf = nomadik_nand_read_buf;
+
+	/* ECC: follow the hardware-defined rulse, but do it in sw */
+	chip->ecc.mode = NAND_ECC_HW;
+	chip->ecc.bytes = 3;
+	chip->ecc.size = 512;
+	chip->ecc.layout = &nomadik_ecc_layout;
+	chip->ecc.calculate = nomadik_ecc_calculate;
+	chip->ecc.hwctl = nomadik_ecc_hwctl;
+	chip->ecc.correct = nomadik_ecc_correct;
+
+	return 0;
+}
diff --git a/drivers/mtd/nand/omap_gpmc.c b/drivers/mtd/nand/omap_gpmc.c
new file mode 100644
index 0000000..5f8ed39
--- /dev/null
+++ b/drivers/mtd/nand/omap_gpmc.c
@@ -0,0 +1,353 @@
+/*
+ * (C) Copyright 2004-2008 Texas Instruments, <www.ti.com>
+ * Rohit Choraria <rohitkc@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/errno.h>
+#include <asm/arch/mem.h>
+#include <asm/arch/omap_gpmc.h>
+#include <linux/mtd/nand_ecc.h>
+#include <nand.h>
+
+static uint8_t cs;
+static gpmc_t *gpmc_base = (gpmc_t *)GPMC_BASE;
+static gpmc_csx_t *gpmc_cs_base;
+static struct nand_ecclayout hw_nand_oob = GPMC_NAND_HW_ECC_LAYOUT;
+
+/*
+ * omap_nand_hwcontrol - Set the address pointers corretly for the
+ *			following address/data/command operation
+ */
+static void omap_nand_hwcontrol(struct mtd_info *mtd, int32_t cmd,
+				uint32_t ctrl)
+{
+	register struct nand_chip *this = mtd->priv;
+
+	/*
+	 * Point the IO_ADDR to DATA and ADDRESS registers instead
+	 * of chip address
+	 */
+	switch (ctrl) {
+	case NAND_CTRL_CHANGE | NAND_CTRL_CLE:
+		this->IO_ADDR_W = (void __iomem *)&gpmc_cs_base->nand_cmd;
+		break;
+	case NAND_CTRL_CHANGE | NAND_CTRL_ALE:
+		this->IO_ADDR_W = (void __iomem *)&gpmc_cs_base->nand_adr;
+		break;
+	case NAND_CTRL_CHANGE | NAND_NCE:
+		this->IO_ADDR_W = (void __iomem *)&gpmc_cs_base->nand_dat;
+		break;
+	}
+
+	if (cmd != NAND_CMD_NONE)
+		writeb(cmd, this->IO_ADDR_W);
+}
+
+/*
+ * omap_hwecc_init - Initialize the Hardware ECC for NAND flash in
+ *                   GPMC controller
+ * @mtd:        MTD device structure
+ *
+ */
+static void omap_hwecc_init(struct nand_chip *chip)
+{
+	/*
+	 * Init ECC Control Register
+	 * Clear all ECC | Enable Reg1
+	 */
+	writel(ECCCLEAR | ECCRESULTREG1, &gpmc_base->ecc_control);
+	writel(ECCSIZE1 | ECCSIZE0 | ECCSIZE0SEL, &gpmc_base->ecc_size_config);
+}
+
+/*
+ * gen_true_ecc - This function will generate true ECC value, which
+ * can be used when correcting data read from NAND flash memory core
+ *
+ * @ecc_buf:	buffer to store ecc code
+ *
+ * @return:	re-formatted ECC value
+ */
+static uint32_t gen_true_ecc(uint8_t *ecc_buf)
+{
+	return ecc_buf[0] | (ecc_buf[1] << 16) | ((ecc_buf[2] & 0xF0) << 20) |
+		((ecc_buf[2] & 0x0F) << 8);
+}
+
+/*
+ * omap_correct_data - Compares the ecc read from nand spare area with ECC
+ * registers values and corrects one bit error if it has occured
+ * Further details can be had from OMAP TRM and the following selected links:
+ * http://en.wikipedia.org/wiki/Hamming_code
+ * http://www.cs.utexas.edu/users/plaxton/c/337/05f/slides/ErrorCorrection-4.pdf
+ *
+ * @mtd:		 MTD device structure
+ * @dat:		 page data
+ * @read_ecc:		 ecc read from nand flash
+ * @calc_ecc:		 ecc read from ECC registers
+ *
+ * @return 0 if data is OK or corrected, else returns -1
+ */
+static int omap_correct_data(struct mtd_info *mtd, uint8_t *dat,
+				uint8_t *read_ecc, uint8_t *calc_ecc)
+{
+	uint32_t orig_ecc, new_ecc, res, hm;
+	uint16_t parity_bits, byte;
+	uint8_t bit;
+
+	/* Regenerate the orginal ECC */
+	orig_ecc = gen_true_ecc(read_ecc);
+	new_ecc = gen_true_ecc(calc_ecc);
+	/* Get the XOR of real ecc */
+	res = orig_ecc ^ new_ecc;
+	if (res) {
+		/* Get the hamming width */
+		hm = hweight32(res);
+		/* Single bit errors can be corrected! */
+		if (hm == 12) {
+			/* Correctable data! */
+			parity_bits = res >> 16;
+			bit = (parity_bits & 0x7);
+			byte = (parity_bits >> 3) & 0x1FF;
+			/* Flip the bit to correct */
+			dat[byte] ^= (0x1 << bit);
+		} else if (hm == 1) {
+			printf("Error: Ecc is wrong\n");
+			/* ECC itself is corrupted */
+			return 2;
+		} else {
+			/*
+			 * hm distance != parity pairs OR one, could mean 2 bit
+			 * error OR potentially be on a blank page..
+			 * orig_ecc: contains spare area data from nand flash.
+			 * new_ecc: generated ecc while reading data area.
+			 * Note: if the ecc = 0, all data bits from which it was
+			 * generated are 0xFF.
+			 * The 3 byte(24 bits) ecc is generated per 512byte
+			 * chunk of a page. If orig_ecc(from spare area)
+			 * is 0xFF && new_ecc(computed now from data area)=0x0,
+			 * this means that data area is 0xFF and spare area is
+			 * 0xFF. A sure sign of a erased page!
+			 */
+			if ((orig_ecc == 0x0FFF0FFF) && (new_ecc == 0x00000000))
+				return 0;
+			printf("Error: Bad compare! failed\n");
+			/* detected 2 bit error */
+			return -1;
+		}
+	}
+	return 0;
+}
+
+/*
+ *  omap_calculate_ecc - Generate non-inverted ECC bytes.
+ *
+ *  Using noninverted ECC can be considered ugly since writing a blank
+ *  page ie. padding will clear the ECC bytes. This is no problem as
+ *  long nobody is trying to write data on the seemingly unused page.
+ *  Reading an erased page will produce an ECC mismatch between
+ *  generated and read ECC bytes that has to be dealt with separately.
+ *  E.g. if page is 0xFF (fresh erased), and if HW ECC engine within GPMC
+ *  is used, the result of read will be 0x0 while the ECC offsets of the
+ *  spare area will be 0xFF which will result in an ECC mismatch.
+ *  @mtd:	MTD structure
+ *  @dat:	unused
+ *  @ecc_code:	ecc_code buffer
+ */
+static int omap_calculate_ecc(struct mtd_info *mtd, const uint8_t *dat,
+				uint8_t *ecc_code)
+{
+	u_int32_t val;
+
+	/* Start Reading from HW ECC1_Result = 0x200 */
+	val = readl(&gpmc_base->ecc1_result);
+
+	ecc_code[0] = val & 0xFF;
+	ecc_code[1] = (val >> 16) & 0xFF;
+	ecc_code[2] = ((val >> 8) & 0x0F) | ((val >> 20) & 0xF0);
+
+	/*
+	 * Stop reading anymore ECC vals and clear old results
+	 * enable will be called if more reads are required
+	 */
+	writel(0x000, &gpmc_base->ecc_config);
+
+	return 0;
+}
+
+/*
+ * omap_enable_ecc - This function enables the hardware ecc functionality
+ * @mtd:        MTD device structure
+ * @mode:       Read/Write mode
+ */
+static void omap_enable_hwecc(struct mtd_info *mtd, int32_t mode)
+{
+	struct nand_chip *chip = mtd->priv;
+	uint32_t val, dev_width = (chip->options & NAND_BUSWIDTH_16) >> 1;
+
+	switch (mode) {
+	case NAND_ECC_READ:
+	case NAND_ECC_WRITE:
+		/* Clear the ecc result registers, select ecc reg as 1 */
+		writel(ECCCLEAR | ECCRESULTREG1, &gpmc_base->ecc_control);
+
+		/*
+		 * Size 0 = 0xFF, Size1 is 0xFF - both are 512 bytes
+		 * tell all regs to generate size0 sized regs
+		 * we just have a single ECC engine for all CS
+		 */
+		writel(ECCSIZE1 | ECCSIZE0 | ECCSIZE0SEL,
+			&gpmc_base->ecc_size_config);
+		val = (dev_width << 7) | (cs << 1) | (0x1);
+		writel(val, &gpmc_base->ecc_config);
+		break;
+	default:
+		printf("Error: Unrecognized Mode[%d]!\n", mode);
+		break;
+	}
+}
+
+/*
+ * omap_nand_switch_ecc - switch the ECC operation b/w h/w ecc and s/w ecc.
+ * The default is to come up on s/w ecc
+ *
+ * @hardware - 1 -switch to h/w ecc, 0 - s/w ecc
+ *
+ */
+void omap_nand_switch_ecc(int32_t hardware)
+{
+	struct nand_chip *nand;
+	struct mtd_info *mtd;
+
+	if (nand_curr_device < 0 ||
+	    nand_curr_device >= CONFIG_SYS_MAX_NAND_DEVICE ||
+	    !nand_info[nand_curr_device].name) {
+		printf("Error: Can't switch ecc, no devices available\n");
+		return;
+	}
+
+	mtd = &nand_info[nand_curr_device];
+	nand = mtd->priv;
+
+	nand->options |= NAND_OWN_BUFFERS;
+
+	/* Reset ecc interface */
+	nand->ecc.read_page = NULL;
+	nand->ecc.write_page = NULL;
+	nand->ecc.read_oob = NULL;
+	nand->ecc.write_oob = NULL;
+	nand->ecc.hwctl = NULL;
+	nand->ecc.correct = NULL;
+	nand->ecc.calculate = NULL;
+
+	/* Setup the ecc configurations again */
+	if (hardware) {
+		nand->ecc.mode = NAND_ECC_HW;
+		nand->ecc.layout = &hw_nand_oob;
+		nand->ecc.size = 512;
+		nand->ecc.bytes = 3;
+		nand->ecc.hwctl = omap_enable_hwecc;
+		nand->ecc.correct = omap_correct_data;
+		nand->ecc.calculate = omap_calculate_ecc;
+		omap_hwecc_init(nand);
+		printf("HW ECC selected\n");
+	} else {
+		nand->ecc.mode = NAND_ECC_SOFT;
+		/* Use mtd default settings */
+		nand->ecc.layout = NULL;
+		printf("SW ECC selected\n");
+	}
+
+	/* Update NAND handling after ECC mode switch */
+	nand_scan_tail(mtd);
+
+	nand->options &= ~NAND_OWN_BUFFERS;
+}
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific:
+ * - IO_ADDR_R: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W: address to write the 8 I/O lines of the flash device
+ * - cmd_ctrl: hardwarespecific function for accesing control-lines
+ * - waitfunc: hardwarespecific function for accesing device ready/busy line
+ * - ecc.hwctl: function to enable (reset) hardware ecc generator
+ * - ecc.mode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ */
+int board_nand_init(struct nand_chip *nand)
+{
+	int32_t gpmc_config = 0;
+	cs = 0;
+
+	/*
+	 * xloader/Uboot's gpmc configuration would have configured GPMC for
+	 * nand type of memory. The following logic scans and latches on to the
+	 * first CS with NAND type memory.
+	 * TBD: need to make this logic generic to handle multiple CS NAND
+	 * devices.
+	 */
+	while (cs < GPMC_MAX_CS) {
+		/*
+		 * Each GPMC set for a single CS is at offset 0x30
+		 * - already remapped for us
+		 */
+		gpmc_cs_base = (gpmc_csx_t *)(GPMC_CONFIG_CS0_BASE +
+				(cs * GPMC_CONFIG_WIDTH));
+		/* Check if NAND type is set */
+		if ((readl(&gpmc_cs_base->config1) & 0xC00) ==
+		     0x800) {
+			/* Found it!! */
+			break;
+		}
+		cs++;
+	}
+	if (cs >= GPMC_MAX_CS) {
+		printf("NAND: Unable to find NAND settings in "
+			"GPMC Configuration - quitting\n");
+		return -ENODEV;
+	}
+
+	gpmc_config = readl(&gpmc_base->config);
+	/* Disable Write protect */
+	gpmc_config |= 0x10;
+	writel(gpmc_config, &gpmc_base->config);
+
+	nand->IO_ADDR_R = (void __iomem *)&gpmc_cs_base->nand_dat;
+	nand->IO_ADDR_W = (void __iomem *)&gpmc_cs_base->nand_cmd;
+
+	nand->cmd_ctrl = omap_nand_hwcontrol;
+	nand->options = NAND_NO_PADDING | NAND_CACHEPRG | NAND_NO_AUTOINCR;
+	/* If we are 16 bit dev, our gpmc config tells us that */
+	if ((readl(gpmc_cs_base) & 0x3000) == 0x1000)
+		nand->options |= NAND_BUSWIDTH_16;
+
+	nand->chip_delay = 100;
+	/* Default ECC mode */
+	nand->ecc.mode = NAND_ECC_SOFT;
+
+	return 0;
+}
diff --git a/drivers/mtd/nand/s3c2410_nand.c b/drivers/mtd/nand/s3c2410_nand.c
new file mode 100644
index 0000000..d27a625
--- /dev/null
+++ b/drivers/mtd/nand/s3c2410_nand.c
@@ -0,0 +1,171 @@
+/*
+ * (C) Copyright 2006 OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#if 0
+#define DEBUGN	printf
+#else
+#define DEBUGN(x, args ...) {}
+#endif
+
+#include <nand.h>
+#include <s3c2410.h>
+#include <asm/io.h>
+
+#define __REGb(x)	(*(volatile unsigned char *)(x))
+#define __REGi(x)	(*(volatile unsigned int *)(x))
+
+#define	NF_BASE		0x4e000000
+#define	NFCONF		__REGi(NF_BASE + 0x0)
+#define	NFCMD		__REGb(NF_BASE + 0x4)
+#define	NFADDR		__REGb(NF_BASE + 0x8)
+#define	NFDATA		__REGb(NF_BASE + 0xc)
+#define	NFSTAT		__REGb(NF_BASE + 0x10)
+#define NFECC0		__REGb(NF_BASE + 0x14)
+#define NFECC1		__REGb(NF_BASE + 0x15)
+#define NFECC2		__REGb(NF_BASE + 0x16)
+
+#define S3C2410_NFCONF_EN          (1<<15)
+#define S3C2410_NFCONF_512BYTE     (1<<14)
+#define S3C2410_NFCONF_4STEP       (1<<13)
+#define S3C2410_NFCONF_INITECC     (1<<12)
+#define S3C2410_NFCONF_nFCE        (1<<11)
+#define S3C2410_NFCONF_TACLS(x)    ((x)<<8)
+#define S3C2410_NFCONF_TWRPH0(x)   ((x)<<4)
+#define S3C2410_NFCONF_TWRPH1(x)   ((x)<<0)
+
+#define S3C2410_ADDR_NALE 4
+#define S3C2410_ADDR_NCLE 8
+
+static void s3c2410_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	DEBUGN("hwcontrol(): 0x%02x 0x%02x\n", cmd, ctrl);
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		ulong IO_ADDR_W = NF_BASE;
+
+		if (!(ctrl & NAND_CLE))
+			IO_ADDR_W |= S3C2410_ADDR_NCLE;
+		if (!(ctrl & NAND_ALE))
+			IO_ADDR_W |= S3C2410_ADDR_NALE;
+
+		chip->IO_ADDR_W = (void *)IO_ADDR_W;
+
+		if (ctrl & NAND_NCE)
+			NFCONF &= ~S3C2410_NFCONF_nFCE;
+		else
+			NFCONF |= S3C2410_NFCONF_nFCE;
+	}
+
+	if (cmd != NAND_CMD_NONE)
+		writeb(cmd, chip->IO_ADDR_W);
+}
+
+static int s3c2410_dev_ready(struct mtd_info *mtd)
+{
+	DEBUGN("dev_ready\n");
+	return (NFSTAT & 0x01);
+}
+
+#ifdef CONFIG_S3C2410_NAND_HWECC
+void s3c2410_nand_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	DEBUGN("s3c2410_nand_enable_hwecc(%p, %d)\n", mtd, mode);
+	NFCONF |= S3C2410_NFCONF_INITECC;
+}
+
+static int s3c2410_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
+				      u_char *ecc_code)
+{
+	ecc_code[0] = NFECC0;
+	ecc_code[1] = NFECC1;
+	ecc_code[2] = NFECC2;
+	DEBUGN("s3c2410_nand_calculate_hwecc(%p,): 0x%02x 0x%02x 0x%02x\n",
+		mtd , ecc_code[0], ecc_code[1], ecc_code[2]);
+
+	return 0;
+}
+
+static int s3c2410_nand_correct_data(struct mtd_info *mtd, u_char *dat,
+				     u_char *read_ecc, u_char *calc_ecc)
+{
+	if (read_ecc[0] == calc_ecc[0] &&
+	    read_ecc[1] == calc_ecc[1] &&
+	    read_ecc[2] == calc_ecc[2])
+		return 0;
+
+	printf("s3c2410_nand_correct_data: not implemented\n");
+	return -1;
+}
+#endif
+
+int board_nand_init(struct nand_chip *nand)
+{
+	u_int32_t cfg;
+	u_int8_t tacls, twrph0, twrph1;
+	S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+
+	DEBUGN("board_nand_init()\n");
+
+	clk_power->CLKCON |= (1 << 4);
+
+	/* initialize hardware */
+	twrph0 = 3; twrph1 = 0; tacls = 0;
+
+	cfg = S3C2410_NFCONF_EN;
+	cfg |= S3C2410_NFCONF_TACLS(tacls - 1);
+	cfg |= S3C2410_NFCONF_TWRPH0(twrph0 - 1);
+	cfg |= S3C2410_NFCONF_TWRPH1(twrph1 - 1);
+
+	NFCONF = cfg;
+
+	/* initialize nand_chip data structure */
+	nand->IO_ADDR_R = nand->IO_ADDR_W = (void *)0x4e00000c;
+
+	/* read_buf and write_buf are default */
+	/* read_byte and write_byte are default */
+
+	/* hwcontrol always must be implemented */
+	nand->cmd_ctrl = s3c2410_hwcontrol;
+
+	nand->dev_ready = s3c2410_dev_ready;
+
+#ifdef CONFIG_S3C2410_NAND_HWECC
+	nand->ecc.hwctl = s3c2410_nand_enable_hwecc;
+	nand->ecc.calculate = s3c2410_nand_calculate_ecc;
+	nand->ecc.correct = s3c2410_nand_correct_data;
+	nand->ecc.mode = NAND_ECC_HW3_512;
+#else
+	nand->ecc.mode = NAND_ECC_SOFT;
+#endif
+
+#ifdef CONFIG_S3C2410_NAND_BBT
+	nand->options = NAND_USE_FLASH_BBT;
+#else
+	nand->options = 0;
+#endif
+
+	DEBUGN("end of nand_init\n");
+
+	return 0;
+}
diff --git a/drivers/mtd/nand/s3c64xx.c b/drivers/mtd/nand/s3c64xx.c
new file mode 100644
index 0000000..edaf55a
--- /dev/null
+++ b/drivers/mtd/nand/s3c64xx.c
@@ -0,0 +1,319 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ *
+ * Implementation for U-Boot 1.1.6 by Samsung
+ *
+ * (C) Copyright 2008
+ * Guennadi Liakhovetki, DENX Software Engineering, <lg@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#include <nand.h>
+#include <s3c6400.h>
+
+#include <asm/io.h>
+#include <asm/errno.h>
+
+#define MAX_CHIPS	2
+static int nand_cs[MAX_CHIPS] = {0, 1};
+
+#ifdef CONFIG_NAND_SPL
+#define printf(arg...) do {} while (0)
+#endif
+
+/* Nand flash definition values by jsgood */
+#ifdef S3C_NAND_DEBUG
+/*
+ * Function to print out oob buffer for debugging
+ * Written by jsgood
+ */
+static void print_oob(const char *header, struct mtd_info *mtd)
+{
+	int i;
+	struct nand_chip *chip = mtd->priv;
+
+	printf("%s:\t", header);
+
+	for (i = 0; i < 64; i++)
+		printf("%02x ", chip->oob_poi[i]);
+
+	printf("\n");
+}
+#endif /* S3C_NAND_DEBUG */
+
+#ifdef CONFIG_NAND_SPL
+static u_char nand_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+	return readb(this->IO_ADDR_R);
+}
+
+static void nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+
+	for (i = 0; i < len; i++)
+		writeb(buf[i], this->IO_ADDR_W);
+}
+
+static void nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+
+	for (i = 0; i < len; i++)
+		buf[i] = readb(this->IO_ADDR_R);
+}
+#endif
+
+static void s3c_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+	int ctrl = readl(NFCONT);
+
+	switch (chip) {
+	case -1:
+		ctrl |= 6;
+		break;
+	case 0:
+		ctrl &= ~2;
+		break;
+	case 1:
+		ctrl &= ~4;
+		break;
+	default:
+		return;
+	}
+
+	writel(ctrl, NFCONT);
+}
+
+/*
+ * Hardware specific access to control-lines function
+ * Written by jsgood
+ */
+static void s3c_nand_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+{
+	struct nand_chip *this = mtd->priv;
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		if (ctrl & NAND_CLE)
+			this->IO_ADDR_W = (void __iomem *)NFCMMD;
+		else if (ctrl & NAND_ALE)
+			this->IO_ADDR_W = (void __iomem *)NFADDR;
+		else
+			this->IO_ADDR_W = (void __iomem *)NFDATA;
+		if (ctrl & NAND_NCE)
+			s3c_nand_select_chip(mtd, *(int *)this->priv);
+		else
+			s3c_nand_select_chip(mtd, -1);
+	}
+
+	if (cmd != NAND_CMD_NONE)
+		writeb(cmd, this->IO_ADDR_W);
+}
+
+/*
+ * Function for checking device ready pin
+ * Written by jsgood
+ */
+static int s3c_nand_device_ready(struct mtd_info *mtdinfo)
+{
+	return !!(readl(NFSTAT) & NFSTAT_RnB);
+}
+
+#ifdef CONFIG_SYS_S3C_NAND_HWECC
+/*
+ * This function is called before encoding ecc codes to ready ecc engine.
+ * Written by jsgood
+ */
+static void s3c_nand_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	u_long nfcont, nfconf;
+
+	/*
+	 * The original driver used 4-bit ECC for "new" MLC chips, i.e., for
+	 * those with non-zero ID[3][3:2], which anyway only holds for ST
+	 * (Numonyx) chips
+	 */
+	nfconf = readl(NFCONF) & ~NFCONF_ECC_4BIT;
+
+	writel(nfconf, NFCONF);
+
+	/* Initialize & unlock */
+	nfcont = readl(NFCONT);
+	nfcont |= NFCONT_INITECC;
+	nfcont &= ~NFCONT_MECCLOCK;
+
+	if (mode == NAND_ECC_WRITE)
+		nfcont |= NFCONT_ECC_ENC;
+	else if (mode == NAND_ECC_READ)
+		nfcont &= ~NFCONT_ECC_ENC;
+
+	writel(nfcont, NFCONT);
+}
+
+/*
+ * This function is called immediately after encoding ecc codes.
+ * This function returns encoded ecc codes.
+ * Written by jsgood
+ */
+static int s3c_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
+				  u_char *ecc_code)
+{
+	u_long nfcont, nfmecc0;
+
+	/* Lock */
+	nfcont = readl(NFCONT);
+	nfcont |= NFCONT_MECCLOCK;
+	writel(nfcont, NFCONT);
+
+	nfmecc0 = readl(NFMECC0);
+
+	ecc_code[0] = nfmecc0 & 0xff;
+	ecc_code[1] = (nfmecc0 >> 8) & 0xff;
+	ecc_code[2] = (nfmecc0 >> 16) & 0xff;
+	ecc_code[3] = (nfmecc0 >> 24) & 0xff;
+
+	return 0;
+}
+
+/*
+ * This function determines whether read data is good or not.
+ * If SLC, must write ecc codes to controller before reading status bit.
+ * If MLC, status bit is already set, so only reading is needed.
+ * If status bit is good, return 0.
+ * If correctable errors occured, do that.
+ * If uncorrectable errors occured, return -1.
+ * Written by jsgood
+ */
+static int s3c_nand_correct_data(struct mtd_info *mtd, u_char *dat,
+				 u_char *read_ecc, u_char *calc_ecc)
+{
+	int ret = -1;
+	u_long nfestat0, nfmeccdata0, nfmeccdata1, err_byte_addr;
+	u_char err_type, repaired;
+
+	/* SLC: Write ecc to compare */
+	nfmeccdata0 = (calc_ecc[1] << 16) | calc_ecc[0];
+	nfmeccdata1 = (calc_ecc[3] << 16) | calc_ecc[2];
+	writel(nfmeccdata0, NFMECCDATA0);
+	writel(nfmeccdata1, NFMECCDATA1);
+
+	/* Read ecc status */
+	nfestat0 = readl(NFESTAT0);
+	err_type = nfestat0 & 0x3;
+
+	switch (err_type) {
+	case 0: /* No error */
+		ret = 0;
+		break;
+
+	case 1:
+		/*
+		 * 1 bit error (Correctable)
+		 * (nfestat0 >> 7) & 0x7ff	:error byte number
+		 * (nfestat0 >> 4) & 0x7	:error bit number
+		 */
+		err_byte_addr = (nfestat0 >> 7) & 0x7ff;
+		repaired = dat[err_byte_addr] ^ (1 << ((nfestat0 >> 4) & 0x7));
+
+		printf("S3C NAND: 1 bit error detected at byte %ld. "
+		       "Correcting from 0x%02x to 0x%02x...OK\n",
+		       err_byte_addr, dat[err_byte_addr], repaired);
+
+		dat[err_byte_addr] = repaired;
+
+		ret = 1;
+		break;
+
+	case 2: /* Multiple error */
+	case 3: /* ECC area error */
+		printf("S3C NAND: ECC uncorrectable error detected. "
+		       "Not correctable.\n");
+		ret = -1;
+		break;
+	}
+
+	return ret;
+}
+#endif /* CONFIG_SYS_S3C_NAND_HWECC */
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+int board_nand_init(struct nand_chip *nand)
+{
+	static int chip_n;
+
+	if (chip_n >= MAX_CHIPS)
+		return -ENODEV;
+
+	NFCONT_REG = (NFCONT_REG & ~NFCONT_WP) | NFCONT_ENABLE | 0x6;
+
+	nand->IO_ADDR_R		= (void __iomem *)NFDATA;
+	nand->IO_ADDR_W		= (void __iomem *)NFDATA;
+	nand->cmd_ctrl		= s3c_nand_hwcontrol;
+	nand->dev_ready		= s3c_nand_device_ready;
+	nand->select_chip	= s3c_nand_select_chip;
+	nand->options		= 0;
+#ifdef CONFIG_NAND_SPL
+	nand->read_byte		= nand_read_byte;
+	nand->write_buf		= nand_write_buf;
+	nand->read_buf		= nand_read_buf;
+#endif
+
+#ifdef CONFIG_SYS_S3C_NAND_HWECC
+	nand->ecc.hwctl		= s3c_nand_enable_hwecc;
+	nand->ecc.calculate	= s3c_nand_calculate_ecc;
+	nand->ecc.correct	= s3c_nand_correct_data;
+
+	/*
+	 * If you get more than 1 NAND-chip with different page-sizes on the
+	 * board one day, it will get more complicated...
+	 */
+	nand->ecc.mode		= NAND_ECC_HW;
+	nand->ecc.size		= CONFIG_SYS_NAND_ECCSIZE;
+	nand->ecc.bytes		= CONFIG_SYS_NAND_ECCBYTES;
+#else
+	nand->ecc.mode		= NAND_ECC_SOFT;
+#endif /* ! CONFIG_SYS_S3C_NAND_HWECC */
+
+	nand->priv		= nand_cs + chip_n++;
+
+	return 0;
+}
diff --git a/drivers/mtd/spi/Makefile b/drivers/mtd/spi/Makefile
index af6af97..d9505a9 100644
--- a/drivers/mtd/spi/Makefile
+++ b/drivers/mtd/spi/Makefile
@@ -27,6 +27,10 @@ LIB	:= $(obj)libspi_flash.a
 
 COBJS-$(CONFIG_SPI_FLASH)	+= spi_flash.o
 COBJS-$(CONFIG_SPI_FLASH_ATMEL)	+= atmel.o
+COBJS-$(CONFIG_SPI_FLASH_STMICRO)	+= stmicro.o
+COBJS-$(CONFIG_SPI_FLASH_SPANSION)	+= spansion.o
+COBJS-$(CONFIG_SPI_FLASH_AMIC)	+= amic.o
+COBJS-$(CONFIG_SPI_FLASH_EON)	+= eon.o
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
diff --git a/drivers/mtd/spi/amic.c b/drivers/mtd/spi/amic.c
new file mode 100644
index 0000000..901ad4c
--- /dev/null
+++ b/drivers/mtd/spi/amic.c
@@ -0,0 +1,340 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file amic.c
+* \brief Support for amic spi flash devices.
+*
+* Note: This file is based very heavily on 'stmicro.c'
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#include <common.h>
+#include <malloc.h>
+#include <spi_flash.h>
+
+#include "spi_flash_internal.h"
+
+/* AMIC-specific commands */
+#define CMD_AMIC_WREN       0x06	/* Write Enable */
+#define CMD_AMIC_WRDI	    0x04	/* Write Disable */
+#define CMD_AMIC_RDSR	    0x05	/* Read Status Register */
+#define CMD_AMIC_WRSR	    0x01	/* Write Status Register */
+#define CMD_AMIC_READ	    0x03	/* Read Data Bytes */
+#define CMD_AMIC_FAST_READ  0x0b	/* Read Data Bytes at Higher Speed */
+#define CMD_AMIC_PP	    0x02	/* Page Program */
+#define CMD_AMIC_SE	    0xd8	/* Sector Erase */
+#define CMD_AMIC_BE	    0xc7	/* Bulk Erase */
+#define CMD_AMIC_DP	    0xb9	/* Deep Power-down */
+#define CMD_AMIC_RES	    0xab	/* Release from DP, and Read Signature */
+
+#define AMIC_ID_A25L040     0x13
+#define AMIC_ID_A25L080     0x14
+
+#define AMIC_ID_A25L40P     0x13
+#define AMIC_ID_A25L80P     0x14
+
+#define AMIC_MANUFACTURE_ID     0x37
+#define AMIC_CONTINUATION_ID    0x7F
+
+#define AMIC_SR_WIP	    (1 << 0)	/* Write-in-Progress */
+
+struct amic_spi_flash_params {
+	u8 idcode0;
+        u8 idcode1;
+	u16 page_size;
+	u16 pages_per_sector;
+	u16 nr_sectors;
+	const char *name;
+};
+
+/* spi_flash needs to be first so upper layers can free() it */
+struct amic_spi_flash {
+	struct spi_flash flash;
+        const struct amic_spi_flash_params *params;
+};
+
+static inline struct amic_spi_flash *to_amic_spi_flash(struct spi_flash
+							      *flash)
+{
+	return container_of(flash, struct amic_spi_flash, flash);
+}
+
+static const struct amic_spi_flash_params amic_spi_flash_table[] = {
+	{
+		.idcode0 = AMIC_MANUFACTURE_ID,
+                .idcode1 = AMIC_ID_A25L040,
+		.page_size = 256,
+		.pages_per_sector = 16,
+		.nr_sectors = 128,
+		.name = "A25L040",
+	},
+        {
+		.idcode0 = AMIC_MANUFACTURE_ID,
+                .idcode1 = AMIC_ID_A25L080,
+		.page_size = 256,
+		.pages_per_sector = 16,
+		.nr_sectors = 256,
+		.name = "A25L080",
+	},
+        {
+		.idcode0 = AMIC_CONTINUATION_ID,
+                .idcode1 = AMIC_ID_A25L40P,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 8,
+		.name = "A25L40P",
+	},
+        {
+		.idcode0 = AMIC_CONTINUATION_ID,
+                .idcode1 = AMIC_ID_A25L80P,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 16,
+		.name = "A25L80P",
+	},
+};
+
+static int amic_wait_ready(struct spi_flash *flash,
+                           unsigned long timeout)
+{
+	struct spi_slave *spi = flash->spi;
+	unsigned long timebase;
+	int ret;
+	u8 status;
+
+	timebase = get_timer(0);
+	do {
+		ret = spi_flash_cmd(spi, CMD_AMIC_RDSR, &status, sizeof(status));
+		if (ret)
+			return -1;
+
+		if ((status & AMIC_SR_WIP) == 0)
+			break;
+
+	} while (get_timer(timebase) < timeout);
+
+
+	if ((status & AMIC_SR_WIP) == 0)
+		return 0;
+
+	/* Timed out */
+	return -1;
+}
+
+static int amic_read_fast(struct spi_flash *flash,
+			      u32 offset,
+                              size_t len,
+                              void *buf)
+{
+	struct amic_spi_flash *amic = to_amic_spi_flash(flash);
+	unsigned long page_addr;
+	unsigned long page_size;
+	u8 cmd[5];
+
+	page_size = amic->params->page_size;
+	page_addr = offset / page_size;
+
+	cmd[0] = CMD_READ_ARRAY_FAST;
+	cmd[1] = page_addr >> 8;
+	cmd[2] = page_addr;
+	cmd[3] = offset % page_size;
+	cmd[4] = 0x00;
+
+	return spi_flash_read_common(flash, cmd, sizeof(cmd), buf, len);
+}
+
+static int amic_write(struct spi_flash *flash,
+			  u32 offset,
+                          size_t len,
+                          const void *buf)
+{
+	struct amic_spi_flash *amic = to_amic_spi_flash(flash);
+	unsigned long page_addr;
+	unsigned long byte_addr;
+	unsigned long page_size;
+	size_t chunk_len;
+	size_t actual;
+	int ret;
+	u8 cmd[4];
+
+	page_size = amic->params->page_size;
+	page_addr = offset / page_size;
+	byte_addr = offset % page_size;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	ret = 0;
+	for (actual = 0; actual < len; actual += chunk_len) {
+		chunk_len = min(len - actual, page_size - byte_addr);
+
+		cmd[0] = CMD_AMIC_PP;
+		cmd[1] = page_addr >> 8;
+		cmd[2] = page_addr;
+		cmd[3] = byte_addr;
+
+		debug
+		    ("PP: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x } chunk_len = %d\n",
+		     buf + actual, cmd[0], cmd[1], cmd[2], cmd[3], chunk_len);
+
+		ret = spi_flash_cmd(flash->spi, CMD_AMIC_WREN, NULL, 0);
+		if (ret < 0) {
+			debug("SF: Enabling Write failed\n");
+			break;
+		}
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4,
+					  buf + actual, chunk_len);
+		if (ret < 0) {
+			debug("SF: AMIC Page Program failed\n");
+			break;
+		}
+
+		ret = amic_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
+		if (ret < 0) {
+			debug("SF: AMIC page programming timed out\n");
+			break;
+		}
+
+		page_addr++;
+		byte_addr = 0;
+	}
+
+	debug("SF: AMIC: Successfully programmed %u bytes @ 0x%x\n",
+	      len, offset);
+
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
+int amic_erase(struct spi_flash *flash,
+                   u32 offset,
+                   size_t len)
+{
+	struct amic_spi_flash *amic = to_amic_spi_flash(flash);
+	unsigned long sector_size;
+	size_t actual;
+	int ret;
+	u8 cmd[4];
+
+	/*
+	 * This function currently uses sector erase only.
+	 * probably speed things up by using bulk erase
+	 * when possible.
+	 */
+
+	sector_size = amic->params->page_size * amic->params->pages_per_sector;
+
+	if (offset % sector_size || len % sector_size) {
+		debug("SF: Erase offset/length not multiple of sector size\n");
+		return -1;
+	}
+
+	len /= sector_size;
+	cmd[0] = CMD_AMIC_SE;
+	cmd[2] = 0x00;
+	cmd[3] = 0x00;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	ret = 0;
+	for (actual = 0; actual < len; actual++) {
+		cmd[1] = (offset / sector_size) + actual;
+
+		ret = spi_flash_cmd(flash->spi, CMD_AMIC_WREN, NULL, 0);
+		if (ret < 0) {
+			debug("SF: Enabling Write failed\n");
+			break;
+		}
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4, NULL, 0);
+		if (ret < 0) {
+			debug("SF: AMIC page erase failed\n");
+                        break;
+		}
+
+		/* Up to 2 seconds */
+		ret = amic_wait_ready(flash, SPI_FLASH_PAGE_ERASE_TIMEOUT);
+		if (ret < 0) {
+			debug("SF: AMIC page erase timed out\n");
+                        break;
+		}
+	}
+
+	debug("SF: AMIC: Successfully erased %u bytes @ 0x%x\n",
+	      len * sector_size, offset);
+
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
+struct spi_flash *spi_flash_probe_amic(struct spi_slave *spi,
+                                           u8 * idcode)
+{
+	const struct amic_spi_flash_params *params = NULL;
+	struct amic_spi_flash *amic;
+	unsigned int i = 0;
+
+        if (idcode[0] == AMIC_MANUFACTURE_ID)
+        {
+            for (i = 0; i < ARRAY_SIZE(amic_spi_flash_table); i++) {
+                    params = &amic_spi_flash_table[i];
+                    if ((params->idcode1 == idcode[2]) &&
+                        (params->idcode0 == idcode[0])) {
+                            break;
+                    }
+            }
+        }
+        else if (idcode[0] == AMIC_CONTINUATION_ID)
+        {
+            for (i = 0; i < ARRAY_SIZE(amic_spi_flash_table); i++) {
+                    params = &amic_spi_flash_table[i];
+                    if ((params->idcode1 == idcode[3]) &&
+                        (params->idcode0 == idcode[0])) {
+                            break;
+                    }
+            }
+        }
+
+	if (i == ARRAY_SIZE(amic_spi_flash_table)) {
+		debug("SF: Unsupported AMIC ID %02x\n", idcode[1]);
+		return NULL;
+	}
+
+	amic = malloc(sizeof(struct amic_spi_flash));
+	if (!amic) {
+		debug("SF: Failed to allocate memory\n");
+		return NULL;
+	}
+
+	amic->params = params;
+	amic->flash.spi = spi;
+	amic->flash.name = params->name;
+
+	amic->flash.write = amic_write;
+	amic->flash.erase = amic_erase;
+	amic->flash.read = amic_read_fast;
+	amic->flash.size = params->page_size * params->pages_per_sector
+	     * params->nr_sectors;
+
+	debug("SF: Detected %s with page size %u, total %u bytes\n",
+	      params->name, params->page_size, amic->flash.size);
+
+	return &amic->flash;
+}
diff --git a/drivers/mtd/spi/atmel.c b/drivers/mtd/spi/atmel.c
index 10fcf0c..07116b8 100644
--- a/drivers/mtd/spi/atmel.c
+++ b/drivers/mtd/spi/atmel.c
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2008 Atmel Corporation
  */
-#define DEBUG
+
 #include <common.h>
 #include <malloc.h>
 #include <spi_flash.h>
@@ -39,9 +39,10 @@ struct atmel_spi_flash_params {
 	const char	*name;
 };
 
+/* spi_flash needs to be first so upper layers can free() it */
 struct atmel_spi_flash {
-	const struct atmel_spi_flash_params *params;
 	struct spi_flash flash;
+	const struct atmel_spi_flash_params *params;
 };
 
 static inline struct atmel_spi_flash *
@@ -52,6 +53,54 @@ to_atmel_spi_flash(struct spi_flash *flash)
 
 static const struct atmel_spi_flash_params atmel_spi_flash_table[] = {
 	{
+		.idcode1		= 0x22,
+		.l2_page_size		= 8,
+		.pages_per_block	= 8,
+		.blocks_per_sector	= 16,
+		.nr_sectors		= 4,
+		.name			= "AT45DB011D",
+	},
+	{
+		.idcode1		= 0x23,
+		.l2_page_size		= 8,
+		.pages_per_block	= 8,
+		.blocks_per_sector	= 16,
+		.nr_sectors		= 8,
+		.name			= "AT45DB021D",
+	},
+	{
+		.idcode1		= 0x24,
+		.l2_page_size		= 8,
+		.pages_per_block	= 8,
+		.blocks_per_sector	= 32,
+		.nr_sectors		= 8,
+		.name			= "AT45DB041D",
+	},
+	{
+		.idcode1		= 0x25,
+		.l2_page_size		= 8,
+		.pages_per_block	= 8,
+		.blocks_per_sector	= 32,
+		.nr_sectors		= 16,
+		.name			= "AT45DB081D",
+	},
+	{
+		.idcode1		= 0x26,
+		.l2_page_size		= 9,
+		.pages_per_block	= 8,
+		.blocks_per_sector	= 32,
+		.nr_sectors		= 16,
+		.name			= "AT45DB161D",
+	},
+	{
+		.idcode1		= 0x27,
+		.l2_page_size		= 9,
+		.pages_per_block	= 8,
+		.blocks_per_sector	= 64,
+		.nr_sectors		= 64,
+		.name			= "AT45DB321D",
+	},
+	{
 		.idcode1		= 0x28,
 		.l2_page_size		= 10,
 		.pages_per_block	= 8,
@@ -66,28 +115,21 @@ static int at45_wait_ready(struct spi_flash *flash, unsigned long timeout)
 	struct spi_slave *spi = flash->spi;
 	unsigned long timebase;
 	int ret;
-	u8 cmd = CMD_AT45_READ_STATUS;
 	u8 status;
 
 	timebase = get_timer(0);
-
-	ret = spi_xfer(spi, 8, &cmd, NULL, SPI_XFER_BEGIN);
-	if (ret)
-		return -1;
-
 	do {
-		ret = spi_xfer(spi, 8, NULL, &status, 0);
+		ret = spi_flash_cmd(spi, CMD_AT45_READ_STATUS, &status, sizeof(status));
 		if (ret)
 			return -1;
 
-		if (status & AT45_STATUS_READY)
+		if ((status & AT45_STATUS_READY) == 0)
 			break;
+
 	} while (get_timer(timebase) < timeout);
 
-	/* Deactivate CS */
-	spi_xfer(spi, 0, NULL, NULL, SPI_XFER_END);
 
-	if (status & AT45_STATUS_READY)
+	if ((status & AT45_STATUS_READY) == 0)
 		return 0;
 
 	/* Timed out */
diff --git a/drivers/mtd/spi/eon.c b/drivers/mtd/spi/eon.c
new file mode 100644
index 0000000..168dc1a
--- /dev/null
+++ b/drivers/mtd/spi/eon.c
@@ -0,0 +1,284 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file eon.c
+* \brief Support for Eon Silicon Solutions spi flash devices.
+*
+* Note: This file is based very heavily on 'stmicro.c'
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#include <common.h>
+#include <malloc.h>
+#include <spi_flash.h>
+
+#include "spi_flash_internal.h"
+
+/* EN25Pxx-specific commands */
+#define CMD_EN25PXX_WREN	0x06	/* Write Enable */
+#define CMD_EN25PXX_WRDI	0x04	/* Write Disable */
+#define CMD_EN25PXX_RDSR        0x05    /* Read Status Register */
+#define CMD_EN25PXX_WRSR	0x01	/* Write Status Register */
+#define CMD_EN25PXX_READ	0x03	/* Read Data Bytes */
+#define CMD_EN25PXX_FAST_READ	0x0b	/* Read Data Bytes at Higher Speed */
+#define CMD_EN25PXX_PP		0x02	/* Page Program */
+#define CMD_EN25PXX_SE		0xd8	/* Sector Erase */
+#define CMD_EN25PXX_BE		0xc7	/* Bulk Erase */
+#define CMD_EN25PXX_DP		0xb9	/* Deep Power-down */
+#define CMD_EN25PXX_RES		0xab	/* Release from DP, and Read Signature */
+
+#define EON_ID_EN25F05          0x10
+
+#define EON_SR_WIP		(1 << 0)	/* Write-in-Progress */
+
+struct eon_spi_flash_params {
+	u8 idcode1;
+	u16 page_size;
+	u16 pages_per_sector;
+	u16 nr_sectors;
+	const char *name;
+};
+
+/* spi_flash needs to be first so upper layers can free() it */
+struct eon_spi_flash {
+	struct spi_flash flash;
+	const struct eon_spi_flash_params *params;
+};
+
+static inline struct eon_spi_flash *to_eon_spi_flash(struct spi_flash *flash)
+{
+	return container_of(flash, struct eon_spi_flash, flash);
+}
+
+static const struct eon_spi_flash_params eon_spi_flash_table[] = {
+	{
+		.idcode1 = EON_ID_EN25F05,
+		.page_size = 256,
+		.pages_per_sector = 16,
+		.nr_sectors = 16,
+		.name = "EN25F05",
+	},
+};
+
+static int eon_wait_ready(struct spi_flash *flash, unsigned long timeout)
+{
+	struct spi_slave *spi = flash->spi;
+	unsigned long timebase;
+	int ret;
+	u8 status;
+
+	timebase = get_timer(0);
+	do {
+		ret = spi_flash_cmd(spi, CMD_EN25PXX_RDSR, &status, sizeof(status));
+		if (ret)
+			return -1;
+
+		if ((status & EON_SR_WIP) == 0)
+			break;
+
+	} while (get_timer(timebase) < timeout);
+
+
+	if ((status & EON_SR_WIP) == 0)
+		return 0;
+
+	/* Timed out */
+	return -1;
+}
+
+static int eon_read_fast(struct spi_flash *flash,
+	    	         u32 offset, size_t len, void *buf)
+{
+	struct eon_spi_flash *eon = to_eon_spi_flash(flash);
+	unsigned long page_addr;
+	unsigned long page_size;
+	u8 cmd[5];
+
+	page_size = eon->params->page_size;
+	page_addr = offset / page_size;
+
+	cmd[0] = CMD_READ_ARRAY_FAST;
+	cmd[1] = page_addr >> 8;
+	cmd[2] = page_addr;
+	cmd[3] = offset % page_size;
+	cmd[4] = 0x00;
+
+	return spi_flash_read_common(flash, cmd, sizeof(cmd), buf, len);
+}
+
+static int eon_write(struct spi_flash *flash,
+		     u32 offset, size_t len, const void *buf)
+{
+	struct eon_spi_flash *eon = to_eon_spi_flash(flash);
+	unsigned long page_addr;
+	unsigned long byte_addr;
+	unsigned long page_size;
+	size_t chunk_len;
+	size_t actual;
+	int ret;
+	u8 cmd[4];
+
+	page_size = eon->params->page_size;
+	page_addr = offset / page_size;
+	byte_addr = offset % page_size;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	ret = 0;
+	for (actual = 0; actual < len; actual += chunk_len) {
+		chunk_len = min(len - actual, page_size - byte_addr);
+
+		cmd[0] = CMD_EN25PXX_PP;
+		cmd[1] = page_addr >> 8;
+		cmd[2] = page_addr;
+		cmd[3] = byte_addr;
+
+		debug
+		    ("PP: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x } chunk_len = %d\n",
+		     buf + actual, cmd[0], cmd[1], cmd[2], cmd[3], chunk_len);
+
+		ret = spi_flash_cmd(flash->spi, CMD_EN25PXX_WREN, NULL, 0);
+		if (ret < 0) {
+			debug("SF: Enabling Write failed\n");
+			break;
+		}
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4,
+					  buf + actual, chunk_len);
+		if (ret < 0) {
+			debug("SF: EON Page Program failed\n");
+			break;
+		}
+
+		ret = eon_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
+		if (ret < 0) {
+			debug("SF: EON page programming timed out\n");
+			break;
+		}
+
+		page_addr++;
+		byte_addr = 0;
+	}
+
+	debug("SF: EON: Successfully programmed %u bytes @ 0x%x\n",
+	      len, offset);
+
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
+int eon_erase(struct spi_flash *flash, u32 offset, size_t len)
+{
+	struct eon_spi_flash *eon = to_eon_spi_flash(flash);
+	unsigned long sector_size;
+	size_t actual;
+	int ret;
+	u8 cmd[4];
+
+	/*
+	 * This function currently uses sector erase only.
+	 * probably speed things up by using bulk erase
+	 * when possible.
+	 */
+
+	sector_size = eon->params->page_size * eon->params->pages_per_sector;
+
+	if (offset % sector_size || len % sector_size) {
+		debug("SF: Erase offset/length not multiple of sector size\n");
+		return -1;
+	}
+
+	len /= sector_size;
+	cmd[0] = CMD_EN25PXX_SE;
+	cmd[2] = 0x00;
+	cmd[3] = 0x00;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	ret = 0;
+	for (actual = 0; actual < len; actual++) {
+		cmd[1] = (offset / sector_size) + actual;
+
+		ret = spi_flash_cmd(flash->spi, CMD_EN25PXX_WREN, NULL, 0);
+		if (ret < 0) {
+			debug("SF: Enabling Write failed\n");
+			break;
+		}
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4, NULL, 0);
+		if (ret < 0) {
+			debug("SF: EON page erase failed\n");
+			break;
+		}
+
+		ret = eon_wait_ready(flash, SPI_FLASH_PAGE_ERASE_TIMEOUT);
+		if (ret < 0) {
+			debug("SF: EON page erase timed out\n");
+			break;
+		}
+	}
+
+	debug("SF: EON: Successfully erased %u bytes @ 0x%x\n",
+	      len * sector_size, offset);
+
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
+struct spi_flash *spi_flash_probe_eon(struct spi_slave *spi, u8 * idcode)
+{
+	const struct eon_spi_flash_params *params;
+	struct eon_spi_flash *eon;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(eon_spi_flash_table); i++) {
+		params = &eon_spi_flash_table[i];
+		if (params->idcode1 == idcode[2]) {
+			break;
+		}
+	}
+
+	if (i == ARRAY_SIZE(eon_spi_flash_table)) {
+		debug("SF: Unsupported EON ID %02x\n", idcode[1]);
+		return NULL;
+	}
+
+	eon = malloc(sizeof(struct eon_spi_flash));
+	if (!eon) {
+		debug("SF: Failed to allocate memory\n");
+		return NULL;
+	}
+
+	eon->params = params;
+	eon->flash.spi = spi;
+	eon->flash.name = params->name;
+
+	eon->flash.write = eon_write;
+	eon->flash.erase = eon_erase;
+	eon->flash.read = eon_read_fast;
+	eon->flash.size = (params->page_size *
+                           params->pages_per_sector *
+	                   params->nr_sectors);
+
+	debug("SF: Detected %s with page size %u, total %u bytes\n",
+	      params->name, params->page_size, eon->flash.size);
+
+	return &eon->flash;
+}
diff --git a/drivers/mtd/spi/spansion.c b/drivers/mtd/spi/spansion.c
new file mode 100644
index 0000000..fdb7917
--- /dev/null
+++ b/drivers/mtd/spi/spansion.c
@@ -0,0 +1,350 @@
+/*
+ * Copyright (C) 2009 Freescale Semiconductor, Inc.
+ *
+ * Author: Mingkai Hu (Mingkai.hu@freescale.com)
+ * Based on stmicro.c by Wolfgang Denk (wd@denx.de),
+ * TsiChung Liew (Tsi-Chung.Liew@freescale.com),
+ * and  Jason McMullan (mcmullan@netapp.com)
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <spi_flash.h>
+
+#include "spi_flash_internal.h"
+
+/* S25FLxx-specific commands */
+#define CMD_S25FLXX_READ	0x03	/* Read Data Bytes */
+#define CMD_S25FLXX_FAST_READ	0x0b	/* Read Data Bytes at Higher Speed */
+#define CMD_S25FLXX_READID	0x90	/* Read Manufacture ID and Device ID */
+#define CMD_S25FLXX_WREN	0x06	/* Write Enable */
+#define CMD_S25FLXX_WRDI	0x04	/* Write Disable */
+#define CMD_S25FLXX_RDSR	0x05	/* Read Status Register */
+#define CMD_S25FLXX_WRSR	0x01	/* Write Status Register */
+#define CMD_S25FLXX_PP		0x02	/* Page Program */
+#define CMD_S25FLXX_SE		0xd8	/* Sector Erase */
+#define CMD_S25FLXX_BE		0xc7	/* Bulk Erase */
+#define CMD_S25FLXX_DP		0xb9	/* Deep Power-down */
+#define CMD_S25FLXX_RES		0xab	/* Release from DP, and Read Signature */
+
+#define SPSN_ID_S25FL008A	0x0213
+#define SPSN_ID_S25FL016A	0x0214
+#define SPSN_ID_S25FL032A	0x0215
+#define SPSN_ID_S25FL064A	0x0216
+#define SPSN_ID_S25FL128P	0x2018
+#define SPSN_EXT_ID_S25FL128P_256KB	0x0300
+#define SPSN_EXT_ID_S25FL128P_64KB	0x0301
+
+#define SPANSION_SR_WIP		(1 << 0)	/* Write-in-Progress */
+
+struct spansion_spi_flash_params {
+	u16 idcode1;
+	u16 idcode2;
+	u16 page_size;
+	u16 pages_per_sector;
+	u16 nr_sectors;
+	const char *name;
+};
+
+struct spansion_spi_flash {
+	struct spi_flash flash;
+	const struct spansion_spi_flash_params *params;
+};
+
+static inline struct spansion_spi_flash *to_spansion_spi_flash(struct spi_flash
+							     *flash)
+{
+	return container_of(flash, struct spansion_spi_flash, flash);
+}
+
+static const struct spansion_spi_flash_params spansion_spi_flash_table[] = {
+	{
+		.idcode1 = SPSN_ID_S25FL008A,
+		.idcode2 = 0,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 16,
+		.name = "S25FL008A",
+	},
+	{
+		.idcode1 = SPSN_ID_S25FL016A,
+		.idcode2 = 0,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 32,
+		.name = "S25FL016A",
+	},
+	{
+		.idcode1 = SPSN_ID_S25FL032A,
+		.idcode2 = 0,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 64,
+		.name = "S25FL032A",
+	},
+	{
+		.idcode1 = SPSN_ID_S25FL064A,
+		.idcode2 = 0,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 128,
+		.name = "S25FL064A",
+	},
+	{
+		.idcode1 = SPSN_ID_S25FL128P,
+		.idcode2 = SPSN_EXT_ID_S25FL128P_64KB,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 256,
+		.name = "S25FL128P_64K",
+	},
+	{
+		.idcode1 = SPSN_ID_S25FL128P,
+		.idcode2 = SPSN_EXT_ID_S25FL128P_256KB,
+		.page_size = 256,
+		.pages_per_sector = 1024,
+		.nr_sectors = 64,
+		.name = "S25FL128P_256K",
+	},
+};
+
+static int spansion_wait_ready(struct spi_flash *flash, unsigned long timeout)
+{
+	struct spi_slave *spi = flash->spi;
+	unsigned long timebase;
+	int ret;
+	u8 status;
+
+	timebase = get_timer(0);
+	do {
+		ret = spi_flash_cmd(spi, CMD_S25FLXX_RDSR, &status, sizeof(status));
+		if (ret)
+			return -1;
+
+		if ((status & SPANSION_SR_WIP) == 0)
+			break;
+
+	} while (get_timer(timebase) < timeout);
+
+
+	if ((status & SPANSION_SR_WIP) == 0)
+		return 0;
+
+	/* Timed out */
+	return -1;
+}
+
+static int spansion_read_fast(struct spi_flash *flash,
+			     u32 offset, size_t len, void *buf)
+{
+	struct spansion_spi_flash *spsn = to_spansion_spi_flash(flash);
+	unsigned long page_addr;
+	unsigned long page_size;
+	u8 cmd[5];
+
+	page_size = spsn->params->page_size;
+	page_addr = offset / page_size;
+
+	cmd[0] = CMD_READ_ARRAY_FAST;
+	cmd[1] = page_addr >> 8;
+	cmd[2] = page_addr;
+	cmd[3] = offset % page_size;
+	cmd[4] = 0x00;
+
+	debug
+		("READ: 0x%x => cmd = { 0x%02x 0x%02x%02x%02x%02x } len = 0x%x\n",
+		 offset, cmd[0], cmd[1], cmd[2], cmd[3], cmd[4], len);
+
+	return spi_flash_read_common(flash, cmd, sizeof(cmd), buf, len);
+}
+
+static int spansion_write(struct spi_flash *flash,
+			 u32 offset, size_t len, const void *buf)
+{
+	struct spansion_spi_flash *spsn = to_spansion_spi_flash(flash);
+	unsigned long page_addr;
+	unsigned long byte_addr;
+	unsigned long page_size;
+	size_t chunk_len;
+	size_t actual;
+	int ret;
+	u8 cmd[4];
+
+	page_size = spsn->params->page_size;
+	page_addr = offset / page_size;
+	byte_addr = offset % page_size;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	ret = 0;
+	for (actual = 0; actual < len; actual += chunk_len) {
+		chunk_len = min(len - actual, page_size - byte_addr);
+
+		cmd[0] = CMD_S25FLXX_PP;
+		cmd[1] = page_addr >> 8;
+		cmd[2] = page_addr;
+		cmd[3] = byte_addr;
+
+		debug
+		    ("PP: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x } chunk_len = %d\n",
+		     buf + actual, cmd[0], cmd[1], cmd[2], cmd[3], chunk_len);
+
+		ret = spi_flash_cmd(flash->spi, CMD_S25FLXX_WREN, NULL, 0);
+		if (ret < 0) {
+			debug("SF: Enabling Write failed\n");
+			break;
+		}
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4,
+					  buf + actual, chunk_len);
+		if (ret < 0) {
+			debug("SF: SPANSION Page Program failed\n");
+			break;
+		}
+
+		ret = spansion_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
+		if (ret < 0) {
+			debug("SF: SPANSION page programming timed out\n");
+			break;
+		}
+
+		page_addr++;
+		byte_addr = 0;
+	}
+
+	debug("SF: SPANSION: Successfully programmed %u bytes @ 0x%x\n",
+	      len, offset);
+
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
+int spansion_erase(struct spi_flash *flash, u32 offset, size_t len)
+{
+	struct spansion_spi_flash *spsn = to_spansion_spi_flash(flash);
+	unsigned long sector_size;
+	size_t actual;
+	int ret;
+	u8 cmd[4];
+
+	/*
+	 * This function currently uses sector erase only.
+	 * probably speed things up by using bulk erase
+	 * when possible.
+	 */
+
+	sector_size = spsn->params->page_size * spsn->params->pages_per_sector;
+
+	if (offset % sector_size || len % sector_size) {
+		debug("SF: Erase offset/length not multiple of sector size\n");
+		return -1;
+	}
+
+	len /= sector_size;
+	cmd[0] = CMD_S25FLXX_SE;
+	cmd[2] = 0x00;
+	cmd[3] = 0x00;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	ret = 0;
+	for (actual = 0; actual < len; actual++) {
+		cmd[1] = (offset / sector_size) + actual;
+
+		ret = spi_flash_cmd(flash->spi, CMD_S25FLXX_WREN, NULL, 0);
+		if (ret < 0) {
+			debug("SF: Enabling Write failed\n");
+			break;
+		}
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4, NULL, 0);
+		if (ret < 0) {
+			debug("SF: SPANSION page erase failed\n");
+			break;
+		}
+
+		/* Up to 2 seconds */
+		ret = spansion_wait_ready(flash, SPI_FLASH_PAGE_ERASE_TIMEOUT);
+		if (ret < 0) {
+			debug("SF: SPANSION page erase timed out\n");
+			break;
+		}
+	}
+
+	debug("SF: SPANSION: Successfully erased %u bytes @ 0x%x\n",
+	      len * sector_size, offset);
+
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
+struct spi_flash *spi_flash_probe_spansion(struct spi_slave *spi, u8 *idcode)
+{
+	const struct spansion_spi_flash_params *params;
+	struct spansion_spi_flash *spsn;
+	unsigned int i;
+	unsigned short jedec, ext_jedec;
+
+	jedec = idcode[1] << 8 | idcode[2];
+	ext_jedec = idcode[3] << 8 | idcode[4];
+
+	for (i = 0; i < ARRAY_SIZE(spansion_spi_flash_table); i++) {
+		params = &spansion_spi_flash_table[i];
+		if (params->idcode1 == jedec) {
+			if (params->idcode2 == ext_jedec)
+				break;
+		}
+	}
+
+	if (i == ARRAY_SIZE(spansion_spi_flash_table)) {
+		debug("SF: Unsupported SPANSION ID %04x %04x\n", jedec, ext_jedec);
+		return NULL;
+	}
+
+	spsn = malloc(sizeof(struct spansion_spi_flash));
+	if (!spsn) {
+		debug("SF: Failed to allocate memory\n");
+		return NULL;
+	}
+
+	spsn->params = params;
+	spsn->flash.spi = spi;
+	spsn->flash.name = params->name;
+
+	spsn->flash.write = spansion_write;
+	spsn->flash.erase = spansion_erase;
+	spsn->flash.read = spansion_read_fast;
+	spsn->flash.size = params->page_size * params->pages_per_sector
+	    * params->nr_sectors;
+
+	debug("SF: Detected %s with page size %u, total %u bytes\n",
+	      params->name, params->page_size, spsn->flash.size);
+
+	return &spsn->flash;
+}
diff --git a/drivers/mtd/spi/spi_flash.c b/drivers/mtd/spi/spi_flash.c
index d581cb3..3d03288 100644
--- a/drivers/mtd/spi/spi_flash.c
+++ b/drivers/mtd/spi/spi_flash.c
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2008 Atmel Corporation
  */
-#define DEBUG
+
 #include <common.h>
 #include <malloc.h>
 #include <spi.h>
@@ -101,7 +101,7 @@ struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
 	struct spi_slave *spi;
 	struct spi_flash *flash;
 	int ret;
-	u8 idcode[3];
+	u8 idcode[5];
 
 	spi = spi_setup_slave(bus, cs, max_hz, spi_mode);
 	if (!spi) {
@@ -120,8 +120,8 @@ struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
 	if (ret)
 		goto err_read_id;
 
-	debug("SF: Got idcode %02x %02x %02x\n", idcode[0],
-			idcode[1], idcode[2]);
+	debug("SF: Got idcode %02x %02x %02x %02x %02x\n", idcode[0],
+			idcode[1], idcode[2], idcode[3], idcode[4]);
 
 	switch (idcode[0]) {
 #ifdef CONFIG_SPI_FLASH_SPANSION
@@ -129,11 +129,28 @@ struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
 		flash = spi_flash_probe_spansion(spi, idcode);
 		break;
 #endif
+#ifdef CONFIG_SPI_FLASH_EON
+	case 0x1C:
+		flash = spi_flash_probe_eon(spi, idcode);
+		break;
+#endif
 #ifdef CONFIG_SPI_FLASH_ATMEL
 	case 0x1F:
 		flash = spi_flash_probe_atmel(spi, idcode);
 		break;
 #endif
+#ifdef CONFIG_SPI_FLASH_STMICRO
+	case 0x20:
+		flash = spi_flash_probe_stmicro(spi, idcode);
+		break;
+#endif
+#ifdef CONFIG_SPI_FLASH_AMIC
+	case 0x37:
+                /* Fall through intentional */
+        case 0x7F:
+		flash = spi_flash_probe_amic(spi, idcode);
+		break;
+#endif
 	default:
 		debug("SF: Unsupported manufacturer %02X\n", idcode[0]);
 		flash = NULL;
@@ -158,5 +175,5 @@ err_claim_bus:
 void spi_flash_free(struct spi_flash *flash)
 {
 	spi_free_slave(flash->spi);
-	free(flash);
+        free(flash);
 }
diff --git a/drivers/mtd/spi/spi_flash_internal.h b/drivers/mtd/spi/spi_flash_internal.h
index 1438050..9a98360 100644
--- a/drivers/mtd/spi/spi_flash_internal.h
+++ b/drivers/mtd/spi/spi_flash_internal.h
@@ -4,9 +4,12 @@
  * Copyright (C) 2008 Atmel Corporation
  */
 
-/* Common parameters */
-#define SPI_FLASH_PROG_TIMEOUT		((10 * CFG_HZ) / 1000)
-#define SPI_FLASH_PAGE_ERASE_TIMEOUT	((50 * CFG_HZ) / 1000)
+/* Common parameters -- kind of high, but they should only occur when there
+ * is a problem (and well your system already is broken), so err on the side
+ * of caution in case we're dealing with slower SPI buses and/or processors.
+ */
+#define SPI_FLASH_PROG_TIMEOUT		(2 * CFG_HZ)
+#define SPI_FLASH_PAGE_ERASE_TIMEOUT	(5 * CFG_HZ)
 #define SPI_FLASH_SECTOR_ERASE_TIMEOUT	(10 * CFG_HZ)
 
 /* Common commands */
@@ -43,3 +46,7 @@ int spi_flash_read_common(struct spi_flash *flash, const u8 *cmd,
 /* Manufacturer-specific probe functions */
 struct spi_flash *spi_flash_probe_spansion(struct spi_slave *spi, u8 *idcode);
 struct spi_flash *spi_flash_probe_atmel(struct spi_slave *spi, u8 *idcode);
+struct spi_flash *spi_flash_probe_stmicro(struct spi_slave *spi, u8 *idcode);
+struct spi_flash *spi_flash_probe_amic(struct spi_slave *spi, u8 *idcode);
+struct spi_flash *spi_flash_probe_eon(struct spi_slave *spi, u8 *idcode);
+
diff --git a/drivers/mtd/spi/stmicro.c b/drivers/mtd/spi/stmicro.c
new file mode 100644
index 0000000..19d2563
--- /dev/null
+++ b/drivers/mtd/spi/stmicro.c
@@ -0,0 +1,350 @@
+/*
+ * (C) Copyright 2000-2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * Copyright 2008, Network Appliance Inc.
+ * Jason McMullan <mcmullan@netapp.com>
+ *
+ * Copyright (C) 2004-2007 Freescale Semiconductor, Inc.
+ * TsiChung Liew (Tsi-Chung.Liew@freescale.com)
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <spi_flash.h>
+
+#include "spi_flash_internal.h"
+
+/* M25Pxx-specific commands */
+#define CMD_M25PXX_WREN		0x06	/* Write Enable */
+#define CMD_M25PXX_WRDI		0x04	/* Write Disable */
+#define CMD_M25PXX_RDSR		0x05	/* Read Status Register */
+#define CMD_M25PXX_WRSR		0x01	/* Write Status Register */
+#define CMD_M25PXX_READ		0x03	/* Read Data Bytes */
+#define CMD_M25PXX_FAST_READ	0x0b	/* Read Data Bytes at Higher Speed */
+#define CMD_M25PXX_PP		0x02	/* Page Program */
+#define CMD_M25PXX_SE		0xd8	/* Sector Erase */
+#define CMD_M25PXX_BE		0xc7	/* Bulk Erase */
+#define CMD_M25PXX_DP		0xb9	/* Deep Power-down */
+#define CMD_M25PXX_RES		0xab	/* Release from DP, and Read Signature */
+
+#define STM_ID_M25P05           0x10
+#define STM_ID_M25P16		0x15
+#define STM_ID_M25P20		0x12
+#define STM_ID_M25P32		0x16
+#define STM_ID_M25P40		0x13
+#define STM_ID_M25P64		0x17
+#define STM_ID_M25P80		0x14
+#define STM_ID_M25P128		0x18
+
+#define STMICRO_SR_WIP		(1 << 0)	/* Write-in-Progress */
+
+struct stmicro_spi_flash_params {
+	u8 idcode1;
+	u16 page_size;
+	u16 pages_per_sector;
+	u16 nr_sectors;
+	const char *name;
+};
+
+/* spi_flash needs to be first so upper layers can free() it */
+struct stmicro_spi_flash {
+	struct spi_flash flash;
+	const struct stmicro_spi_flash_params *params;
+};
+
+static inline struct stmicro_spi_flash *to_stmicro_spi_flash(struct spi_flash
+							     *flash)
+{
+	return container_of(flash, struct stmicro_spi_flash, flash);
+}
+
+static const struct stmicro_spi_flash_params stmicro_spi_flash_table[] = {
+	{
+		.idcode1 = STM_ID_M25P05,
+		.page_size = 256,
+		.pages_per_sector = 128,
+		.nr_sectors = 2,
+		.name = "M25P05-A",
+	},
+        {
+		.idcode1 = STM_ID_M25P16,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 32,
+		.name = "M25P16",
+	},
+	{
+		.idcode1 = STM_ID_M25P20,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 4,
+		.name = "M25P20",
+	},
+	{
+		.idcode1 = STM_ID_M25P32,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 64,
+		.name = "M25P32",
+	},
+	{
+		.idcode1 = STM_ID_M25P40,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 8,
+		.name = "M25P40",
+	},
+	{
+		.idcode1 = STM_ID_M25P64,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 128,
+		.name = "M25P64",
+	},
+	{
+		.idcode1 = STM_ID_M25P80,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 16,
+		.name = "M25P80",
+	},
+	{
+		.idcode1 = STM_ID_M25P128,
+		.page_size = 256,
+		.pages_per_sector = 1024,
+		.nr_sectors = 64,
+		.name = "M25P128",
+	},
+};
+
+static int stmicro_wait_ready(struct spi_flash *flash, unsigned long timeout)
+{
+	struct spi_slave *spi = flash->spi;
+	unsigned long timebase;
+	int ret;
+	u8 status;
+
+	timebase = get_timer(0);
+	do {
+		ret = spi_flash_cmd(spi, CMD_M25PXX_RDSR, &status, sizeof(status));
+		if (ret)
+			return -1;
+
+		if ((status & STMICRO_SR_WIP) == 0)
+			break;
+
+	} while (get_timer(timebase) < timeout);
+
+
+	if ((status & STMICRO_SR_WIP) == 0)
+		return 0;
+
+	/* Timed out */
+	return -1;
+}
+
+static int stmicro_read_fast(struct spi_flash *flash,
+			     u32 offset, size_t len, void *buf)
+{
+	struct stmicro_spi_flash *stm = to_stmicro_spi_flash(flash);
+	unsigned long page_addr;
+	unsigned long page_size;
+	u8 cmd[5];
+
+	page_size = stm->params->page_size;
+	page_addr = offset / page_size;
+
+	cmd[0] = CMD_READ_ARRAY_FAST;
+	cmd[1] = page_addr >> 8;
+	cmd[2] = page_addr;
+	cmd[3] = offset % page_size;
+	cmd[4] = 0x00;
+
+	return spi_flash_read_common(flash, cmd, sizeof(cmd), buf, len);
+}
+
+static int stmicro_write(struct spi_flash *flash,
+			 u32 offset, size_t len, const void *buf)
+{
+	struct stmicro_spi_flash *stm = to_stmicro_spi_flash(flash);
+	unsigned long page_addr;
+	unsigned long byte_addr;
+	unsigned long page_size;
+	size_t chunk_len;
+	size_t actual;
+	int ret;
+	u8 cmd[4];
+
+	page_size = stm->params->page_size;
+	page_addr = offset / page_size;
+	byte_addr = offset % page_size;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	ret = 0;
+	for (actual = 0; actual < len; actual += chunk_len) {
+		chunk_len = min(len - actual, page_size - byte_addr);
+
+		cmd[0] = CMD_M25PXX_PP;
+		cmd[1] = page_addr >> 8;
+		cmd[2] = page_addr;
+		cmd[3] = byte_addr;
+
+		debug
+		    ("PP: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x } chunk_len = %d\n",
+		     buf + actual, cmd[0], cmd[1], cmd[2], cmd[3], chunk_len);
+
+		ret = spi_flash_cmd(flash->spi, CMD_M25PXX_WREN, NULL, 0);
+		if (ret < 0) {
+			debug("SF: Enabling Write failed\n");
+			break;
+		}
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4,
+					  buf + actual, chunk_len);
+		if (ret < 0) {
+			debug("SF: STMicro Page Program failed\n");
+			break;
+		}
+
+		ret = stmicro_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
+		if (ret < 0) {
+			debug("SF: STMicro page programming timed out\n");
+			break;
+		}
+
+		page_addr++;
+		byte_addr = 0;
+	}
+
+	debug("SF: STMicro: Successfully programmed %u bytes @ 0x%x\n",
+	      len, offset);
+
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
+int stmicro_erase(struct spi_flash *flash, u32 offset, size_t len)
+{
+	struct stmicro_spi_flash *stm = to_stmicro_spi_flash(flash);
+	unsigned long sector_size;
+	size_t actual;
+	int ret;
+	u8 cmd[4];
+
+	/*
+	 * This function currently uses sector erase only.
+	 * probably speed things up by using bulk erase
+	 * when possible.
+	 */
+
+	sector_size = stm->params->page_size * stm->params->pages_per_sector;
+
+	if (offset % sector_size || len % sector_size) {
+		debug("SF: Erase offset/length not multiple of sector size\n");
+		return -1;
+	}
+
+	len /= sector_size;
+	cmd[0] = CMD_M25PXX_SE;
+	cmd[2] = 0x00;
+	cmd[3] = 0x00;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	ret = 0;
+	for (actual = 0; actual < len; actual++) {
+		cmd[1] = (offset / sector_size) + actual;
+
+		ret = spi_flash_cmd(flash->spi, CMD_M25PXX_WREN, NULL, 0);
+		if (ret < 0) {
+			debug("SF: Enabling Write failed\n");
+			break;
+		}
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4, NULL, 0);
+		if (ret < 0) {
+			debug("SF: STMicro page erase failed\n");
+			break;
+		}
+
+		ret = stmicro_wait_ready(flash, SPI_FLASH_PAGE_ERASE_TIMEOUT);
+		if (ret < 0) {
+			debug("SF: STMicro page erase timed out\n");
+			break;
+		}
+	}
+
+	debug("SF: STMicro: Successfully erased %u bytes @ 0x%x\n",
+	      len * sector_size, offset);
+
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
+struct spi_flash *spi_flash_probe_stmicro(struct spi_slave *spi, u8 * idcode)
+{
+	const struct stmicro_spi_flash_params *params;
+	struct stmicro_spi_flash *stm;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(stmicro_spi_flash_table); i++) {
+		params = &stmicro_spi_flash_table[i];
+		if (params->idcode1 == idcode[2]) {
+			break;
+		}
+	}
+
+	if (i == ARRAY_SIZE(stmicro_spi_flash_table)) {
+		debug("SF: Unsupported STMicro ID %02x\n", idcode[1]);
+		return NULL;
+	}
+
+	stm = malloc(sizeof(struct stmicro_spi_flash));
+	if (!stm) {
+		debug("SF: Failed to allocate memory\n");
+		return NULL;
+	}
+
+	stm->params = params;
+	stm->flash.spi = spi;
+	stm->flash.name = params->name;
+
+	stm->flash.write = stmicro_write;
+	stm->flash.erase = stmicro_erase;
+	stm->flash.read = stmicro_read_fast;
+	stm->flash.size = params->page_size * params->pages_per_sector
+	    * params->nr_sectors;
+
+	debug("SF: Detected %s with page size %u, total %u bytes\n",
+	      params->name, params->page_size, stm->flash.size);
+
+	return &stm->flash;
+}
diff --git a/examples/stubs.c b/examples/stubs.c
index ec53532..cd318e5 100644
--- a/examples/stubs.c
+++ b/examples/stubs.c
@@ -38,6 +38,32 @@ gd_t *global_data;
 "	bctr\n"				\
 	: : "i"(offsetof(gd_t, jt)), "i"(XF_ ## x * sizeof(void *)) : "r11");
 #elif defined(CONFIG_ARM)
+#ifdef BUILD_FOR_THUMB
+/*
+ * r7 holds the pointer to the global_data in a Thumb build,
+ * ip is a call-clobbered register
+ */
+#define EXPORT_FUNC(x) \
+	asm volatile (			\
+        ".globl " #x       "\n"		\
+        "@ Enter ARM mode   \n"         \
+        "push   {r6}        \n"         \
+        "adr    r6,2f       \n"         \
+        "bx     r6          \n"         \
+        ".align             \n"         \
+        ".arm               \n"         \
+        "2:                 \n"         \
+#x                        ":\n"		\
+        "ldr	ip, [r7, %0]\n"		\
+        "ldr	pc, [ip, %1]\n"		\
+        "@ Enter Thumb mode \n"         \
+        "adr    r6,3f + 1   \n"         \
+        "bx     r6          \n"         \
+        ".thumb             \n"         \
+        "3:                 \n"         \
+        "pop    {r6}        \n"         \
+	: : "i"(offsetof(gd_t, jt)), "i"(XF_ ## x * sizeof(void *)) : "ip");
+#else
 /*
  * r8 holds the pointer to the global_data, ip is a call-clobbered
  * register
@@ -49,6 +75,8 @@ gd_t *global_data;
 "	ldr	ip, [r8, %0]\n"		\
 "	ldr	pc, [ip, %1]\n"		\
 	: : "i"(offsetof(gd_t, jt)), "i"(XF_ ## x * sizeof(void *)) : "ip");
+#endif
+
 #elif defined(CONFIG_MIPS)
 /*
  * k0 ($26) holds the pointer to the global_data; t9 ($25) is a call-
diff --git a/include/asm-arm/arch-pc20x/ebi.h b/include/asm-arm/arch-pc20x/ebi.h
new file mode 100644
index 0000000..5abf931
--- /dev/null
+++ b/include/asm-arm/arch-pc20x/ebi.h
@@ -0,0 +1,89 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+ 
+/*****************************************************************************
+ *
+ * Description: picoChip PC20x ARM Subsystem
+ *
+ *              External Bus Interface Register Definitions
+ *
+ *****************************************************************************/ 
+#ifndef __PC20X_EBI_H
+#define __PC20X_EBI_H
+
+#define SdramConRegOffset               0x00
+#define SdramTim0RegOffset              0x04
+#define SdramTim1RegOffset              0x08
+#define SdramCtlRegOffset               0x0C
+#define SdramRefreshRegOffset           0x10
+#define SChipSelRegion0LowRegOffset     0x14
+#define SChipSelRegion1LowRegOffset     0x18
+#define SChipSelRegion2LowRegOffset     0x1C
+#define SChipSelRegion3LowRegOffset     0x20
+#define SChipSelRegion4LowRegOffset     0x24
+#define SChipSelRegion5LowRegOffset     0x28
+#define SChipSelRegion6LowRegOffset     0x2C
+#define SChipSelRegion7LowRegOffset     0x30
+#define SChipSelRegion0HghRegOffset     0x34
+#define SChipSelRegion1HghRegOffset     0x38
+#define SChipSelRegion2HghRegOffset     0x3C
+#define SChipSelRegion3HghRegOffset     0x40
+#define SChipSelRegion4HghRegOffset     0x44
+#define SChipSelRegion5HghRegOffset     0x48
+#define SChipSelRegion6HghRegOffset     0x4C
+#define SChipSelRegion7HghRegOffset     0x50
+#define SMask0RegOffset                 0x54
+#define SMask1RegOffset                 0x58
+#define SMask2RegOffset                 0x5C
+#define SMask3RegOffset                 0x60
+#define SMask4RegOffset                 0x64
+#define SMask5RegOffset                 0x68
+#define SMask6RegOffset                 0x6C
+#define SMask7RegOffset                 0x70
+#define ChipSelAlias0LowRegOffset       0x74
+#define ChipSelAlias1LowRegOffset       0x78
+#define ChipSelAlias0HghRegOffset       0x7C
+#define ChipSelAlias1HghRegOffset       0x80
+#define ChipSelRemap0LowRegOffset       0x84
+#define ChipSelRemap1LowRegOffset       0x88
+#define ChipSelRemap0HghRegOffset       0x8C
+#define ChipSelRemap1HghRegOffset       0x90
+#define StaticMemTimSet0RegOffset       0x94
+#define StaticMemTimSet1RegOffset       0x98
+#define StaticMemTimSet2RegOffset       0x9C
+#define FlashTrpdrRegOffset             0xA0
+#define StaticMemControlRegOffset       0xA4
+#define SyncFlashOpcodeRegOffset        0xA8
+#define ExtendModeRegOffset             0xAC
+#define SyncFlashConfigRegOffset        0xB0
+#define SyncFlashControlRegOffset       0xB4
+#define SyncFlashTimRegOffset           0xB8
+
+/* #define StaticMemTimSet0Value           0x10C74F4F */
+#define StaticMemTimSet0Value           0x10C7174F 
+
+#define WriteProtectAllDisable          0x0000000E
+
+
+#endif /* __PC20X_EBI_H */
diff --git a/include/asm-arm/arch-pc20x/emac.h b/include/asm-arm/arch-pc20x/emac.h
new file mode 100644
index 0000000..6df1d29
--- /dev/null
+++ b/include/asm-arm/arch-pc20x/emac.h
@@ -0,0 +1,306 @@
+/*
+ *  include/asm/arch/svb20x/ethernet.h
+ *
+ *  BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * Description:
+ *
+ * This module provides the network interface to the firecracker EMAC 
+ * hardware.
+ *
+ * References:
+ *
+ * Synopsys DesignWare Ethernet Universal Databook Version 3.2 
+ *  November 2005.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ * v0.01 09nov06    - Initial version
+ */
+
+#ifndef __FIRECRACKER_PC20X_ETHERNET_H
+#define __FIRECRACKER_PC20X_ETHERNET_H
+
+/* Register offsets: */
+#define EMAC_MAC_CONFIG_REG_OFFSET          (0x0000)
+#define EMAC_MAC_FRAME_FLT_REG_OFFSET       (0x0004)
+#define EMAC_MAC_HASH_HIGH_REG_OFFSET       (0x0008)
+#define EMAC_MAC_HASH_LOW_REG_OFFSET        (0x000c)
+#define EMAC_MAC_GMII_ADDR_REG_OFFSET       (0x0010)
+#define EMAC_MAC_GMII_DATA_REG_OFFSET       (0x0014)
+#define EMAC_MAC_FLOW_CONTROL_REG_OFFSET    (0x0018)
+#define EMAC_MAC_VLAN_TAG_REG_OFFSET        (0x001c)
+#define EMAC_MAC_VERSION_REG_OFFSET         (0x0020)
+#define EMAC_MAC_WAKE_FILT_REG_OFFSET       (0x0028)
+#define EMAC_MAC_PMT_REG_OFFSET             (0x002c)
+#define EMAC_MAC_ADDR_N_HIGH_REG_OFFSET(__N)(0x0040 + (0x0008 * __N))
+#define EMAC_MAC_ADDR_N_LOW_REG_OFFSET(__N) (0x0044 + (0x0008 * __N))
+
+#define EMAC_DMA_BUS_MODE_REG_OFFSET        (0x1000)
+#define EMAC_DMA_TX_DEMAND_REG_OFFSET       (0x1004)
+#define EMAC_DMA_RX_DEMAND_REG_OFFSET       (0x1008)
+#define EMAC_DMA_RX_LIST_REG_OFFSET         (0x100c)
+#define EMAC_DMA_TX_LIST_REG_OFFSET         (0x1010)
+#define EMAC_DMA_STATUS_REG_OFFSET          (0x1014)
+#define EMAC_DMA_MODE_REG_OFFSET            (0x1018)
+#define EMAC_DMA_IE_REG_OFFSET              (0x101c)
+#define EMAC_DMA_STATS_REG_OFFSET           (0x1020)
+#define EMAC_DMA_CURR_TX_DESC_REG_OFFSET    (0x1048)
+#define EMAC_DMA_CURR_RX_DESC_REG_OFFSET    (0x104c)
+#define EMAC_DMA_CURR_TX_BUF_REG_OFFSET     (0x1050)
+#define EMAC_DMA_CURR_RX_BUF_REG_OFFSET     (0x1054)
+
+
+/* Register bit definitions: */
+
+/* EMAC_MAC_CONFIG_REG_OFFSET bits: */
+#define EMAC_WATCHDOG_DISABLE               (1 << 23)
+#define EMAC_JABBER_DISABLE                 (1 << 22)
+#define EMAC_FRAME_BURST_ENABLE             (1 << 21)
+#define EMAC_JUMBO_FRAME_ENABLE             (1 << 20)
+#define EMAC_INTER_FRAME_GAP_SHIFT          (17)
+#define EMAC_INTER_FRAME_GAP_MASK           (0x7 << EMAC_INTER_FRAME_GAP_SHIFT)
+#define EMAC_PORT_SELECT                    (1 << 15)
+#define EMAC_SPEED_100                      (1 << 14)
+#define EMAC_DIABLE_RECEIVE_OWN             (1 << 13)
+#define EMAC_LOOP_BACK_MODE                 (1 << 12)
+#define EMAC_DUPLEX_MODE                    (1 << 11)
+#define EMAC_CHECKSUM_OFFLOAD               (1 << 10)
+#define EMAC_DISABLE_RETRY                  (1 << 9)
+#define EMAC_LINK_UP                        (1 << 8)
+#define EMAC_CRC_STRIPPING                  (1 << 7)
+#define EMAC_BACK_OFF_SHIFT                 (5)
+#define EMAC_BACK_OFF_MASK                  (0x3 << EMAC_BACK_OFF_SHIFT)
+#define EMAC_DEFERRAL_CHECK                 (1 << 4)
+#define EMAC_TX_ENABLE                      (1 << 3)
+#define EMAC_RX_ENABLE                      (1 << 2)
+
+/* EMAC_MAC_FRAME_FLT_REG_OFFSET bits: */
+#define EMAC_RECEIVE_ALL                    (1 << 31)
+#define EMAC_SOURCE_FILTER_ENABLE           (1 << 9)
+#define EMAC_SOURCE_INVERSE_FILTER          (1 << 8)
+#define EMAC_PASS_CONTROL_FRAMES_SHIFT      (6)
+#define EMAC_PASS_CONTROL_FRAMES_MASK       (0x3 << EMAC_PASS_CONTROL_FRAMES_SHIFT)
+#define EMAC_DISABLE_BROADCAST              (1 << 5)
+#define EMAC_PASS_ALL_MULTICAST             (1 << 4)
+#define EMAC_INVERSE_FILTER                 (1 << 3)
+#define EMAC_HASH_MULTICAST                 (1 << 2)
+#define EMAC_HASH_UNICAST                   (1 << 1)
+#define EMAC_PROMISCUOUS_MODE               (1 << 0)
+
+
+/* EMAC_MAC_GMII_ADDR_REG_OFFSET bits: */
+#define EMAC_GMII_ADDRESS_SHIFT             (11)
+#define EMAC_GMII_ADDRESS_MASK              (0x1f << EMAC_GMII_ADDRESS_SHIFT)
+#define EMAC_GMII_GMII_REG_SHIFT            (6)
+#define EMAC_GMII_GMII_REG_MASK             (0x1f << EMAC_GMII_GMII_REG_SHIFT)
+#define EMAC_GMII_CSR_CLOCK_SHIFT           (2)
+#define EMAC_GMII_CSR_CLOCK_MASK            (0x7 << EMAC_GMII_CSR_CLOCK_SHIFT)
+#define EMAC_GMII_CSR_RANGE_60_100          (0x0 << EMAC_GMII_CSR_CLOCK_SHIFT)
+#define EMAC_GMII_CSR_RANGE_100_150         (0x1 << EMAC_GMII_CSR_CLOCK_SHIFT)
+#define EMAC_GMII_CSR_RANGE_20_35           (0x2 << EMAC_GMII_CSR_CLOCK_SHIFT)
+#define EMAC_GMII_CSR_RANGE_35_60           (0x3 << EMAC_GMII_CSR_CLOCK_SHIFT)
+#define EMAC_GMII_CSR_RANGE_150_250         (0x4 << EMAC_GMII_CSR_CLOCK_SHIFT)
+#define EMAC_GMII_CSR_RANGE_250_300         (0x5 << EMAC_GMII_CSR_CLOCK_SHIFT)
+#define EMAC_GMII_WRITE                     (1 << 1)
+#define EMAC_GMII_BUSY                      (1 << 0)
+
+
+/* EMAC_MAC_FLOW_CONTROL_REG_OFFSET bits: */
+#define EMAC_PAUSE_TIME_SHIFT               (16)
+#define EMAC_PAUSE_TIME_MASK                (0xffff << EMAC_PAUSE_TIME_SHIFT)
+#define EMAC_PAUSE_LOW_THRESHOLD_SHIFT      (4)
+#define EMAC_PAUSE_LOW_THRESHOLD_MASK       (0x3 << EMAC_PAUSE_LOW_THRESHOLD_SHIFT)
+#define EMAC_UNI_PAUSE_DETECT               (1 << 3)
+#define EMAC_RX_FLOW_ENABLE                 (1 << 2)
+#define EMAC_TX_FLOW_ENABLE                 (1 << 1)
+#define EMAC_FLOW_BUSY                      (1 << 0)
+
+
+/* EMAC_MAC_ADDR_N_HIGH_REG_OFFSET bits: */
+#define EMAC_MAC_ADDR_ENABLE                (1 << 31)
+#define EMAC_MAC_ADDR_SOURCE                (1 << 30)
+#define EMAC_MAC_ADDR_MASK_CNTL_SHIFT       (24)
+#define EMAC_MAC_ADDR_MASK_CNTL_MASK        (0x3f << EMAC_MAC_ADDR_MASK_CNTL_SHIFT)
+
+
+/* EMAC_DMA_BUS_MODE_REG_OFFSET bits: */
+#define EMAC_FIXED_BURST                    (1 << 16)
+#define EMAC_PRIORITY_RATIO_SHIFT           (14)
+#define EMAC_PRIORITY_RATIO_MASK            (0x3 << EMAC_PRIORITY_RATIO_SHIFT)
+#define EMAC_BURST_LENGTH_SHIFT             (8)
+#define EMAC_BURST_LENGTH_MASK              (0x3f << EMAC_BURST_LENGTH_SHIFT)
+#define EMAC_BURST_LENGTH_1                 (0x1 << EMAC_BURST_LENGTH_SHIFT)
+#define EMAC_BURST_LENGTH_2                 (0x2 << EMAC_BURST_LENGTH_SHIFT)
+#define EMAC_BURST_LENGTH_4                 (0x4 << EMAC_BURST_LENGTH_SHIFT)
+#define EMAC_BURST_LENGTH_8                 (0x8 << EMAC_BURST_LENGTH_SHIFT)
+#define EMAC_BURST_LENGTH_16                (0x10 << EMAC_BURST_LENGTH_SHIFT)
+#define EMAC_BURST_LENGTH_32                (0x20 << EMAC_BURST_LENGTH_SHIFT)
+#define EMAC_DMA_SKIP_SHIFT                 (2)
+#define EMAC_DMA_SKIP_MASK                  (0x0000007c)
+#define EMAC_DMA_ARBITRATION                (1 << 1)
+#define EMAC_SOFT_RESET                     (1 << 0)
+
+/* EMAC_DMA_STATUS_REG_OFFSET bits: */
+#define EMAC_GMAC_PMT_INT                   (1 << 28)
+#define EMAC_GMAC_MMC_INT                   (1 << 27)
+#define EMAC_GMAC_LINE_IF_INT               (1 << 26)
+#define EMAC_BUS_ERROR_SHIFT                (23)
+#define EMAC_BUS_ERROR_MASK                 (0x7 << EMAC_BUS_ERROR_SHIFT)
+#define EMAC_DMA_TX_STATE_SHIFT             (20)
+#define EMAC_DMA_TX_STATE_MASK              (0x7 << EMAC_DMA_TX_STATE_SHIFT)
+#define EMAC_DMA_TX_STOPPED                 (0x0 << EMAC_DMA_TX_STATE_SHIFT)
+#define EMAC_DMA_TX_FETCHING                (0x1 << EMAC_DMA_TX_STATE_SHIFT)
+#define EMAC_DMA_TX_WAITING                 (0x2 << EMAC_DMA_TX_STATE_SHIFT)
+#define EMAC_DMA_TX_READING                 (0x3 << EMAC_DMA_TX_STATE_SHIFT)
+#define EMAC_DMA_TX_SUSPENDED               (0x6 << EMAC_DMA_TX_STATE_SHIFT)
+#define EMAC_DMA_TX_RUNNING                 (0x7 << EMAC_DMA_TX_STATE_SHIFT)
+#define EMAC_DMA_RX_STATE_SHIFT             (17)
+#define EMAC_DMA_RX_STATE_MASK              (0x7 << EMAC_DMA_RX_STATE_SHIFT)
+#define EMAC_DMA_RX_STOPPED                 (0x0 << EMAC_DMA_RX_STATE_SHIFT)
+#define EMAC_DMA_RX_FETCHING                (0x1 << EMAC_DMA_RX_STATE_SHIFT)
+#define EMAC_DMA_RX_WAITING                 (0x3 << EMAC_DMA_RX_STATE_SHIFT)
+#define EMAC_DMA_RX_SUSPENDED               (0x4 << EMAC_DMA_RX_STATE_SHIFT)
+#define EMAC_DMA_RX_CLOSING                 (0x5 << EMAC_DMA_RX_STATE_SHIFT)
+#define EMAC_DMA_RX_TRANSFERRING            (0x7 << EMAC_DMA_RX_STATE_SHIFT)
+#define EMAC_NORMAL_SUMM_INT                (1 << 16)
+#define EMAC_ABNORMAL_SUMM_INT              (1 << 15)
+#define EMAC_EARLY_RX_INT                   (1 << 14)
+#define EMAC_FATAL_BUS_ERROR_INT            (1 << 13)
+#define EMAC_EARLY_TX_INT                   (1 << 10)
+#define EMAC_RX_TIMEOUT_INT                 (1 << 9)
+#define EMAC_RX_STOPPED_INT                 (1 << 8)
+#define EMAC_RX_UNAVAILABLE_INT             (1 << 7)
+#define EMAC_RX_INT                         (1 << 6)
+#define EMAC_TX_UNDERFLOW_INT               (1 << 5)
+#define EMAC_RX_OVERFLOW_INT                (1 << 4)
+#define EMAC_TX_JABBER_TIMEOUT_INT          (1 << 3)
+#define EMAC_TX_UNAVAILABLE_INT             (1 << 2)
+#define EMAC_TX_STOPPED_INT                 (1 << 1)
+#define EMAC_TX_INT                         (1 << 0)
+
+
+/* EMAC_DMA_MODE_REG_OFFSET bits: */
+#define EMAC_STORE_FORWARD                  (1 << 21)
+#define EMAC_FLUSH_TX_FIFO                  (1 << 20)
+#define EMAC_TX_THRESHOLD_SHIFT             (14)
+#define EMAC_TX_THRESHOLD_MASK              (0x7 << EMAC_TX_THRESHOLD_SHIFT)
+#define EMAC_START_TX                       (1 << 13)
+#define EMAC_FC_DEACTIVE_SHIFT              (11)
+#define EMAC_FC_DEACTIVE_MASK               (0x3 << EMAC_FC_DEACTIVE_SHIFT)
+#define EMAC_FC_ACTIVE_SHIFT                (9)
+#define EMAC_FC_ACTIVE_MASK                 (0x3 << EMAC_FC_ACTIVE_SHIFT)
+#define EMAC_ENABLE_FLOW_CONTROL            (1 << 8)
+#define EMAC_FORWARD_ERROR_FRAMES           (1 << 7)
+#define EMAC_FORWARD_UNDERSIZE_FRAMES       (1 << 6)
+#define EMAC_RX_THRESHOLD_CONTROL_SHIFT     (1 << 3)
+#define EMAC_RX_THRESHOLD_CONTROL_MASK      (0x3 << EMAC_RX_THRESHOLD_CONTROL_SHIFT)
+#define EMAC_OPERATE_ON_SECOND_FRAME        (1 << 2)
+#define EMAC_START_RX                       (1 << 1)
+
+
+/* EMAC_DMA_IE_REG_OFFSET bits: */
+#define EMAC_NORMAL_SUMM_IE                 (1 << 16)
+#define EMAC_ABNORMAL_SUMM_IE               (1 << 15)
+#define EMAC_EARLY_RX_IE                    (1 << 14)
+#define EMAC_FATAL_BUS_ERROR_IE             (1 << 13)
+#define EMAC_EARLY_TX_IE                    (1 << 10)
+#define EMAC_RX_TIMEOUT_IE                  (1 << 9)
+#define EMAC_RX_STOPPED_IE                  (1 << 8)
+#define EMAC_RX_UNAVAILABLE_IE              (1 << 7)
+#define EMAC_RX_IE                          (1 << 6)
+#define EMAC_TX_UNDERFLOW_IE                (1 << 5)
+#define EMAC_RX_OVERFLOW_IE                 (1 << 4)
+#define EMAC_TX_JABBER_IE                   (1 << 3)
+#define EMAC_TX_UNAVAILABLE_IE              (1 << 2)
+#define EMAC_TX_STOPPED_IE                  (1 << 1)
+#define EMAC_TX_IE                          (1 << 0)
+
+
+/* EMAC_DMA_STATS_REG_OFFSET bits: */
+#define EMAC_OVERFLOW_FIFO_OVERFLOW         (1 << 28)
+#define EMAC_APP_MISSED_SHIFT               (17)
+#define EMAC_APP_MISSED_MASK                (0x7ff << EMAC_MISSED_FRAMES_SHIFT)
+#define EMAC_OVERFLOW_MISSED_FRAMES         (1 << 16)
+#define EMAC_CNTR_MISSED_SHIFT              (0)
+#define EMAC_CNTR_MISSED_MASK               (0xffff << EMAC_CNTR_MISSED_SHIFT)
+
+
+
+/* Descriptor fields: */
+
+/* Transmit/Receive Status: */
+#define EMAC_DESC_STATUS_OWNER              (0x80000000)
+#define EMAC_DESC_STATUS_ERR_SUM            (0x00008000)
+
+/* Transmit Status word: */
+#define EMAC_TX_DESC_STATUS_JABBER_TO       (0x00004000)
+#define EMAC_TX_DESC_STATUS_FLUSHED         (0x00002000)
+#define EMAC_TX_DESC_STATUS_LOSS_CARRIER    (0x00000800)
+#define EMAC_TX_DESC_STATUS_NC              (0x00000400)
+#define EMAC_TX_DESC_STATUS_LC              (0x00000200)
+#define EMAC_TX_DESC_STATUS_EC              (0x00000100)
+#define EMAC_TX_DESC_STATUS_VLAN            (0x00000080)
+#define EMAC_TX_DESC_STATUS_CC_SHIFT        (3)
+#define EMAC_TX_DESC_STATUS_CC_MASK         (0x00000078)
+#define EMAC_TX_DESC_STATUS_ED              (0x00000004)
+#define EMAC_TX_DESC_STATUS_UF              (0x00000002)
+#define EMAC_TX_DESC_STATUS_DB              (0x00000001)
+
+/* Receive Status word: */
+#define EMAC_RX_DESC_STATUS_FAIL_DST_ADDR   (0x40000000)
+#define EMAC_RX_DESC_STATUS_FLEN_SHIFT      (16)
+#define EMAC_RX_DESC_STATUS_FLEN_MASK       (0x3fff0000)
+#define EMAC_RX_DESC_STATUS_DESC_ERR        (0x00004000)
+#define EMAC_RX_DESC_STATUS_FAIL_SRC_ADDR   (0x00002000)
+#define EMAC_RX_DESC_STATUS_LEN_ERR         (0x00001000)
+#define EMAC_RX_DESC_STATUS_OV_ERR          (0x00000800)
+#define EMAC_RX_DESC_STATUS_VLAN            (0x00000400)
+#define EMAC_RX_DESC_STATUS_FIRST_DESC      (0x00000200)
+#define EMAC_RX_DESC_STATUS_LAST_DESC       (0x00000100)
+#define EMAC_RX_DESC_STATUS_IPC_ERR         (0x00000080)
+#define EMAC_RX_DESC_STATUS_LATE_COL        (0x00000040)
+#define EMAC_RX_DESC_STATUS_FRAME_TYPE      (0x00000020)
+#define EMAC_RX_DESC_STATUS_WDT_TIMEOUT     (0x00000010)
+#define EMAC_RX_DESC_STATUS_RX_ERR          (0x00000008)
+#define EMAC_RX_DESC_STATUS_DRIBBLE_ERR     (0x00000004)
+#define EMAC_RX_DESC_STATUS_CRC_ERR         (0x00000002)
+#define EMAC_RX_DESC_STATUS_DST_MATCH_MAC0  (0x00000001)
+
+/* Transmit/Receive Control word: */
+#define EMAC_RX_DESC_CNTL_DISABLE_INT_COM   (0x80000000)    /* Rx only */
+#define EMAC_TX_DESC_CNTL_ENABLE_INT_COM    (0x80000000)    /* Tx only */
+#define EMAC_TX_DESC_CNTL_LAST_SEG          (0x40000000)    /* Tx only */
+#define EMAC_TX_DESC_CNTL_FIRST_SEG         (0x20000000)    /* Tx only */
+#define EMAC_TX_DESC_CNTL_DISABLE_CRC       (0x04000000)    /* Tx only */
+#define EMAC_DESC_CNTL_END_RING             (0x02000000)
+#define EMAC_DESC_CNTL_CHAINED              (0x01000000)
+#define EMAC_TX_DESC_CNTL_DISABLE_PAD       (0x00800000)    /* Tx only */
+#define EMAC_DESC_CNTL_TBS2_SHIFT           (11)
+#define EMAC_DESC_CNTL_TBS2_MASK            (0x003ff800)
+#define EMAC_DESC_CNTL_TBS1_SHIFT           (0)
+#define EMAC_DESC_CNTL_TBS1_MASK            (0x000007ff)
+
+/* EMAC_MAX_MAC_ADDRS defines the number of perfect match addresses
+ * available.
+ */
+#define EMAC_MAX_MAC_ADDRS                      (16)
+
+
+#endif /* __FIRECRACKER_PC20X_ETHERNET_INCLUDED */
+
diff --git a/include/asm-arm/arch-pc20x/gpio.h b/include/asm-arm/arch-pc20x/gpio.h
new file mode 100644
index 0000000..480e9fb
--- /dev/null
+++ b/include/asm-arm/arch-pc20x/gpio.h
@@ -0,0 +1,67 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+ 
+/*****************************************************************************
+ *
+ * Description: picoChip PC20x ARM Subsystem
+ *
+ *              GPIO Register Definitions
+ *
+ *****************************************************************************/ 
+#ifndef __PC20X_GPIO_H
+#define __PC20X_GPIO_H
+
+/* Gpio pins for Port A, numbered 0 to N-1 */
+#define NumberPortAPins                             8
+
+/* Register definitions for GPIO */
+#define GpioPortAOutputDataRegOffset                (0x00)
+#define GpioPortADataDirectionRegOffset             (0x04)
+#define GpioPortAInputDataRegOffset                 (0x50)
+
+/* Register definitions for GPIO interrupts */
+#define GpioPortAInterruptEnableRegOffset           (0x30)
+#define GpioPortAInterruptMaskRegOffset             (0x34)
+#define GpioPortAInterruptLevelRegOffset            (0x38)
+#define GpioPortAInterruptPolarityRegOffset         (0x3c)
+#define GpioPortAInterruptStatusRegOffset           (0x40)
+#define GpioPortAInterruptRawStatusRegOffset        (0x44)
+#define GpioPortAInterruptEOIRegOffset              (0x4c)
+#define GpioPortAInterruptSyncLevelRegOffset        (0x60)
+
+/* Gpio identification register */
+#define GpioIdentifierRegOffset                     (0x64)
+
+
+/* Bit definitions */
+#define Gpio(__N)                                   (0x01 << (__N))
+
+/* Synchronisation level register bits */
+#define SynchroniseLevelInterrupts                  (0x01)
+
+
+#endif /* __PC20X_GPIO_H */
+
+
+
diff --git a/include/asm-arm/arch-pc20x/memif.h b/include/asm-arm/arch-pc20x/memif.h
new file mode 100644
index 0000000..ca9b8b5
--- /dev/null
+++ b/include/asm-arm/arch-pc20x/memif.h
@@ -0,0 +1,145 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+ 
+/*****************************************************************************
+ *
+ * Description: picoChip PC20x ARM Subsystem
+ *
+ *              Memory Interface Register Definitions
+ *
+ *****************************************************************************/ 
+#ifndef __PC20X_MEMIF_H
+#define __PC20X_MEMIF_H
+
+#define MemifpASdBuffer0SetupRegOffset              (0x0000 * 2)
+#define MemifpASdBuffer0AddressSetupRegOffset       (0x0001 * 2)
+#define MemifpASdBuffer0FIFOSetupRegOffset          (0x0002 * 2)
+#define MemifpASdBuffer1SetupRegOffset              (0x0004 * 2)
+#define MemifpASdBuffer1AddressSetupRegOffset       (0x0005 * 2)
+#define MemifpASdBuffer1FIFOSetupRegOffset          (0x0006 * 2)
+#define MemifpASdBuffer2SetupRegOffset              (0x0008 * 2)
+#define MemifpASdBuffer2AddressSetupRegOffset       (0x0009 * 2)
+#define MemifpASdBuffer2FIFOSetupRegOffset          (0x000A * 2)
+#define MemifpASdBuffer3SetupRegOffset              (0x000C * 2)
+#define MemifpASdBuffer3AddressSetupRegOffset       (0x000D * 2)
+#define MemifpASdBuffer3FIFOSetupRegOffset          (0x000E * 2)
+#define MemifpASBuffer0SetupRegOffset               (0x0010 * 2)
+#define MemifpASBuffer0AddressSetupRegOffset        (0x0011 * 2)
+#define MemifpASBuffer0FIFOSetupRegOffset           (0x0012 * 2)
+#define MemifpASBuffer1SetupRegOffset               (0x0014 * 2)
+#define MemifpASBuffer1AddressSetupRegOffset        (0x0015 * 2)
+#define MemifpASBuffer1FIFOSetupRegOffset           (0x0016 * 2)
+#define MemifSdramArbGroup0SlotAConfigRegOffset     (0x0020 * 2)
+#define MemifSdramArbGroup0SlotBConfigRegOffset     (0x0021 * 2)
+#define MemifSdramArbGroup1SlotAConfigRegOffset     (0x0022 * 2)
+#define MemifSdramArbGroup1SlotBConfigRegOffset     (0x0023 * 2)
+#define MemifSdramArbGroup2SlotAConfigRegOffset     (0x0024 * 2)
+#define MemifSdramArbGroup2SlotBConfigRegOffset     (0x0025 * 2)
+#define MemifSdramArbGroup3SlotAConfigRegOffset     (0x0026 * 2)
+#define MemifSdramArbGroup3SlotBConfigRegOffset     (0x0027 * 2)
+#define MemifSdramArbGroup4SlotAConfigRegOffset     (0x0028 * 2)
+#define MemifSdramArbGroup4SlotBConfigRegOffset     (0x0029 * 2)
+#define MemifSdramArbGroup5SlotAConfigRegOffset     (0x002A * 2)
+#define MemifSdramArbGroup5SlotBConfigRegOffset     (0x002B * 2)
+#define MemifSdramArbGroup6SlotAConfigRegOffset     (0x002C * 2)
+#define MemifSdramArbGroup6SlotBConfigRegOffset     (0x002D * 2)
+#define MemifSdramArbGroup7SlotAConfigRegOffset     (0x002E * 2)
+#define MemifSdramArbGroup7SlotBConfigRegOffset     (0x002F * 2)
+#define MemifSdramArbValidGroupsConfigRegOffset     (0x0030 * 2)
+#define MemifSramArbSlotAConfigRegOffset            (0x0040 * 2)
+#define MemifSramArbSlotBConfigRegOffset            (0x0041 * 2)
+#define MemifSramArbSlotCConfigRegOffset            (0x0042 * 2)
+#define MemifSramArbValidSlotsConfigRegOffset       (0x0043 * 2)
+#define MemifArbUpdateRegOffset                     (0x004F * 2)
+#define MemifSdramSetupRegOffset                    (0x0050 * 2)
+#define MemifSdramRefreshRateRegOffset              (0x0051 * 2)
+#define MemifSdramMrsRegOffset                      (0x0052 * 2)
+#define MemifSdramErsRegOffset                      (0x0053 * 2)
+#define MemifSdramSetupCompleteReg                  (0x0054 * 2)
+#define MemifSramSetupCompleteReg                   (0x0055 * 2)
+#define MemifAhbArbPriorityPort0Masters03RegOffset  (0x0060 * 2)
+#define MemifAhbArbPriorityPort0Masters46RegOffset  (0x0061 * 2)
+#define MemifAhbArbPriorityPort1Masters03RegOffset  (0x0062 * 2)
+#define MemifAhbArbPriorityPort1Masters46RegOffset  (0x0063 * 2)
+#define MemifAhbArbPriorityPort2Masters03RegOffset  (0x0064 * 2)
+#define MemifAhbArbPriorityPort2Masters46RegOffset  (0x0065 * 2)
+#define MemifAhbArbPriorityPort3Masters03RegOffset  (0x0066 * 2)
+#define MemifAhbArbPriorityPort3Masters46RegOffset  (0x0067 * 2)
+#define MemifAhbArbPriorityPort4Masters03RegOffset  (0x0068 * 2)
+#define MemifAhbArbPriorityPort4Masters46RegOffset  (0x0069 * 2)
+#define MemifAhbArbitrationSchemeRegOffset          (0x006A * 2)
+#define MemifTestModeEnableRegOffset                (0x0070 * 2)
+#define MemifTestModeWriteDataRegOffset             (0x0071 * 2)
+#define MemifTestModeAddressRegOffset               (0x0072 * 2)
+#define MemifTestModeAddress2RegOffset              (0x0073 * 2)
+#define MemifTestModeControlRegOffset               (0x0074 * 2)
+#define MemifTestModeReadDataRegOffset              (0x0075 * 2)
+#define MemifpABufferStatusRegOffset                (0x0080 * 2)
+                     
+/* DLL register offsets */
+#define DLL0SlaveAdjustRegOffset                     0x0122
+#define DLL1SlaveAdjustRegOffset                     0x0128
+#define DLL2SlaveAdjustRegOffset                     0x012E
+#define DLL3SlaveAdjustRegOffset                     0x0134
+#define DLLConfigUpdateRegOffset                     0x0138
+
+/* Memory Interface constants */
+
+/* _SDRAM_Setup Register */
+#define SdramSize14r10c                             0x00
+#define SdramSize13r10c                             0x01
+#define SdramSize13r9c                              0x10
+#define SdramWidth32                                (0x0 << 2)
+#define SdramWidth16                                (0x1 << 2)
+#define SdramRWGap4                                 (0x4 << 3)
+#define SdramWRGap7                                 (0x7 << 7)
+#define SdramOdtDisabled                            (0x00 << 11)
+#define SdramOdt75Ohm                               (0x01 << 11)
+#define SdramOdt150Ohm                              (0x02 << 11)
+#define SdramCaptureDelay0Mclk	                    (0x00 << 13)
+#define SdramCaptureDelay0_5Mclk	            (0x01 << 13)
+#define SdramCaptureDelay1Mclk	                    (0x02 << 13)
+#define SdramCaptureDelay1_5Mclk	            (0x03 << 13)
+
+/* _SDRAM_Refresh_Rate */
+#define SdramRefreshCount                           0x05DC
+
+/* _SRAM_Config_Done */
+#define SramSetupComplete                           0x0001
+
+/* _SDRAM_Config_Done */
+#define SdramSetupComplete                          0x0001
+
+/* _SDRAM_ERS */
+#define SdramEmrsSetup                              0x0004
+
+/* DLL Registers */
+#define DLL0SlaveAdjustValue                        0x4803
+#define DLL1SlaveAdjustValue                        0x4A03
+#define DLL2SlaveAdjustValue                        0x4A03
+#define DLL3SlaveAdjustValue                        0x4A03
+#define DLLConfigUpdateInProgress                   0x0001
+#define DLLConfigUpdate                             0x0001
+
+#endif /* __PC20X_MEMIF_H */
diff --git a/include/asm-arm/arch-pc20x/pc20x.h b/include/asm-arm/arch-pc20x/pc20x.h
new file mode 100644
index 0000000..1177577
--- /dev/null
+++ b/include/asm-arm/arch-pc20x/pc20x.h
@@ -0,0 +1,49 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+ 
+/*****************************************************************************
+ *
+ * Description: picoChip PC20x ARM Subsystem Peripherals Base Addresses
+ *
+ *****************************************************************************/
+#ifndef __PC20X_H
+#define __PC20X_H
+
+#define PC20X_MEM_IF_BASE       0xffe00000
+#define PC20X_EBI_BASE          0xffe20000
+#define PC20X_UART1_BASE        0xffe40000
+#define PC20X_UART2_BASE        0xffe50000
+#define PC20X_TIMER_BASE        0xffe60000
+#define PC20X_WDOG_BASE         0xffe70000
+#define PC20X_GPIO_BASE         0xffe80000
+#define PC20X_RTC_CLK_BASE      0xffe90000
+#define PC20X_REMAP_BASE        0xffea0000
+#define PC20X_AHB_2_PICO_BASE   0xffec0000
+#define PC20X_DMAC1_BASE        0xfff00000
+#define PC20X_DMAC2_BASE        0xfff10000
+#define PC20X_EMAC_BASE         0xfff60000
+#define PC20X_SLAVE_PROCIF_BASE 0xfffc0000
+#define PC20X_VIC_BASE          0xfffffc00
+
+#endif /* __PC20X_H */
diff --git a/include/asm-arm/arch-pc20x/picoarray.h b/include/asm-arm/arch-pc20x/picoarray.h
new file mode 100644
index 0000000..11223ed
--- /dev/null
+++ b/include/asm-arm/arch-pc20x/picoarray.h
@@ -0,0 +1,84 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*****************************************************************************
+ *
+ * Description: picoChip PC20x ARM Subsystem
+ *
+ *              picoArray Register Definitions
+ *
+ *****************************************************************************/
+#ifndef __PC20X_PICOARRAY_H
+#define __PC20X_PICOARRAY_H
+
+/* Register address offsets from picoArray Base */
+
+/* DMA 0 to 3 available */
+#define PicoDmaNConfigRegOffset(__N)		        (0x00 + 0x0c * (__N))
+#define PicoDmaNStatusRegOffset(__N)                (0x04 + 0x0c * (__N))
+#define PicoDmaNDataRegOffset(__N)                  (0x08 + 0x0c * (__N))
+
+/* GPR 0 to 24 available */
+#define PicoGprNConfigRegOffset(__N)                (0x30 + 0x0c * (__N))
+#define PicoGprNStatusRegOffset(__N)                (0x34 + 0x0c * (__N))
+#define PicoGprNDataRegOffset(__N)                  (0x38 + 0x0c * (__N))
+
+/* ID registers */
+#define PicoGpr25ConfigIDRegOffset                  (0x15c)
+#define PicoGpr25StatusIDRegOffset                  (0x160)
+#define PicoGpr25DataIDRegOffset                    (0x164)
+
+/* Interrupt status */
+/************* TODO - The data sheet is incomplete. Unknown address **********/
+#define PicoInterruptStatusRegOffset                (0x00)  /* TODO Not correct! */   
+
+/* PicoDmaNConfigRegOffset bit definitions. The watermark value can be 0 to 64 */
+#define PicoDmaInterruptEnable                      (0x00000001)
+#define PicoDmaEnable                               (0x00000002)
+#define PicoDmaFIFOWatermarkMask                    (0x000001fc)
+#define PicoDmaFIFOWatermarkN(__N)                  (__N << 2)
+
+/* PicoGprNConfigRegOffset bit definitions. */
+#define PicoGprInterruptEnable                      (0x00000001)
+
+/* PicoDmaNStatusRegOffset bit definitions */
+#define PicoDmaSignalEnable                         (0x00000001)
+#define PicoDmaSignalDirection                      (0x00000002)
+#define PicoDmaSignalBlocking                       (0x00000004)
+#define PicoDmaState                                (0x00000008)
+#define PicoDmaFIFOLevel                            (0x000007f0)
+#define PicoDmaFifoSingle                           (0x00000800)
+
+/* PicoGprNStatusRegOffset bit definitions */
+#define PicoGprSignalEnable                         (0x00000001)
+#define PicoGprSignalDirection                      (0x00000002)
+#define PicoGprSignalBlocking                       (0x00000004)
+#define PicoGprState                                (0x00000008)
+
+/* PicoInterruptStatusRegOffset bit definitions */
+#define PicoDmaNInterruptStatus(__N)                (0x00000001 << __N)
+#define PicoGprNInterruptStatus(__N)                (0x00000010 << __N)
+
+
+#endif /* __PC20X_PICOARRAY_H */
diff --git a/include/asm-arm/arch-pc20x/procif.h b/include/asm-arm/arch-pc20x/procif.h
new file mode 100644
index 0000000..08d1c8d
--- /dev/null
+++ b/include/asm-arm/arch-pc20x/procif.h
@@ -0,0 +1,84 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*****************************************************************************
+ *
+ * Description: picoChip PC20x Procif AHB Slave Register Definitions
+ *
+ *****************************************************************************/
+#ifndef __PC20X_PROCIF_H
+#define __PC20X_PROCIF_H
+ 
+/* Slave AHB Interface Registers */
+
+#define PC20X_PROCIF_BASE           0xFFFF0000	/* Base Address */
+#define ProcifExtTabEnt0RegOffset   0x0020      /* Extended Table Entry #0 */
+#define ProcifExtTabEnt1RegOffset   0x0024      /* Extended Table Entry #1 */
+#define ProcifExtTabEnt2RegOffset   0x0028      /* Extended Table Entry #2 */
+#define ProcifExtTabEnt3RegOffset   0x002C      /* Extended Table Entry #3 */
+#define ProcifExtTabEnt4RegOffset   0x0030      /* Extended Table Entry #4 */
+#define ProcifExtTabEnt5RegOffset   0x0034      /* Extended Table Entry #5 */
+#define ProcifExtTabEnt6RegOffset   0x0038      /* Extended Table Entry #6 */
+#define ProcifExtTabEnt7RegOffset   0x003C      /* Extended Table Entry #7 */
+
+#define ProcifIntGpioRegOffset      0x03FC      /* Internal GPIO register offset */
+	
+#define ProcifGpioARMSofResetIdx    31          /* ARM Sub-System Soft Reset */                                               
+#define ProcifGpioARMSofResetMask   (1<<ProcifGpioARMSofResetIdx)
+
+#define ProcifGpioPicoSofResetIdx   30          /* picoArray Soft Reset */ 
+#define ProcifGpioPicoSofResetMask  (1<<ProcifGpioPicoSofResetIdx)
+
+#define ProcifGpioMemifSofResetIdx  29          /* MEM-IF Soft Reset */
+#define ProcifGpioMemifSofResetMask (1<<ProcifGpioMemifSofResetIdx)
+
+#define ProcifGpioSlaveAHBAccessIdx     28      /* Slave AHB Access Control */ 
+#define ProcifGpioSlaveAHBAccessMask    (1<<ProcifGpioSlaveAHBAccessIdx)
+
+#define ProcifGpioPicoAccessIdx     27          /* picoArray Access Control */ 
+#define ProcifGpioPicoAccessMask    (1<<ProcifGpioPicoAccessIdx)
+
+#define ProcifIRQRequestIdx         6           /* IRQ Request, used to assert an ARM926EJ IRQ via the VIC */
+#define ProcifIRQRequestMask        (1<<ProcifIRQRequestIdx)
+
+#define ProcifWdogPauseIdx          5           /* Watchdog Pause, when asserted pauses the Watchdog Timer's countdown */ 
+#define ProcifWdogPauseMask         (1<<ProcifWdogPauseIdx)
+
+#define ProcifDmac1DreqMuxIdx       4           /* DMAC1 DREQ Mux, allows DMAC1's DREQ[1] & [3] source to be selected in master mode */
+#define ProcifDmac1DreqMuxMask      (1<<ProcifDmac1DreqMuxIdx)
+
+#define ProcifDmac2DreqMuxIdx       3           /* DMAC2 DREQ Mux, allows DMAC2's DREQ[1] & [3] source to be selected in master mode */
+#define ProcifDmac2DreqMuxMask      (1<<ProcifDmac2DreqMuxIdx)
+
+#define ProcifReverseMIIEnablePinIdx    2       /* Reverse MII Enable Pin N/A Returns the value of the Reverse MII Block enable pin */
+#define ProcifReverseMIIEnablePinMask   (1<<ProcifReverseMIIEnablePinIdx)
+
+#define ProcifEthernetBootModePinIdx    1 	/* Ethernet Boot Mode Pin N/A Returns the value of the Ethernet Boot mode input pin */
+#define ProcifEthernetBootModePinMask   (1<<ProcifEthernetBootModePinIdx)
+
+#define ProcifSlaveMasterModePinIdx     0       /* Slave/Master Mode Pin N/A Returns the value of the Slave/Master mode input pin */
+#define ProcifSlaveMasterModePinMask    (1<<ProcifSlaveMasterModePinIdx)
+
+#endif /* __PC20X_PROCIF_H */
+
diff --git a/include/asm-arm/arch-pc20x/rap.h b/include/asm-arm/arch-pc20x/rap.h
new file mode 100644
index 0000000..d3b5ed4
--- /dev/null
+++ b/include/asm-arm/arch-pc20x/rap.h
@@ -0,0 +1,61 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*****************************************************************************
+ *
+ * Description: picoChip PC20x ARM Subsystem
+ *
+ *              Remap Block Register Definitions
+ *
+ *****************************************************************************/
+#ifndef __PC20X_RAP_H
+#define __PC20X_RAP_H
+ 
+#define RapPauseModeRegOffset   0x00
+#define RapIdCodeRegOffset	0x04
+#define RapRemapModeRegOffset	0x08
+#define RapResetStatusRegOffset	0x0c
+#define RapResetStatusClrOffset	0x10
+#define RapCompVersionOffset	0x14
+
+#define RapIdCodeValue		0x00000000
+
+#define RapResetStatusSoftIdx	0
+#define RapResetStatusWdogIdx	1
+#define RapResetStatusGlblIdx	2
+
+#define RapResetStatusSoftMask	(1 << RapResetStatusSoftIdx)
+#define RapResetStatusWdogMask	(1 << RapResetStatusWdogIdx)
+#define RapResetStatusGlblMask	(1 << RapResetStatusGlblIdx)
+
+#define RapPauseModeRegReset	0x00000000
+#define RapIdCodeRegReset	RapIdCodeValue
+#define RapRemapModeRegReset	0x00000000
+#define RapResetStatusRegReset	0x00000000
+#define RapResetStatusClrReset	0x00000000
+#define RapCompVersionReset	0x3230322b
+
+#define REMAP_NORMAL_MODE       0x00000001
+
+#endif /* __PC20X_RAP_H */
diff --git a/include/asm-arm/arch-pc20x/rtc.h b/include/asm-arm/arch-pc20x/rtc.h
new file mode 100644
index 0000000..cd28483
--- /dev/null
+++ b/include/asm-arm/arch-pc20x/rtc.h
@@ -0,0 +1,56 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*****************************************************************************
+ *
+ * Description: picoChip PC20x ARM Subsystem
+ *
+ *              Real Time Clock Register Definitions
+ *
+ *****************************************************************************/
+#ifndef __PC20X_RTC_H
+#define __PC20X_RTC_H
+
+/* Register address offsets from RTC Base */
+#define RtcCurrectCounterValueRegOffset         (0x00)
+#define RtcCounterMatchRegOffset                (0x04)
+#define RtcCounterLoadRegOffset                 (0x08)
+#define RtcCounterControlRegOffset              (0x0c)
+#define RtcInterruptStatusRegOffset             (0x10)
+#define RtcRawInterruptStatusRegOffset          (0x14)
+#define RtcInterruptEOIRegOffset                (0x18)
+#define RtcComponentVersionRegOffset            (0x1c)
+
+/* RtcCounterControlRegOffset bit definitions */
+#define InterruptEnable                         (0x01)
+#define InterruptMask                           (0x02)
+
+/* Interrupt bits */
+#define RtcInterrupt                            (0x01)
+
+
+#endif /* __PC20X_RTC_H */
+
+
+
diff --git a/include/asm-arm/arch-pc20x/sizes.h b/include/asm-arm/arch-pc20x/sizes.h
new file mode 100644
index 0000000..ed30b79
--- /dev/null
+++ b/include/asm-arm/arch-pc20x/sizes.h
@@ -0,0 +1,59 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA0 2111-1307
+ * USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *		   from .s file by awk -f s2h.awk
+ */
+/*  Size defintions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h			1
+
+/* Useful sizes (all specified in Bytes)*/
+#define SZ_128      0x00000080
+#define SZ_256      0x00000100
+#define SZ_512      0x00000200
+
+#define SZ_1K       0x00000400
+#define SZ_2K       0x00000800
+#define SZ_4K	    0x00001000
+#define SZ_8K	    0x00002000
+#define SZ_16K	    0x00004000
+#define SZ_32K      0x00008000
+#define SZ_64K	    0x00010000
+#define SZ_128K	    0x00020000
+#define SZ_256K	    0x00040000
+#define SZ_512K	    0x00080000
+
+#define SZ_1M	    0x00100000
+#define SZ_2M	    0x00200000
+#define SZ_4M	    0x00400000
+#define SZ_8M	    0x00800000
+#define SZ_16M	    0x01000000
+#define SZ_32M	    0x02000000
+#define SZ_64M	    0x04000000
+#define SZ_128M	    0x08000000
+#define SZ_256M	    0x10000000
+#define SZ_512M	    0x20000000
+
+#define SZ_1G	    0x40000000
+#define SZ_2G	    0x80000000
+
+#endif	/* __sizes_h */
diff --git a/include/asm-arm/arch-pc20x/timer.h b/include/asm-arm/arch-pc20x/timer.h
new file mode 100644
index 0000000..9fea3ad
--- /dev/null
+++ b/include/asm-arm/arch-pc20x/timer.h
@@ -0,0 +1,63 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+ 
+/*****************************************************************************
+ *
+ * Description: picoChip PC20x ARM Subsystem
+ *
+ *              Timer Register Definitions
+ *
+ *****************************************************************************/ 
+#ifndef __PC20X_TIMER_H
+#define __PC20X_TIMER_H
+
+/* The number of timers in the hardware, numbered 0 to N-1 */
+#define TimerNumberOfTimers                         4
+
+/* Register definitions for the timers */
+#define TimerNLoadCountRegOffset(__N)               (0x0000 + (0x14 * (__N)))
+#define TimerNCurrentValueRegOffset(__N)            (0x0004 + (0x14 * (__N)))
+#define TimerNControlRegOffset(__N)                 (0x0008 + (0x14 * (__N)))
+#define TimerNEOIRegOffset(__N)                     (0x000c + (0x14 * (__N)))
+#define TimerNInterruptStatusRegOffset(__N)         (0x0010 + (0x14 * (__N)))
+
+/* Timer N control register bit definitions */
+#define TimerEnable                                 (0x00000001)
+#define TimerMode                                   (0x00000002)
+#define TimerInterruptMask                          (0x00000004)
+
+
+/* Register definitions for global timer registers */
+#define TimersInterruptStatusRegOffset              (0x00a0)
+#define TimersEOIRegOffset                          (0x00a4)
+#define TimersRawInterruptStatusRegOffset           (0x00a8)
+
+/* Global Timer Registers bit definitions */
+#define Timer(__N)                                  (0x00000001 << (__N))
+
+
+#endif /* __PC20X_TIMER_H */
+
+
+
diff --git a/include/asm-arm/arch-pc20x/uart.h b/include/asm-arm/arch-pc20x/uart.h
new file mode 100644
index 0000000..fad8a38
--- /dev/null
+++ b/include/asm-arm/arch-pc20x/uart.h
@@ -0,0 +1,176 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*****************************************************************************
+ *
+ * Description: picoChip PC20x ARM Subsystem
+ *
+ *              UART Register Definitions
+ *
+ *****************************************************************************/
+#ifndef __PC20X_UART_H
+#define __PC20X_UART_H
+
+/* Register address offsets from UART Base */
+#define UartRXBufferRegOffset		0x00
+#define UartTXHoldingRegOffset		0x00
+#define UartDivisorLowRegOffset		0x00
+#define UartDivisorHighRegOffset	0x04
+#define UartIntEnableRegOffset		0x04
+#define UartIntIdentityRegOffset	0x08
+#define UartFIFOCtrlRegOffset		0x08
+#define UartLineCtrlRegOffset		0x0c
+#define UartModemCtrlRegOffset		0x10
+#define UartLineStatusRegOffset		0x14
+#define UartModemStatusRegOffset	0x18
+#define UartScratchRegOffset		0x1c
+
+#define UartShadowRXBufferRegOffset	0x30 /* not available in this implementation */
+#define UartShadowTXHoldingRegOffset	0x30 /* not available in this implementation */
+
+#define UartFIFOAccessRegOffset		0x70 /* not available in this implementation */
+#define UartTXFIFOReadRegOffset		0x74 /* not available in this implementation */
+#define UartRXFIFOWriteRegOffset	0x78 /* not available in this implementation */
+#define UartUartStatusRegOffset		0x7c
+#define UartTXFIFOLevelRegOffset	0x80 /* not available in this implementation */
+#define UartRXFIFOLevelRegOffset	0x84 /* not available in this implementation */
+#define UartSoftResetRegOffset		0x88 /* not available in this implementation */
+
+
+#define UartShadowRTSRegOffset			0x8c
+#define UartShadowBrkCtrlRegOffset		0x90
+#define UartShadowDMAModeRegOffset		0x94
+#define UartShadowFIFOEnableRegOffset		0x98
+#define UartShadowRCVRTriggerRegOffset		0x9c
+#define UartShadowTXEmptyTriggerRegOffset	0xa0
+#define UartHaltTXRegOffset			0xa4
+#define UartDMASoftAckRegOffset			0xa8
+#define UartCompParamRegOffset			0xf4
+#define UartUartVersionRegOffset		0xf8
+#define UartCompTypeRegOffset			0xfc
+
+/* DLL & DLH */
+#define UartDivisorMask                 0xFF
+
+/* IER */ 
+#define UartIntEnablePTIMEIdx		0x7	/* Programmable THRE Interrupt Mode Enable that can be */
+						/*  written to only when THRE_MODE_USER == Enabled, */
+						/*  always readable. This is used to enable/disable the */
+						/*  generation of THRE Interrupt. */
+#define UartIntEnableEDSSIIdx		0x3	/*  R/W Enable Modem Status Interrupt. */
+#define UartIntEnableELSIIdx		0x2	/*  R/W Enable Receiver Line Status Interrupt. */
+#define UartIntEnableETBEIIdx		0x1	/*  R/W Enable Transmit Holding Register Empty Interrupt. */
+#define UartIntEnableERBFIIdx		0x0	/*  R/W Enable Received Data Available Interrupt. */
+
+#define UartIntEnablePTIMEMask		(1 << UartIntEnablePTIMEIdx)
+#define UartIntEnableEDSSIMask          (1 << UartIntEnableEDSSIIdx)		
+#define UartIntEnableELSIMask		(1 << UartIntEnableELSIIdx)    		
+#define UartIntEnableETBEIMask		(1 << UartIntEnableETBEIIdx)		
+#define UartIntEnableERBFIMask		(1 << UartIntEnableERBFIIdx)		
+	
+/* IIR */
+#define UartIntIdentityMask		0x0F
+#define UartIntIdentityModemStatus	0x00
+#define UartIntIdentityNone		0x01
+#define UartIntIdentityTHREmpty		0x02
+#define UartIntIdentityRXData		0x04
+#define UartIntIdentityRXLineStatus 	0x06
+#define UartIntIdentityBusyDetect 	0x07
+#define UartIntIdentityCharacterTimeout	0x0C
+
+/* FCR */
+#define UartFIFOCtrlRCVRMask		0xC0
+#define UartFIFOCtrlRCVR1Char		0x00
+#define UartFIFOCtrlRCVRQuarterFull	0x40
+#define UartFIFOCtrlRCVRHalfFull	0x80
+#define UartFIFOCtrlRCVR2LessThanFull	0xC0
+
+#define UartFIFOCtrlTXEmptyMask		0x30
+#define UartFIFOCtrlTXEmptyEmpty	0x00
+#define UartFIFOCtrlTXEmpty2Chars	0x10
+#define UartFIFOCtrlTXEmptyQuarterFull	0x20
+#define UartFIFOCtrlTXEmptyHalfFull	0x30
+
+#define UartFIFOCtrlEnable		0x01	/* fifo enable bit */
+
+
+/* LCR indices */
+#define UartLineCtrlDLABIdx		7	/* Divisor latch access bit */
+#define UartLineCtrlBrkIdx		6 
+#define UartLineCtrlEPSIdx		4 
+#define UartLineCtrlPENIdx		3 
+#define UartLineCtrlStopIdx		2 
+#define UartLineCtrlDLSIdx		0 
+
+/* LCR bit masks */
+#define UartLineCtrlDLABMask		(1 << UartLineCtrlDLABIdx)
+#define UartLineCtrlBrkMask		(1 << UartLineCtrlBrkIdx)      
+#define UartLineCtrlEPSMask		(1 << UartLineCtrlEPSIdx)      
+#define UartLineCtrlPENMask		(1 << UartLineCtrlPENIdx)      
+#define UartLineCtrlStopMask            (1 << UartLineCtrlStopIdx)
+#define UartLineCtrlDLSMask		3 
+#define UartLineCtrlDLS8bits		3	/* 8 bit data length */
+#define UartLineCtrlDLS7bits		2	/* 7 bit data length */
+#define UartLineCtrlDLS6bits		1	/* 6 bit data length */
+#define UartLineCtrlDLS5bits		0	/* 5 bit data length */
+
+#define UartLineCtrl1StopBit            ~(UartLineCtrlStopMask)
+#define UartLineCtrlParityDisable       ~(UartLineCtrlPENMask)
+
+
+/* MCR indices */
+#define UartModemCtrlLoopBackIdx	4
+#define UartModemCtrlOut2Idx		3
+#define UartModemCtrlOut1Idx		2
+#define UartModemCtrlCTSIdx		1
+#define UartModemCtrlDTRIdx		0
+
+/* MCR bit masks */
+#define UartModemCtrlLoopBackMask	(1 << UartModemCtrlLoopBackIdx)
+#define UartModemCtrlOut2Mask		(1 << UartModemCtrlOut2Idx)    
+#define UartModemCtrlOut1Mask		(1 << UartModemCtrlOut1Idx)    
+#define UartModemCtrlCTSMask		(1 << UartModemCtrlCTSIdx)     
+#define UartModemCtrlDTRMask		(1 << UartModemCtrlDTRIdx)     
+
+#define UartModemStatusCTSIdx		4	/* CTS input */
+#define UartModemStatusDCTSIdx		0	/* change in CTS input since last read */
+
+#define UartLineStatusTHREIdx		5
+#define UartLineStatusDataReadyIdx	0
+#define UartLineStatusTHREMask		(1 << UartLineStatusTHREIdx)
+#define UartLineStatusDataReadyMask	(1 << UartLineStatusDataReadyIdx)
+
+#define UartUartStatusRFFIdx		4	/* RX FIFO full */
+#define UartUartStatusRFNEIdx		3	/* RX FIFO not empty */
+#define UartUartStatusTFEIdx		2 
+#define UartUartStatusTFNFIdx		1 
+#define UartUartStatusBusyIdx		0 
+
+#define UartUartStatusRFFMask		(1 << UartUartStatusRFFIdx)    
+#define UartUartStatusRFNEMask		(1 << UartUartStatusRFNEIdx)
+#define UartUartStatusTFEMask		(1 << UartUartStatusTFEIdx)    
+#define UartUartStatusTFNFMask		(1 << UartUartStatusTFNFIdx)
+#define UartUartStatusBusyMask		(1 << UartUartStatusBusyIdx)
+
+#endif /* __PC20X_UART_H */
diff --git a/include/asm-arm/arch-pc20x/wdog.h b/include/asm-arm/arch-pc20x/wdog.h
new file mode 100644
index 0000000..d0e21f1
--- /dev/null
+++ b/include/asm-arm/arch-pc20x/wdog.h
@@ -0,0 +1,96 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*****************************************************************************
+ *
+ * Description: picoChip PC20x ARM Subsystem
+ *
+ *              Watchdog Timer Register Definitions
+ *
+ *****************************************************************************/
+#ifndef __PC20X_WDOG_H
+#define __PC20X_WDOG_H
+
+/* Register address offsets from Watchdog Base */
+#define WdtControlRegOffset                     (0x00)
+#define WdtTimeoutRangeRegOffset                (0x04)
+#define WdtCurrectCounterValueRegOffset         (0x08)
+#define WdtCounterRestartRegOffset              (0x0c)
+#define WdtInterruptStatusRegOffset             (0x10)
+#define WdtInterruptEOIRegOffset                (0x14)
+
+/* WDT_CR register bit definitions */
+#define EnableWdt                               (0x01)
+#define ResponseModeInterrupt                   (0x02)
+#define ResponseModeReset                       ~(ResponseModeInterrupt)
+#define ResetPulseLength2pclk                   (0x00 << 2)
+#define ResetPulseLength4pclk                   (0x01 << 2)
+#define ResetPulseLength8pclk                   (0x02 << 2)
+#define ResetPulseLength16pclk                  (0x03 << 2)
+#define ResetPulseLength32pclk                  (0x04 << 2)
+#define ResetPulseLength64pclk                  (0x05 << 2)
+#define ResetPulseLength128pclk                 (0x06 << 2)
+#define ResetPulseLength256pclk                 (0x07 << 2)
+
+/* WDT_TORR register bit definitions */
+#define TimeoutPeriod64K                        (0x00 << 0)
+#define TimeoutPeriod128K                       (0x01 << 0)
+#define TimeoutPeriod256K                       (0x02 << 0)
+#define TimeoutPeriod512K                       (0x03 << 0)
+#define TimeoutPeriod1M                         (0x04 << 0)
+#define TimeoutPeriod2M                         (0x05 << 0)
+#define TimeoutPeriod4M                         (0x06 << 0)
+#define TimeoutPeriod8M                         (0x07 << 0)
+#define TimeoutPeriod16M                        (0x08 << 0)
+#define TimeoutPeriod32M                        (0x09 << 0)
+#define TimeoutPeriod64M                        (0x0a << 0)
+#define TimeoutPeriod128M                       (0x0b << 0)
+#define TimeoutPeriod256M                       (0x0c << 0)
+#define TimeoutPeriod512M                       (0x0d << 0)
+#define TimeoutPeriod1G                         (0x0e << 0)
+#define TimeoutPeriod2G                         (0x0f << 0)
+#define FirstTimeoutPeriod64K                   (0x00 << 4)
+#define FirstTimeoutPeriod128K                  (0x01 << 4)
+#define FirstTimeoutPeriod256K                  (0x02 << 4)
+#define FirstTimeoutPeriod512K                  (0x03 << 4)
+#define FirstTimeoutPeriod1M                    (0x04 << 4)
+#define FirstTimeoutPeriod2M                    (0x05 << 4)
+#define FirstTimeoutPeriod4M                    (0x06 << 4)
+#define FirstTimeoutPeriod8M                    (0x07 << 4)
+#define FirstTimeoutPeriod16M                   (0x08 << 4)
+#define FirstTimeoutPeriod32M                   (0x09 << 4)
+#define FirstTimeoutPeriod64M                   (0x0a << 4)
+#define FirstTimeoutPeriod128M                  (0x0b << 4)
+#define FirstTimeoutPeriod256M                  (0x0c << 4)
+#define FirstTimeoutPeriod512M                  (0x0d << 4)
+#define FirstTimeoutPeriod1G                    (0x0e << 4)
+#define FirstTimeoutPeriod2G                    (0x0f << 4)
+
+/* WDT_CRR register bit definitions */
+#define WDOG_RESTART                            (0x76)
+
+/* WDT_EOI register bits */
+#define WDOG_INTERRUPT                          (0x01)
+
+#endif /* __PC20X_WDOG_H */
diff --git a/include/asm-arm/arch-pc20x/wdt.h b/include/asm-arm/arch-pc20x/wdt.h
new file mode 100644
index 0000000..92f8d94
--- /dev/null
+++ b/include/asm-arm/arch-pc20x/wdt.h
@@ -0,0 +1,103 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*****************************************************************************
+ *
+ * Description: picoChip PC20x ARM Subsystem
+ *
+ *              Watchdog Timer Register Definitions
+ *
+ *****************************************************************************/
+#ifndef __PC20X_WDT_H
+#define __PC20X_WDT_H
+
+/* Register address offsets from WDT Base */
+#define WdtControlRegOffset                     (0x00)
+#define WdtTimeoutRangeRegOffset                (0x04)
+#define WdtCurrectCounterValueRegOffset         (0x08)
+#define WdtCounterRestartRegOffset              (0x0c)
+#define WdtInterruptStatusRegOffset             (0x10)
+#define WdtInterruptEOIRegOffset                (0x14)
+
+
+/* WdtControlRegOffset register bit definitions */
+#define EnableWdt                               (0x01)
+#define ResponseMode                            (0x02)
+#define ResetPulseLength2pclk                   (0x00 << 2)
+#define ResetPulseLength4pclk                   (0x01 << 2)
+#define ResetPulseLength8pclk                   (0x02 << 2)
+#define ResetPulseLength16pclk                  (0x03 << 2)
+#define ResetPulseLength32pclk                  (0x04 << 2)
+#define ResetPulseLength64pclk                  (0x05 << 2)
+#define ResetPulseLength128pclk                 (0x06 << 2)
+#define ResetPulseLength256pclk                 (0x07 << 2)
+
+/* WdtTimeoutRangeRegOffset register bit definitions */
+#define TimeoutPeriod64K                        (0x00 << 0)
+#define TimeoutPeriod128K                       (0x01 << 0)
+#define TimeoutPeriod256K                       (0x02 << 0)
+#define TimeoutPeriod512K                       (0x03 << 0)
+#define TimeoutPeriod1M                         (0x04 << 0)
+#define TimeoutPeriod2M                         (0x05 << 0)
+#define TimeoutPeriod4M                         (0x06 << 0)
+#define TimeoutPeriod8M                         (0x07 << 0)
+#define TimeoutPeriod16M                        (0x08 << 0)
+#define TimeoutPeriod32M                        (0x09 << 0)
+#define TimeoutPeriod64M                        (0x0a << 0)
+#define TimeoutPeriod128M                       (0x0b << 0)
+#define TimeoutPeriod256M                       (0x0c << 0)
+#define TimeoutPeriod512M                       (0x0d << 0)
+#define TimeoutPeriod1G                         (0x0e << 0)
+#define TimeoutPeriod2G                         (0x0f << 0)
+#define FirstTimeoutPeriod64K                   (0x00 << 4)
+#define FirstTimeoutPeriod128K                  (0x01 << 4)
+#define FirstTimeoutPeriod256K                  (0x02 << 4)
+#define FirstTimeoutPeriod512K                  (0x03 << 4)
+#define FirstTimeoutPeriod1M                    (0x04 << 4)
+#define FirstTimeoutPeriod2M                    (0x05 << 4)
+#define FirstTimeoutPeriod4M                    (0x06 << 4)
+#define FirstTimeoutPeriod8M                    (0x07 << 4)
+#define FirstTimeoutPeriod16M                   (0x08 << 4)
+#define FirstTimeoutPeriod32M                   (0x09 << 4)
+#define FirstTimeoutPeriod64M                   (0x0a << 4)
+#define FirstTimeoutPeriod128M                  (0x0b << 4)
+#define FirstTimeoutPeriod256M                  (0x0c << 4)
+#define FirstTimeoutPeriod512M                  (0x0d << 4)
+#define FirstTimeoutPeriod1G                    (0x0e << 4)
+#define FirstTimeoutPeriod2G                    (0x0f << 4)
+
+/* WdtCounterRestartRegOffset register timer restart code.
+ * To restart the WDT, set this value.
+ */
+#define KickWdt                                 (0x76)
+
+/* WdtInterruptStatusRegOffset register bits */
+#define WdtInterrupt                            (0x01)
+
+
+
+#endif /* __PC20X_WDT_H */
+
+
+
diff --git a/include/asm-arm/arch-pc302/axi2cfg.h b/include/asm-arm/arch-pc302/axi2cfg.h
new file mode 100644
index 0000000..42312bf
--- /dev/null
+++ b/include/asm-arm/arch-pc302/axi2cfg.h
@@ -0,0 +1,162 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file axi2cfg.h
+* \brief Definitions for the PC302 AXI2CFG Block.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef PC302_AXI2CFG_H
+#define PC302_AXI2CFG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+/* Functional Registers */
+
+#define AXI2CFG_SYS_CONFIG_REG_OFFSET               (0x0000)
+#define AXI2CFG_JTAG_ISC_REG_OFFSET                 (0x0004)
+#define AXI2CFG_IRQ_REG_OFFSET                      (0x0008)
+#define AXI2CFG_PURGE_CFG_PORT_REG_OFFSET           (0x000C)
+#define AXI2CFG_DMA_CFG_REG_OFFSET                  (0x0010)
+#define AXI2CFG_DEVICE_ID_REG_OFFSET                (0x0014)
+#define AXI2CFG_REVISION_ID_REG_OFFSET              (0x0018)
+#define AXI2CFG_CONFIG_WRITE_REG_OFFSET             (0x0100)
+#define AXI2CFG_CONFIG_READ_REG_OFFSET              (0x0200)
+#define AXI2CFG_DMAC1_CONFIG_REG_OFFSET             (0x0300)
+
+
+/*****************************************************************************/
+/* Register Bit Fields		                                             */
+/*****************************************************************************/
+
+#define AXI2CFG_SYS_CONFIG_PA_RST_IDX               (30)
+#define AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_SZ       (8)
+#define AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_HI       (23)
+#define AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO       (16)
+#define AXI2CFG_SYS_CONFIG_RW_EBI_CLK_DISABLE_IDX   (15)
+#define AXI2CFG_SYS_CONFIG_RW_EXCVEC_EN_IDX         (14)
+#define AXI2CFG_SYS_CONFIG_RW_RMII_EN_IDX           (13)
+#define AXI2CFG_SYS_CONFIG_RW_REVMII_EN_IDX         (12)
+#define AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_SZ           (4)
+#define AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_HI           (11)
+#define AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_LO           (8)
+#define AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_IDX       (7)
+#define AXI2CFG_SYS_CONFIG_MASK_AXI_ERR_IDX         (6)
+#define AXI2CFG_SYS_CONFIG_RW_REMAP_IDX             (5)
+#define AXI2CFG_SYS_CONFIG_WDG_PAUSE_IDX            (4)
+#define AXI2CFG_SYS_CONFIG_DMAC1_CH6_IDX            (3)
+#define AXI2CFG_SYS_CONFIG_DMAC1_CH7_IDX            (2)
+#define AXI2CFG_SYS_CONFIG_BOOT_MODE_SZ             (2)
+#define AXI2CFG_SYS_CONFIG_BOOT_MODE_HI             (1)
+#define AXI2CFG_SYS_CONFIG_BOOT_MODE_LO             (0)
+
+#define AXI2CFG_SYS_CONFIG_PA_RST_MASK              (1 << AXI2CFG_SYS_CONFIG_PA_RST_IDX)
+#define AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_MASK         (((1 << AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_SZ)-1) << AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO)
+#define AXI2CFG_SYS_CONFIG_RW_EXCVEC_EN_MASK        (1 << AXI2CFG_SYS_CONFIG_RW_EXCVEC_EN_IDX)
+#define AXI2CFG_SYS_CONFIG_RW_RMII_EN_MASK          (1 << AXI2CFG_SYS_CONFIG_RW_RMII_EN_IDX)
+#define AXI2CFG_SYS_CONFIG_RW_REVMII_EN_MASK        (1 << AXI2CFG_SYS_CONFIG_RW_REVMII_EN_IDX)
+#define AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_MASK         (((1 << AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_SZ)-1) << AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_LO)
+#define AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK      (1<<AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_IDX)
+#define AXI2CFG_SYS_CONFIG_MASK_AXI_ERR_MASK        (1 << AXI2CFG_SYS_CONFIG_MASK_AXI_ERR_IDX)
+#define AXI2CFG_SYS_CONFIG_RW_REMAP_MASK            (1 << AXI2CFG_SYS_CONFIG_RW_REMAP_IDX)
+#define AXI2CFG_SYS_CONFIG_WDG_PAUSE_MASK           (1 << AXI2CFG_SYS_CONFIG_WDG_PAUSE_IDX)
+#define AXI2CFG_SYS_CONFIG_DMAC1_CH6_MASK           (1 << AXI2CFG_SYS_CONFIG_DMAC1_CH6_IDX)
+#define AXI2CFG_SYS_CONFIG_DMAC1_CH7_MASK           (1 << AXI2CFG_SYS_CONFIG_DMAC1_CH7_IDX)
+#define AXI2CFG_SYS_CONFIG_BOOT_MODE_MASK           (((1 << AXI2CFG_SYS_CONFIG_BOOT_MODE_SZ)-1) << AXI2CFG_SYS_CONFIG_BOOT_MODE_LO)
+
+#define AXI2CFG_DMAC1_CONFIG_WR_SZ                  (7)
+#define AXI2CFG_DMAC1_CONFIG_WR_HI                  (16)
+#define AXI2CFG_DMAC1_CONFIG_WR_LO                  (10)
+#define AXI2CFG_DMAC1_CONFIG_WATERMARK_SZ           (7)
+#define AXI2CFG_DMAC1_CONFIG_WATERMARK_HI           (9)
+#define AXI2CFG_DMAC1_CONFIG_WATERMARK_LO           (3)
+#define AXI2CFG_DMAC1_CONFIG_SNGL_IDX               (2)
+#define AXI2CFG_DMAC1_CONFIG_STATE_IDX              (1)
+#define AXI2CFG_DMAC1_CONFIG_ENABLE_IDX             (0)
+
+#define AXI2CFG_JTAG_ISC_REGISTER_IDX               (0)
+#define AXI2CFG_JTAG_ISC_IN_CTRL_IDX                (1)
+#define AXI2CFG_JTAG_ISC_DISABLED_IDX               (2)
+/* [31:2] - Reserved */
+
+#define AXI2CFG_PURGE_CFG_RD_PORT_IDX               (0)
+#define AXI2CFG_PURGE_CFG_WR_PORT_IDX               (1)
+#define AXI2CFG_PURGE_CFG_WR_PRGSS_PORT_IDX         (2)
+/* [31:3]   Reserved */
+
+#define AXI2CFG_DEVICE_ID_NML_302_REG_VALUE         (0x03020004)
+
+/*****************************************************************************/
+/* Register Bit Field Manipulation                                           */
+/*****************************************************************************/
+
+#define AXI2CFG_PA_SOFT_RESET_IDX                   (30)
+#define AXI2CFG_SHD_GPIO_7_IDX                      (23)
+#define AXI2CFG_SHD_GPIO_6_IDX                      (22)
+#define AXI2CFG_SHD_GPIO_5_IDX                      (21)
+#define AXI2CFG_SHD_GPIO_4_IDX                      (20)
+#define AXI2CFG_SHD_GPIO_3_IDX                      (19)
+#define AXI2CFG_SHD_GPIO_2_IDX                      (18)
+#define AXI2CFG_SHD_GPIO_1_IDX                      (17)
+#define AXI2CFG_SHD_GPIO_0_IDX                      (16)
+#define AXI2CFG_EBI_CLK_DISABLE_IDX                 (15)
+#define AXI2CFG_EXCEPTION_VECT_EN_IDX               (14)
+#define AXI2CFG_RMII_EN_IDX                         (13)
+#define AXI2CFG_REV_MII_EN_IDX                      (12)
+#define AXI2CFG_DECODE_MUX_3_IDX                    (11)
+#define AXI2CFG_DECODE_MUX_2_IDX                    (10)
+#define AXI2CFG_DECODE_MUX_1_IDX                    (9)
+#define AXI2CFG_DECODE_MUX_0_IDX                    (8)
+#define AXI2CFG_MASK_AXI_ERROR_IDX                  (6)
+#define AXI2CFG_REMAP_IDX                           (5)
+#define AXI2CFG_WDG_PAUSE_IDX                       (4)
+#define AXI2CFG_DMA_CHAN_6_MUX_IDX                  (3)
+#define AXI2CFG_DMA_CHAN_7_MUX_IDX                  (2)
+#define AXI2CFG_BOOT_MODE_IDX                       (0)
+
+#define AXI2CFG_PA_SOFT_RESET               (1 << AXI2CFG_PA_SOFT_RESET_IDX)
+#define AXI2CFG_SHD_GPIO_7                  (1 << AXI2CFG_SHD_GPIO_7_IDX)
+#define AXI2CFG_SHD_GPIO_6                  (1 << AXI2CFG_SHD_GPIO_6_IDX)
+#define AXI2CFG_SHD_GPIO_5                  (1 << AXI2CFG_SHD_GPIO_5_IDX)
+#define AXI2CFG_SHD_GPIO_4                  (1 << AXI2CFG_SHD_GPIO_4_IDX)
+#define AXI2CFG_SHD_GPIO_3                  (1 << AXI2CFG_SHD_GPIO_3_IDX)
+#define AXI2CFG_SHD_GPIO_2                  (1 << AXI2CFG_SHD_GPIO_2_IDX)
+#define AXI2CFG_SHD_GPIO_1                  (1 << AXI2CFG_SHD_GPIO_1_IDX)
+#define AXI2CFG_SHD_GPIO_0                  (1 << AXI2CFG_SHD_GPIO_0_IDX)
+#define AXI2CFG_EBI_CLK_DISABLE             (1 << AXI2CFG_EBI_CLK_DISABLE_IDX)
+#define AXI2CFG_EXCEPTION_VECT_EN           (1 << AXI2CFG_EXCEPTION_VECT_EN_IDX)
+#define AXI2CFG_RMII_EN                     (1 << AXI2CFG_RMII_EN_IDX)
+#define AXI2CFG_REV_MII_EN                  (1 << AXI2CFG_REV_MII_EN_IDX)
+#define AXI2CFG_DECODE_MUX_3                (1 << AXI2CFG_DECODE_MUX_3_IDX)
+#define AXI2CFG_DECODE_MUX_2                (1 << AXI2CFG_DECODE_MUX_2_IDX)
+#define AXI2CFG_DECODE_MUX_1                (1 << AXI2CFG_DECODE_MUX_1_IDX)
+#define AXI2CFG_DECODE_MUX_0                (1 << AXI2CFG_DECODE_MUX_0_IDX)
+#define AXI2CFG_MASK_AXI_ERROR              (1 << AXI2CFG_MASK_AXI_ERROR_IDX)
+#define AXI2CFG_REMAP                       (1 << AXI2CFG_REMAP_IDX)
+#define AXI2CFG_WDG_PAUSE                   (1 << AXI2CFG_WDG_PAUSE_IDX)
+#define AXI2CFG_DMA_CHAN_6_MUX              (1 << AXI2CFG_DMA_CHAN_6_MUX_IDX)
+#define AXI2CFG_DMA_CHAN_7_MUX              (1 << AXI2CFG_DMA_CHAN_7_MUX_IDX)
+#define AXI2CFG_BOOT_MODE                   (1 << AXI2CFG_BOOT_MODE_IDX)
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif /* PC302_AXI2CFG_H */
diff --git a/include/asm-arm/arch-pc302/ebi.h b/include/asm-arm/arch-pc302/ebi.h
new file mode 100644
index 0000000..5f4e7b0
--- /dev/null
+++ b/include/asm-arm/arch-pc302/ebi.h
@@ -0,0 +1,193 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file ebi.h
+* \brief Definitions for the PC302 EBI Block.
+*
+* Copyright (c) 2006-2008 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef PC302_EBI_H
+#define PC302_EBI_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define SDRAM_CON_REG_OFFSET                    (0x00)
+#define SDRAM_TIM0_REG_OFFSET                   (0x04)
+#define SDRAM_TIM1_REG_OFFSET                   (0x08)
+#define SDRAM_CTL_REG_OFFSET                    (0x0C)
+#define SDRAM_REFRESH_REG_OFFSET                (0x10)
+#define SCHIP_SEL_REGION0_LOW_REG_OFFSET        (0x14)
+#define SCHIP_SEL_REGION1_LOW_REG_OFFSET        (0x18)
+#define SCHIP_SEL_REGION2_LOW_REG_OFFSET        (0x1C)
+#define SCHIP_SEL_REGION3_LOW_REG_OFFSET        (0x20)
+#define SCHIP_SEL_REGION4_LOW_REG_OFFSET        (0x24)
+#define SCHIP_SEL_REGION5_LOW_REG_OFFSET        (0x28)
+#define SCHIP_SEL_REGION6_LOW_REG_OFFSET        (0x2C)
+#define SCHIP_SEL_REGION7_LOW_REG_OFFSET        (0x30)
+#define SCHIP_SEL_REGION0_HGH_REG_OFFSET        (0x34)
+#define SCHIP_SEL_REGION1_HGH_REG_OFFSET        (0x38)
+#define SCHIP_SEL_REGION2_HGH_REG_OFFSET        (0x3C)
+#define SCHIP_SEL_REGION3_HGH_REG_OFFSET        (0x40)
+#define SCHIP_SEL_REGION4_HGH_REG_OFFSET        (0x44)
+#define SCHIP_SEL_REGION5_HGH_REG_OFFSET        (0x48)
+#define SCHIP_SEL_REGION6_HGH_REG_OFFSET        (0x4C)
+#define SCHIP_SEL_REGION7_HGH_REG_OFFSET        (0x50)
+#define SMASK0_REG_OFFSET                       (0x54)
+#define SMASK1_REG_OFFSET                       (0x58)
+#define SMASK2_REG_OFFSET                       (0x5C)
+#define SMASK3_REG_OFFSET                       (0x60)
+#define SMASK4_REG_OFFSET                       (0x64)
+#define SMASK5_REG_OFFSET                       (0x68)
+#define SMASK6_REG_OFFSET                       (0x6C)
+#define SMASK7_REG_OFFSET                       (0x70)
+#define CHIP_SEL_ALIAS0_LOW_REG_OFFSET          (0x74)
+#define CHIP_SEL_ALIAS1_LOW_REG_OFFSET          (0x78)
+#define CHIP_SEL_ALIAS0_HGH_REG_OFFSET          (0x7C)
+#define CHIP_SEL_ALIAS1_HGH_REG_OFFSET          (0x80)
+#define CHIP_SEL_REMAP0_LOW_REG_OFFSET          (0x84)
+#define CHIP_SEL_REMAP1_LOW_REG_OFFSET          (0x88)
+#define CHIP_SEL_REMAP0_HGH_REG_OFFSET          (0x8C)
+#define CHIP_SEL_REMAP1_HGH_REG_OFFSET          (0x90)
+#define STATIC_MEM_TIMSET0_REG_OFFSET           (0x94)
+#define STATIC_MEM_TIMSET1_REG_OFFSET           (0x98)
+#define STATIC_MEM_TIMSET2_REG_OFFSET           (0x9C)
+#define FLASH_TRPDR_REG_OFFSET                  (0xA0)
+#define STATICM_EMCONTROL_REG_OFFSET            (0xA4)
+#define SYNC_FLASH_OPCODE_REG_OFFSET            (0xA8)
+#define EXTEND_MODE_REG_OFFSET                  (0xAC)
+#define SYNC_FLASH_CONFIG_REG_OFFSET            (0xB0)
+#define SYNC_FLASH_CONTROL_REG_OFFSET           (0xB4)
+#define SYNC_FLASH_TIM_REG_OFFSET               (0xB8)
+
+/* Macros ------------------------------------------------------------------ */
+
+#define SETLOWFREQDEV                           (1<<27)
+#define RESETLOWFREQDEV                         (0<<27)
+#define SETREADYMODE                            (1<<26)
+#define RESETREADYMODE                          (0<<26)
+#define SETPAGEMODE                             (1<<26)
+#define RESETPAGEMODE                           (0<<26)
+#define PAGESIZE4                               (0<<24)
+#define PAGESIZE8                               (1<<24)
+#define PAGESIZE16                              (2<<24)
+#define PAGESIZE32                              (3<<24)
+#define T_PRC_0                                 (4)
+#define T_BTA_0                                 (7)
+#define T_WP_0                                  (20<<10)
+#define T_WR_0                                  (3)
+#define T_AS_0                                  (1)
+#define T_RC_0                                  (32)
+#define T_PRC_1                                 (1)
+#define T_BTA_1                                 (1)
+#define T_WP_1                                  (2)
+#define T_WR_1                                  (1)
+#define T_AS_1                                  (1)
+#define T_RC_1                                  (4)
+#define T_PRC_2                                 (1)
+#define T_BTA_2                                 (1)
+#define T_WP_2                                  (2)
+#define T_WR_2                                  (1)
+#define T_AS_2                                  (1)
+#define T_RC_2                                  (4)
+
+#define EBI_DECODE_0                            (0)
+#define EBI_DECODE_1                            (1)
+#define EBI_DECODE_2                            (2)
+#define EBI_DECODE_3                            (3)
+
+#define EBI_SMSKR_REG_SELECT_SHIFT              (8)
+#define EBI_SMSKR_REG_SELECT_MASK               (3)
+#define EBI_REG_SELECT_TIMING_SET_0             (0)
+#define EBI_REG_SELECT_TIMING_SET_1             (1)
+#define EBI_REG_SELECT_TIMING_SET_2             (2)
+
+#define EBI_SMSKR_MEM_TYPE_SHIFT                (5)
+#define EBI_SMSKR_MEM_TYPE_MASK                 (3)
+#define EBI_MEM_TYPE_SDRAM                      (0)
+#define EBI_MEM_TYPE_SRAM                       (1)
+#define EBI_MEM_TYPE_FLASH                      (2)
+
+#define EBI_SMSKR_MEM_SIZE_SHIFT                (0)
+#define EBI_SMSKR_MEM_SIZE_MASK                 (0x1F)
+#define EBI_MEM_SIZE_NO_MEMORY                  (0x00)
+#define EBI_MEM_SIZE_64KB                       (0x01)
+#define EBI_MEM_SIZE_128KB                      (0x02)
+#define EBI_MEM_SIZE_256KB                      (0x03)
+#define EBI_MEM_SIZE_512KB                      (0x04)
+#define EBI_MEM_SIZE_1MB                        (0x05)
+#define EBI_MEM_SIZE_2MB                        (0x06)
+#define EBI_MEM_SIZE_4MB                        (0x07)
+#define EBI_MEM_SIZE_8MB                        (0x08)
+#define EBI_MEM_SIZE_16MB                       (0x09)
+#define EBI_MEM_SIZE_32MB                       (0x0A)
+#define EBI_MEM_SIZE_64MB                       (0x0B)
+#define EBI_MEM_SIZE_128MB                      (0x0C)
+#define EBI_MEM_SIZE_256MB                      (0x0D)
+#define EBI_MEM_SIZE_512MB                      (0x0E)
+#define EBI_MEM_SIZE_1GB                        (0x0F)
+#define EBI_MEM_SIZE_2GB                        (0x10)
+#define EBI_MEM_SIZE_4GB                        (0x11)
+
+#define EBI_TIMING_SET_0                        (0)
+#define EBI_TIMING_SET_1                        (1)
+#define EBI_TIMING_SET_2                        (2)
+
+#define EBI_SMTMGR_REG_READ_PIPE_SHIFT          (28)
+#define EBI_SMTMGR_REG_READ_PIPE_MASK           (3)
+
+#define EBI_SMTMGR_REG_CLK_SYNC_SHIFT           (27)
+#define EBI_SMTMGR_REG_CLK_SYNC_MASK            (1)
+
+#define EBI_SMTMGR_REG_READY_MODE_SHIFT         (26)
+#define EBI_SMTMGR_REG_READY_MODE_MASK          (1)
+
+#define EBI_SMTMGR_REG_PAGE_SIZE_SHIFT          (24)
+#define EBI_SMTMGR_REG_PAGE_SIZE_MASK           (3)
+#define EBI_PAGE_SIZE_4                         (0)
+#define EBI_PAGE_SIZE_8                         (1)
+#define EBI_PAGE_SIZE_16                        (2)
+#define EBI_PAGE_SIZE_32                        (3)
+
+#define EBI_SMTMGR_REG_PAGE_MODE_SHIFT          (23)
+#define EBI_SMTMGR_REG_PAGE_MODE_MASK           (1)
+
+#define EBI_SMTMGR_REG_PAGE_READ_CYCLE_SHIFT    (19)
+#define EBI_SMTMGR_REG_PAGE_READ_CYCLE_MASK     (0xF)
+
+#define EBI_SMTMGR_REG_BUS_TURN_AROUND_SHIFT    (16)
+#define EBI_SMTMGR_REG_BUS_TURN_AROUND_MASK     (0x7)
+
+#define EBI_SMTMGR_REG_WRITE_PULSE_SHIFT        (10)
+#define EBI_SMTMGR_REG_WRITE_PULSE_MASK         (0x3F)
+
+#define EBI_SMTMGR_REG_ADDR_HOLD_SHIFT          (8)
+#define EBI_SMTMGR_REG_ADDR_HOLD_MASK           (3)
+
+#define EBI_SMTMGR_REG_ADDR_SETUP_SHIFT         (6)
+#define EBI_SMTMGR_REG_ADDR_SETUP_MASK          (3)
+
+#define EBI_SMTMGR_REG_TIMING_READ_CYCLE_MASK   (0x1F)
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif /* PC302_EBI_H */
+/
diff --git a/include/asm-arm/arch-pc302/emac.h b/include/asm-arm/arch-pc302/emac.h
new file mode 100644
index 0000000..30e0403
--- /dev/null
+++ b/include/asm-arm/arch-pc302/emac.h
@@ -0,0 +1,197 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file emac.h
+* \brief Definitions for the PC302 EMAC Block.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef PC302_EMAC_H
+#define PC302_EMAC_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/* Constant-s -------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define EMAC_NETWORK_CTRL_REG_OFFSET                                (0x0000)
+#define EMAC_NETWORK_CFG_REG_OFFSET                                 (0x0004)
+#define EMAC_NETWORK_STATUS_REG_OFFSET                              (0x0008)
+#define EMAC_USER_IO_REG_OFFSET                                     (0x000C)
+#define EMAC_DMA_CFG_REG_OFFSET                                     (0x0010)
+#define EMAC_TX_STATUS_REG_OFFSET                                   (0x0014)
+#define EMAC_RX_BUFF_Q_BASE_ADDR_REG_OFFSET                         (0x0018)
+#define EMAC_TX_BUFF_Q_BASE_ADDR_REG_OFFSET                         (0x001C)
+#define EMAC_RX_STATUS_REG_OFFSET                                   (0x0020)
+#define EMAC_INT_STATUS_REG_OFFSET                                  (0x0024)
+#define EMAC_INT_ENABLE_REG_OFFSET                                  (0x0028)
+#define EMAC_INT_DISABLE_REG_OFFSET                                 (0x002C)
+#define EMAC_INT_MASK_REG_OFFSET                                    (0x0030)
+#define EMAC_PHY_MAINTAIN_REG_OFFSET                                (0x0034)
+#define EMAC_RX_PAUSE_QUANTUM_REG_OFFSET                            (0x0038)
+#define EMAC_TX_PAUSE_QUATNUM_REG_OFFSET                            (0x003C)
+#define EMAC_HASH_BOT_32_0_REG_OFFSET                               (0x0080)
+#define EMAC_HASH_TOP_63_32_REG_OFFSET                              (0x0084)
+#define EMAC_SPEC_ADDR_1_BOT_31_0_REG_OFFSET                        (0x0088)
+#define EMAC_SPEC_ADDR_1_TOP_47_32_REG_OFFSET                       (0x008C)
+#define EMAC_SPEC_ADDR_2_BOT_31_0_REG_OFFSET                        (0x0090)
+#define EMAC_SPEC_ADDR_2_TOP_47_32_REG_OFFSET                       (0x0094)
+#define EMAC_SPEC_ADDR_3_BOT_31_0_REG_OFFSET                        (0x0098)
+#define EMAC_SPEC_ADDR_3_TOP_47_32_REG_OFFSET                       (0x009C)
+#define EMAC_SPEC_ADDR_4_BOT_31_0_REG_OFFSET                        (0x00A0)
+#define EMAC_SPEC_ADDR_4_TOP_47_32_REG_OFFSET                       (0x00A4)
+#define EMAC_TYPE_ID_MATCH_1_REG_OFFSET                             (0x00A8)
+#define EMAC_TYPE_ID_MATCH_2_REG_OFFSET                             (0x00AC)
+#define EMAC_TYPE_ID_MATCH_3_REG_OFFSET                             (0x00B0)
+#define EMAC_TYPE_ID_MATCH_4_REG_OFFSET                             (0x00B4)
+#define EMAC_WOL_REG_OFFSET                                         (0x00B8)
+#define EMAC_IPG_STRETCH_REG_OFFSET                                 (0x00BC)
+#define EMAC_STACKED_VLAN_REG_OFFSET                                (0x00C0)
+
+#define EMAC_MODULE_ID_REG_OFFSET                                   (0x00FC)
+
+#define EMAC_OCTETS_TX_31_0_REG_OFFSET                              (0x0100)
+#define EMAC_OCTETS_TX_47_32_REG_OFFSET                             (0x0104)
+#define EMAC_FRAMES_TX_NO_ERROR_REG_OFFSET                          (0x0108)
+#define EMAC_BROADCAST_FRAMES_TX_NO_ERROR_REG_OFFSET                (0x010C)
+#define EMAC_MULTICAST_FRAMES_TX_NO_ERROR_REG_OFFSET                (0x0110)
+#define EMAC_TX_PAUSE_FRAMES_REG_OFFSET                             (0x0114)
+#define EMAC_64_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET                  (0x0118)
+#define EMAC_65_127_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET              (0x011C)
+#define EMAC_128_255_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET             (0x0120)
+#define EMAC_256_511_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET             (0x0124)
+#define EMAC_512_1023_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET            (0x0128)
+#define EMAC_1024_1518_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET           (0x012C)
+#define EMAC_GREATER_THAN_1518_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET   (0x0130)
+#define EMAC_TX_UNDER_RUN_ERROR_REG_OFFSET                          (0x0134)
+#define EMAC_SINGLE_COLLISION_FRAMES_REG_OFFSET                     (0x0138)
+#define EMAC_MULTIPLE_COLLISION_FRAMES_REG_OFFSET                   (0x013C)
+#define EMAC_EXCESSIVE_COLLISIONS_REG_OFFSET                        (0x0140)
+#define EMAC_LATE_COLLISIONS_REG_OFFSET                             (0x0144)
+#define EMAC_DEFFERED_TX_FRAMES_REG_OFFSET                          (0x0148)
+#define EMAC_CARRIER_SENSE_ERRORS_REG_OFFSET                        (0x014C)
+#define EMAC_OCTETS_RX_31_0_NO_ERROR_REG_OFFSET                     (0x0150)
+#define EMAC_OCTETS_RX_47_32_NO_ERROR_REG_OFFSET                    (0x0154)
+#define EMAC_FRAMES_RX_NO_ERROR_REG_OFFSET                          (0x0158)
+#define EMAC_BROADCAST_FRAMES_RX_NO_ERROR_REG_OFFSET                (0x015C)
+#define EMAC_MULTICAST_FRAMES_RX_NO_ERROR_REG_OFFSET                (0x0160)
+#define EMAC_PAUSE_FRAME_RX_REG_OFFSET                              (0x0164)
+#define EMAC_64_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET                  (0x0168)
+#define EMAC_65_127_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET              (0x016C)
+#define EMAC_128_255_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET             (0x0170)
+#define EMAC_256_511_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET             (0x0174)
+#define EMAC_512_1023_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET            (0x0178)
+#define EMAC_1024_1518_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET           (0x017C)
+#define EMAC_1519_TO_MAX_FRAMES_RX_NO_ERROR_REG_OFFSET              (0x0180)
+#define EMAC_UNDERSIZE_FRAMES_RX_REG_OFFSET                         (0x0184)
+#define EMAC_OVERSIZE_FRAMES_RX_REG_OFFSET                          (0x0188)
+#define EMAC_JABBER_FRAMES_RX_REG_OFFSET                            (0x018C)
+#define EMAC_FCS_ERRORS_REG_OFFSET                                  (0x0190)
+#define EMAC_LENGTH_FIELD_FRAME_ERRORS_REG_OFFSET                   (0x0194)
+#define EMAC_RX_SYMBOL_ERRORS_REG_OFFSET                            (0x0198)
+#define EMAC_ALLIGNMENT_ERRORS_REG_OFFSET                           (0x019C)
+#define EMAC_RX_RESOURCE_ERRORS_REG_OFFSET                          (0x01A0)
+#define EMAC_RX_OVERRUN_ERRORS_REG_OFFSET                           (0x01A4)
+#define EMAC_IP_HDR_CHECKSUM_ERRORS_REG_OFFSET                      (0x01A8)
+#define EMAC_TCP_CHECKSUM_ERRORS_REG_OFFSET                         (0x01AC)
+#define EMAC_UDP_CHECKSUM_ERRORS_REG_OFFSET                         (0x01B0)
+
+#define EMAC_1588_TIMERS_SECONDS_REG_OFFSET                         (0x01D0)
+#define EMAC_1588_TIMER_NANO_SECONDS_REG_OFFSET                     (0x01D4)
+#define EMAC_1588_TIMER_ADJUST_REG_OFFSET                           (0x01D8)
+#define EMAC_1588_TIMER_INCREMENT_REG_OFFSET                        (0x01DC)
+
+#define EMAC_PTP_EVENT_FRAME_TX_SECONDS_REG_OFFSET                  (0x01E0)
+#define EMAC_PTP_EVENT_FRAME_TX_NANO_SECONDS_REG_OFFSET             (0x01E4)
+#define EMAC_PTP_EVENT_FRAME_RX_SECONDS_REG_OFFSET                  (0x01E8)
+#define EMAC_PTP_EVENT_FRAME_RX_NANO_SECONDS_REG_OFFSET             (0x01EC)
+#define EMAC_PTP_PEER_EVENT_FRAME_TX_SECONDS_REG_OFFSET             (0x01F0)
+#define EMAC_PTP_PEER_EVENT_FRAME_TX_NANO_SECONDS_REG_OFFSET        (0x01F4)
+#define EMAC_PTP_PEER_EVENT_FRAME_RX_SECONDS_REG_OFFSET             (0x01F8)
+#define EMAC_PTP_PEER_EVENT_FRAME_RX_NANO_SECONDS_REG_OFFSET        (0x01FC)
+
+#define EMAC_PCS_CTRL_REG_OFFSET                                    (0x0200)
+#define EMAC_PCS_STATUS_REG_OFFSET                                  (0x0204)
+#define EMAC_PCS_UPPER_PHY_ID_REG_OFFSET                            (0x0208)
+#define EMAC_PCS_LOWER_PHY_ID_REG_OFFSET                            (0x020C)
+#define EMAC_PCS_AUTO_NEG_ADVERT_REG_OFFSET                         (0x0210)
+#define EMAC_PCS_AUTO_NEG_LINK_PARTNER_AB_REG_OFFSET                (0x0214)
+#define EMAC_PCS_AUTO_NEG_EXPANSION_REG_OFFSET                      (0x0218)
+#define EMAC_PCS_AUTO_NEG_NEXT_PAGE_REG_OFFSET                      (0x021C)
+#define EMAC_PCS_AUTO_NEG_LINK_PARTNER_NEXT_PAGE_REG_OFFSET         (0x0220)
+#define EMAC_PCS_EXTENDED_STATUS_REG_OFFSET                         (0x023C)
+
+/* EMAC_NETWORK_CTRL_REG_OFFSET bits */
+#define EMAC_TRANSMIT_HALT                                          (((unsigned int)1) << 10)
+#define EMAC_START_TX                                               (((unsigned int)1) << 9)
+#define EMAC_CLEAR_STATS_REGISTERS                                  (((unsigned int)1) << 5)
+#define EMAC_MDIO_ENABLE                                            (((unsigned int)1) << 4)
+#define EMAC_TX_ENABLE                                              (((unsigned int)1) << 3)
+#define EMAC_RX_ENABLE                                              (((unsigned int)1) << 2)
+
+/* EMAC_NETWORK_CFG_REG_OFFSET bits */
+#define EMAC_64_BIT_AMBA_DATA_BUS_WITDH                             (((unsigned int)1) << 21)
+#define EMAC_MDC_CLOCK_DIV_MASK                                     (0x7 << 18)
+#define EMAC_MDC_CLOCK_DIV_96                                       (0x5 << 18)
+#define EMAC_FCS_REMOVE                                             (((unsigned int)1) << 17)
+#define EMAC_LENGTH_FIELD_ERROR_FRAME_DISCARD                       (((unsigned int)1) << 16)
+#define EMAC_FULL_DUPLEX                                            (((unsigned int)1) << 1)
+#define EMAC_SPEED_100_MBPS                                         (((unsigned int)1) << 0)
+
+/* EMAC_NETWORK_STATUS_REG_OFFSET bits */
+#define EMAC_PHY_MANAGEMENT_IDLE                                    (((unsigned int)1) << 2)
+
+/* EMAC_DMA_CFG_REG_OFFSET bits */
+#define EMAC_DMA_RX_BUFFER_SIZE_IDX                                 (16)
+#define EMAC_DMA_RX_BUFFER_SIZE_MASK                                (0xFF << EMAC_DMA_RX_BUFFER_SIZE_IDX)
+#define EMAC_DMA_RX_BUFFER_SIZE                                     (0x18 << EMAC_DMA_RX_BUFFER_SIZE_IDX)
+
+/* EMAC_PHY_MAINTAIN_REG_OFFSET bits */
+#define EMAC_PHY_ID_MASK                                            (0x1F)
+#define EMAC_PHY_ID_SHIFT                                           (23)
+#define EMAC_PHY_REG_MASK                                           (0x1F)
+#define EMAC_PHY_REG_SHIFT                                          (18)
+#define EMAC_PHY_DATA_MASK                                          (0xFFFF)
+
+/* EMAC_TX_STATUS_REG_OFFSET bits */
+#define EMAC_TRANSMIT_COMPLETE                                      (((unsigned int)1) << 5)
+#define EMAC_TRANSMIT_GO                                            (((unsigned int)1) << 3)
+
+/* Rx Descriptor Bits */
+#define EMAC_RX_DESC_WRAP                                           (((unsigned int)1) << 1)
+#define EMAC_RX_DESC_HOST_OWN                                       (((unsigned int)1) << 0)
+
+#define EMAC_RX_DESC_END_OF_FRAME                                   (((unsigned int)1) << 15)
+#define EMAC_RX_DESC_START_OF_FRAME                                 (((unsigned int)1) << 14)
+#define EMAC_RX_DESC_LENGTH_MASK                                    (0x1FFF)
+
+/* Tx Descriptor Bits */
+#define EMAC_TX_DESC_HOST_OWN                                       (((unsigned int)1) << 31)
+#define EMAC_TX_DESC_WRAP                                           (((unsigned int)1) << 30)
+#define EMAC_TX_RETRY_ERROR                                         (((unsigned int)1) << 29)
+#define EMAC_TX_UNDERRUN_ERROR                                      (((unsigned int)1) << 28)
+#define EMAC_TX_FRAME_CORRUPTION_ERROR                              (((unsigned int)1) << 27)
+#define EMAC_TX_LATE_COLLISION_ERROR                                (((unsigned int)1) << 26)
+#define EMAC_TX_NO_CRC_APPEND                                       (((unsigned int)1) << 16)
+#define EMAC_TX_LAST_BUFFER                                         (((unsigned int)1) << 15)
+#define EMAC_TX_BUFFER_LENGTH_MASK                                  (0x3FFF)
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif /* PC302_EMAC_H */
diff --git a/include/asm-arm/arch-pc302/fuse.h b/include/asm-arm/arch-pc302/fuse.h
new file mode 100644
index 0000000..f21fe7c
--- /dev/null
+++ b/include/asm-arm/arch-pc302/fuse.h
@@ -0,0 +1,84 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file fuse.h
+* \brief Definitions for the PC302 Fuse Block.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+#ifndef PC302_FUSE_H
+#define PC302_FUSE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/* Constants -------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define FUSE_MAP_0_REG_OFFSET           (0x00)
+#define FUSE_MAP_1_REG_OFFSET           (0x04)
+#define FUSE_MAP_2_REG_OFFSET           (0x08)
+#define FUSE_MAP_3_REG_OFFSET           (0x0C)
+
+#define FUSE_MAP_4_REG_OFFSET           (0x10)
+#define FUSE_MAP_5_REG_OFFSET           (0x14)
+#define FUSE_MAP_6_REG_OFFSET           (0x18)
+#define FUSE_MAP_7_REG_OFFSET           (0x1C)
+
+#define FUSE_MAP_8_REG_OFFSET           (0x20)
+#define FUSE_MAP_9_REG_OFFSET           (0x24)
+#define FUSE_MAP_10_REG_OFFSET          (0x28)
+#define FUSE_MAP_11_REG_OFFSET          (0x2C)
+
+#define FUSE_MAP_12_REG_OFFSET          (0x30)
+#define FUSE_MAP_13_REG_OFFSET          (0x34)
+#define FUSE_MAP_14_REG_OFFSET          (0x38)
+#define FUSE_MAP_15_REG_OFFSET          (0x3C)
+
+#define FUSE_MAP_16_REG_OFFSET          (0x40)
+#define FUSE_MAP_17_REG_OFFSET          (0x44)
+#define FUSE_MAP_18_REG_OFFSET          (0x48)
+#define FUSE_MAP_19_REG_OFFSET          (0x4C)
+
+#define FUSE_MAP_20_REG_OFFSET          (0x50)
+#define FUSE_MAP_21_REG_OFFSET          (0x54)
+#define FUSE_MAP_22_REG_OFFSET          (0x58)
+#define FUSE_MAP_23_REG_OFFSET          (0x5C)
+
+#define FUSE_MAP_24_REG_OFFSET          (0x60)
+#define FUSE_MAP_25_REG_OFFSET          (0x64)
+#define FUSE_MAP_26_REG_OFFSET          (0x68)
+#define FUSE_MAP_27_REG_OFFSET          (0x6C)
+
+#define FUSE_MAP_28_REG_OFFSET          (0x70)
+#define FUSE_MAP_29_REG_OFFSET          (0x74)
+#define FUSE_MAP_30_REG_OFFSET          (0x78)
+#define FUSE_MAP_31_REG_OFFSET          (0x7C)
+
+#define FUSE_CONTROL_REG_OFFSET         (0x80)
+#define FUSE_WRITE_BIT_ADDR_REG_OFFSET  (0x84)
+#define FUSE_WRITE_PERFORM              (0x88)
+
+/*****************************************************************************/
+/* Register Bit Field Manipulation                                           */
+/*****************************************************************************/
+
+#define FUSE_WRITE_FUSE_ENABLE          (0x66757365)
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif /* PC302_FUSE_H */
diff --git a/include/asm-arm/arch-pc302/gpio.h b/include/asm-arm/arch-pc302/gpio.h
new file mode 100644
index 0000000..e2cea07
--- /dev/null
+++ b/include/asm-arm/arch-pc302/gpio.h
@@ -0,0 +1,82 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file gpio.h
+* \brief Definitions for the PC302 GPIO Block.
+*
+* Copyright (c) 2006-2008 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef PC302_GPIO_H
+#define PC302_GPIO_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define GPIO_SW_PORT_A_DR_REG_OFFSET        (0x00)
+#define GPIO_SW_PORT_A_DDR_REG_OFFSET	    (0x04)
+#define GPIO_SW_PORT_A_CTL_REG_OFFSET       (0x08)
+#define GPIO_SW_PORT_B_DR_REG_OFFSET        (0x0C)
+#define GPIO_SW_PORT_B_DDR_REG_OFFSET	    (0x10)
+#define GPIO_SW_PORT_B_CTL_REG_OFFSET       (0x14)
+#define GPIO_SW_PORT_C_DR_REG_OFFSET        (0x18)
+#define GPIO_SW_PORT_C_DDR_REG_OFFSET	    (0x1C)
+#define GPIO_SW_PORT_C_CTL_REG_OFFSET       (0x20)
+
+/* no port {D} */
+
+/* global GPIO registers */
+#define GPIO_INT_EN_REG_OFFSET              (0x30)
+#define GPIO_INT_MASK_REG_OFFSET            (0x34)
+#define GPIO_INT_TYPE_LEVEL_REG_OFFSET 	    (0x38)
+#define GPIO_INT_POLARITY_REG_OFFSET 	    (0x3c)
+
+#define GPIO_INT_STATUS_REG_OFFSET	    (0x40)
+#define GPIO_RAW_INT_STATUS_REG_OFFSET	    (0x44)
+
+/* no debounce */
+#define GPIO_PORT_A_EOI_REG_OFFSET          (0x4c)
+#define GPIO_EXT_PORT_A_REG_OFFSET          (0x50)
+#define GPIO_EXT_PORT_B_REG_OFFSET          (0x54)
+#define GPIO_EXT_PORT_C_REG_OFFSET          (0x58)
+
+/* no port {D} */
+
+#define GPIO_LS_SYNC_REG_OFFSET		    (0x60)
+#define GPIO_ID_CODE_REG_OFFSET		    (0x64)
+#define GPIO_RESERVED_REG_OFFSET            (0x68)
+#define GPIO_COMP_VERSION_REG_OFFSET	    (0x6c)
+
+
+/* Macros ------------------------------------------------------------------ */
+
+/* Useful bit definitions */
+#define GPIO_BIT_7  (0x80)
+#define GPIO_BIT_6  (0x40)
+#define GPIO_BIT_5  (0x20)
+#define GPIO_BIT_4  (0x10)
+#define GPIO_BIT_3  (0x08)
+#define GPIO_BIT_2  (0x04)
+#define GPIO_BIT_1  (0x02)
+#define GPIO_BIT_0  (0x01)
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif /* PC302_GPIO_H */
diff --git a/include/asm-arm/arch-pc302/mem_arm.h b/include/asm-arm/arch-pc302/mem_arm.h
new file mode 100644
index 0000000..0506e00
--- /dev/null
+++ b/include/asm-arm/arch-pc302/mem_arm.h
@@ -0,0 +1,137 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file mem_arm.h
+* \brief Definitions for the PC302 Memif-ARM Block.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef PC302_MEM_ARM_H
+#define PC302_MEM_ARM_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define MEMIF_ARM_INDIRECT_RW_CMD_OFFSET    (0x00 * 4)
+#define MEMIF_ARM_RSVD_0_OFFSET             (0x01 * 4)
+#define MEMIF_ARM_HPR_OFFSET                (0x02 * 4)
+#define MEMIF_ARM_LPR_OFFSET                (0x03 * 4)
+#define MEMIF_ARM_WR_OFFSET                 (0x04 * 4)
+#define MEMIF_ARM_DRAM_PARAM_0_OFFSET       (0x05 * 4)
+#define MEMIF_ARM_DRAM_PARAM_1_OFFSET       (0x06 * 4)
+#define MEMIF_ARM_DRAM_PARAM_2_OFFSET       (0x07 * 4)
+#define MEMIF_ARM_DRAM_PARAM_3_OFFSET       (0x08 * 4)
+#define MEMIF_ARM_DRAM_PARAM_4_OFFSET       (0x09 * 4)
+#define MEMIF_ARM_DRAM_INIT_PARAM_OFFSET    (0x0A * 4)
+#define MEMIF_ARM_DRAM_EMR2_EMR3_OFFSET     (0x0B * 4)
+#define MEMIF_ARM_DRAM_EMR_MR_OFFSET        (0x0C * 4)
+#define MEMIF_ARM_DRAM_BL_OFFSET            (0x0D * 4)
+#define MEMIF_ARM_DRAM_FORCE_LPR_OFFSET     (0x0E * 4)
+#define MEMIF_ARM_ADDR_MAP_0_OFFSET         (0x0F * 4)
+#define MEMIF_ARM_ADDR_MAP_1_OFFSET         (0x10 * 4)
+#define MEMIF_ARM_ADDR_MAP_2_OFFSET         (0x11 * 4)
+#define MEMIF_ARM_DRAM_ODT_OFFSET           (0x12 * 4)
+#define MEMIF_ARM_PHY_DEBUG_0_OFFSET        (0x13 * 4)
+#define MEMIF_ARM_PHY_CMD_RDC_OFFSET        (0x14 * 4)
+#define MEMIF_ARM_CTRL_MODE_OFFSET          (0x15 * 4)
+#define MEMIF_ARM_DLL_CALIB_OFFSET          (0x16 * 4)
+#define MEMIF_ARM_ODT_CTRL_OFFSET           (0x17 * 4)
+#define MEMIF_ARM_DDRC_CTRL_0_OFFSET        (0x18 * 4)
+#define MEMIF_ARM_DDRC_CTRL_1_OFFSET        (0x19 * 4)
+#define MEMIF_ARM_PHY_SLV_DLL_OFFSET        (0x1A * 4)
+#define MEMIF_ARM_PHY_DEBUG_1_OFFSET        (0x1B * 4)
+#define MEMIF_ARM_PHY_DEBUG_2_OFFSET        (0x1C * 4)
+#define MEMIF_ARM_PHY_DEBUG_3_OFFSET        (0x1D * 4)
+#define MEMIF_ARM_PHY_DEBUG_4_OFFSET        (0x1E * 4)
+#define MEMIF_ARM_PHY_LOCAL_ODT_OFFSET      (0x1F * 4)
+#define MEMIF_ARM_GP0_OFFSET                (0x20 * 4)
+#define MEMIF_ARM_GP1_OFFSET                (0x21 * 4)
+#define MEMIF_ARM_GP2_OFFSET                (0x22 * 4)
+#define MEMIF_ARM_PHY_LOCAL_DRV_STRENGTH_OFFSET \
+        (MEMIF_ARM_GP2_OFFSET)
+#define MEMIF_ARM_GP3_OFFSET                (0x23 * 4)
+#define MEMIF_ARM_GP4_OFFSET                (0x24 * 4)
+
+#define MEMIF_ARM_AXI_HP_MSTR_0_OFFSET      (0x3A * 4)
+#define MEMIF_ARM_AXI_HP_MSTR_1_OFFSET      (0x3B * 4)
+#define MEMIF_ARM_AXI_HP_MSTR_2_OFFSET      (0x3C * 4)
+#define MEMIF_ARM_AXI_HP_MSTR_3_OFFSET      (0x3D * 4)
+#define MEMIF_ARM_AXI_START_ADDR_OFFSET     (0x3E * 4)
+#define MEMIF_ARM_AXI_END_ADDR_OFFSET       (0x3F * 4)
+
+/*****************************************************************************/
+/* Register Values                                                           */
+/*****************************************************************************/
+
+/* Set up values for a single 512Mbx16 sdram device */
+#define MEMIF_ARM_ADDR_MAP_0_VAL_512Mbx16   (0x00000F77)  /* bank */
+#define MEMIF_ARM_ADDR_MAP_1_VAL_512Mbx16   (0xFFF00000)  /* col */
+#define MEMIF_ARM_ADDR_MAP_2_VAL_512Mbx16   (0x0FF22222)  /* row */
+
+/* Set up values for a single 1Gbx16 sdram device */
+#define MEMIF_ARM_ADDR_MAP_0_VAL_1Gbx16     (0x00000777)  /* bank */
+#define MEMIF_ARM_ADDR_MAP_1_VAL_1Gbx16     (0xFFF00000)  /* col */
+#define MEMIF_ARM_ADDR_MAP_2_VAL_1Gbx16     (0x0FF33333)  /* row */
+
+#define MEMIF_ARM_DRAM_EMR_MR_VAL           (0x00000A63)
+
+/* final wait after ddr initialisation sequence is 8 cycles */
+#define MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_IDX     (0)
+#define MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_MSK     (0x3F)
+#define MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_VAL     (0x8)
+
+/* pre cke assertion delay must be 200us */
+#define MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_IDX   (14)
+#define MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_MSK   (0xFF)
+#define MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_VAL   (0x50)
+
+/* post cke assertion is 400ns */
+#define MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_IDX   (22)
+#define MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_MSK   (0xFF)
+#define MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_VAL   (0x2)
+
+/*****************************************************************************/
+/* Base Addresses                                                            */
+/*****************************************************************************/
+
+/* col  [9:0]  = axaddr[10:1] */
+/* bank [1:0]  = axaddr[12:11] */
+/* row  [12:0] = axaddr[25:13] */
+#define BANK0_BASE_512Mbx16                 (0x00000000)
+#define BANK1_BASE_512Mbx16                 (0x00000800)
+#define BANK2_BASE_512Mbx16                 (0x00001000)
+#define BANK3_BASE_512Mbx16                 (0x00001800)
+
+/* col  [9:0]  = axaddr[10:1] */
+/* bank [2:0]  = axaddr[13:11] */
+/* row  [13:0] = axaddr[27:14] */
+#define BANK0_BASE_1Gbx8                    (0x00000000)
+#define BANK1_BASE_1Gbx8                    (0x00000800)
+#define BANK2_BASE_1Gbx8                    (0x00001000)
+#define BANK3_BASE_1Gbx8                    (0x00001800)
+#define BANK4_BASE_1Gbx8                    (0x00002000)
+#define BANK5_BASE_1Gbx8                    (0x00002800)
+#define BANK6_BASE_1Gbx8                    (0x00003000)
+#define BANK7_BASE_1Gbx8                    (0x00003800)
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif /* PC302_MEM_ARM_H */
diff --git a/include/asm-arm/arch-pc302/mem_shd.h b/include/asm-arm/arch-pc302/mem_shd.h
new file mode 100644
index 0000000..c7d1b0e
--- /dev/null
+++ b/include/asm-arm/arch-pc302/mem_shd.h
@@ -0,0 +1,403 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file mem_arm.h
+* \brief Definitions for the PC302 Memif-ARM Block.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef PC302_MEM_SHD_H
+#define PC302_MEM_SHD_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/* Includes ---------------------------------------------------------------- */
+#include "pa.h"
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define ADDR_PA_BUF0_SETUP                  (0x0000)
+#define ADDR_PA_BUF0_ADDR                   (0x0001)
+#define ADDR_PA_BUF1_SETUP                  (0x0002)
+#define ADDR_PA_BUF1_ADDR                   (0x0003)
+#define ADDR_PA_BUF2_SETUP                  (0x0004)
+#define ADDR_PA_BUF2_ADDR                   (0x0005)
+#define ADDR_PA_BUF3_SETUP                  (0x0006)
+#define ADDR_PA_BUF3_ADDR                   (0x0007)
+#define ADDR_PA_BUF4_SETUP                  (0x0008)
+#define ADDR_PA_BUF4_ADDR                   (0x0009)
+#define ADDR_PA_BUF5_SETUP                  (0x000A)
+#define ADDR_PA_BUF5_ADDR                   (0x000B)
+#define ADDR_PA_BUF6_SETUP                  (0x000C)
+#define ADDR_PA_BUF6_ADDR                   (0x000D)
+#define ADDR_PA_BUF7_SETUP                  (0x000E)
+#define ADDR_PA_BUF7_ADDR                   (0x000F)
+#define ADDR_PA_BUF8_SETUP                  (0x0010)
+#define ADDR_PA_BUF8_ADDR                   (0x0011)
+#define ADDR_PA_BUF9_SETUP                  (0x0012)
+#define ADDR_PA_BUF9_ADDR                   (0x0013)
+#define ADDR_SDRAM_ARB_G0_S0_S1             (0x0020)
+#define ADDR_SDRAM_ARB_G0_S2_S3             (0x0021)
+#define ADDR_SDRAM_ARB_G1_S0_S1             (0x0022)
+#define ADDR_SDRAM_ARB_G1_S2_S3             (0x0023)
+#define ADDR_SDRAM_ARB_G2_S0_S1             (0x0024)
+#define ADDR_SDRAM_ARB_G2_S2_S3             (0x0025)
+#define ADDR_SDRAM_ARB_G3_S0_S1             (0x0026)
+#define ADDR_SDRAM_ARB_G3_S2_S3             (0x0027)
+#define ADDR_SDRAM_ARB_G4_S0_S1             (0x0028)
+#define ADDR_SDRAM_ARB_G4_S2_S3             (0x0029)
+#define ADDR_SDRAM_ARB_G5_S0_S1             (0x002A)
+#define ADDR_SDRAM_ARB_G5_S2_S3             (0x002B)
+#define ADDR_SDRAM_ARB_G6_S0_S1             (0x002C)
+#define ADDR_SDRAM_ARB_G6_S2_S3             (0x002D)
+#define ADDR_SDRAM_ARB_G7_S0_S1             (0x002E)
+#define ADDR_SDRAM_ARB_G7_S2_S3             (0x002F)
+#define ADDR_SDRAM_VALID_GROUPS             (0x0030)
+#define ADDR_SRAM_ARB_S0_S1                 (0x0040)
+#define ADDR_SRAM_ARB_S2_S3                 (0x0041)
+#define ADDR_SRAM_ARB_S4_S5                 (0x0042)
+#define ADDR_SRAM_VALID_SLOTS               (0x0043)
+#define ADDR_ARB_UPDATE                     (0x004F)
+#define ADDR_SDRAM_SETUP                    (0x0050)
+#define ADDR_SDRAM_REFRESH                  (0x0051)
+#define ADDR_SDRAM_MRS                      (0x0052)
+#define ADDR_SDRAM_EMRS                     (0x0053)
+#define ADDR_SDRAM_EMRS2                    (0x0054)
+#define ADDR_SDRAM_EMRS3                    (0x0055)
+#define ADDR_SDRAM_ODT_SETUP                (0x0056)
+#define ADDR_SDRAM_CFG_DONE                 (0x0057)
+#define ADDR_SDRAM_AXI_CONFIG               (0x0058)
+#define ADDR_SDRAM_DEBUG                    (0x0059)
+#define ADDR_SDRAM_STATUS                   (0x005A)
+#define ADDR_PHY_TEST                       (0x0060)
+#define ADDR_PHY_CONFIG                     (0x0061)
+#define ADDR_PHY_LOCAL_ODT_CONFIG           (0x0062)
+#define ADDR_PHY_RDC_FIFO_RST_ERR_CNT       (0x0063)
+#define ADDR_PHY_WR_SLAVE                   (0x0064)
+#define ADDR_PHY_RD_SLAVE                   (0x0065)
+#define ADDR_PHY_DEBUG_WR_DLL0              (0x0066)
+#define ADDR_PHY_DEBUG_RC_DLL0              (0x0068)
+#define ADDR_PHY_DEBUG_RC_DLL1              (0x0069)
+#define ADDR_PHY_IO_CELL_CONFIG             (0x006A)
+#define ADDR_PHY_DEBUG_STATUS_BC            (0x0070)
+#define ADDR_PHY_DEBUG_STATUS_RC_DLL_0      (0x0071)
+#define ADDR_PHY_DEBUG_STATUS_RC_DLL_1      (0x0072)
+#define ADDR_PHY_DEBUG_STATUS_MASTER_DLL_0  (0x0073)
+#define ADDR_PHY_DEBUG_STATUS_OF_IN_DELAY_0 (0x0075)
+#define ADDR_PHY_DEBUG_STATUS_OF_OUT_DELAY_0    (0x0076)
+#define ADDR_PA_FIFO_STATUS_LWR             (0x0080)
+#define ADDR_PA_FIFO_STATUS_UPR             (0x0081)
+#define ADDR_PA_ADDR_ERR_LWR                (0x0082)
+#define ADDR_PA_ADDR_ERR_UPR                (0x0083)
+#define ADDR_PA_ADDR_ERR_MASK_LWR           (0x0084)
+#define ADDR_PA_ADDR_ERR_MASK_UPR           (0x0085)
+
+#define CBFM_SLEEPREG_ADDR                  (0xA060)
+#define CBFM_RUNREG_ADDR                    (0xA061)
+#define CBFM_ERRREG_ADDR                    (0xA062)
+#define CBFM_RESETREG_ADDR                  (0xA063)
+#define CBFM_IDREG_ADDR                     (0xA064)
+#define CBFM_RSTRUNMASK_ADDR                (0xA065)
+#define CBFM_BISTEN_ADDR                    (0xA066)
+#define CBFM_BISTDATA_ADDR                  (0xA067)
+#define CBFM_TM_ADDR                        (0xA068)
+
+/*****************************************************************************/
+/* Register Values                                                           */
+/*****************************************************************************/
+
+#define DDR2_ROW_13_COL_9               (0x2)
+#define DDR2_ROW_13_COL_10              (0x1)
+#define DDR2_ROW_14_COL_10              (0x0)
+#define DDR2_8_BANKS                    (0x1)
+#define DDR2_4_BANKS                    (0x0)
+#define DDR2_BRC_ADDR                   (0x0)
+#define DDR2_RBC_ADDR                   (0x1)
+#define DDR2_RW_GAP                     (0x3)
+#define DDR2_WR_GAP                     (0xa)
+#define DDR2_CAS_4                      (0x4)
+#define DDR2_CAS_5                      (0x5)
+#define DDR2_CAS_6                      (0x6)
+#define DDR2_CAS_7                      (0x7)
+#define DDR2_REFRESH_TIME               (0x07d0)
+#define DDR2_BURST_SEQUENTIAL           (0x0000)
+#define DDR2_WR                         (0x05)
+#define DDR2_DQSN_DISABLE               (0x1)
+
+#define SDRAM_ARB_AXI_SLOT              (0)
+#define SDRAM_ARB_PA_SLOT               (1)
+#define SDRAM_ARB_DET_SLOT              (0)
+#define SDRAM_ARB_OPP_SLOT              (1)
+#define SDRAM_ARB_RD_SLOT               (0)
+#define SDRAM_ARB_WR_SLOT               (1)
+#define SDRAM_ARB_CSP_1_SLOT            (0)
+#define SDRAM_ARB_CSP_2_SLOT            (1)
+#define SDRAM_ARB_CSP_4_SLOT            (2)
+#define SDRAM_ARB_CSP_8_SLOT            (3)
+
+#define SDRAM_ARB_1_VALID_SLOT          (1)
+#define SDRAM_ARB_2_VALID_SLOT          (3)
+#define SDRAM_ARB_3_VALID_SLOT          (7)
+#define SDRAM_ARB_4_VALID_SLOT          (15)
+#define SDRAM_ARB_5_VALID_SLOT          (31)
+#define SDRAM_ARB_6_VALID_SLOT          (63)
+#define SDRAM_ARB_7_VALID_SLOT          (127)
+#define SDRAM_ARB_8_VALID_SLOT          (255)
+
+#define PHY_CONFIG_BL_4                 (2)
+#define PHY_CONFIG_BL_8                 (3)
+#define PHY_CONFIG_RDC_WE_TO_RE_2       (2)
+#define PHY_CONFIG_FIXED_RE             (1)
+
+#define ADDR_SDRAM_STATUS_INIT_DONE_BIT     (0)
+#define ADDR_SDRAM_STATUS_IN_RESET_BIT      (1)
+#define ADDR_SDRAM_STATUS_IN_STB_CLK_BIT    (2)
+#define ADDR_SDRAM_STATUS_IN_INIT_BIT       (3)
+#define ADDR_SDRAM_STATUS_IN_ARB_BIT        (4)
+#define ADDR_SDRAM_STATUS_IN_REF_BIT        (5)
+#define ADDR_SDRAM_STATUS_IN_UPDATE_BIT     (6)
+#define ADDR_SDRAM_STATUS_IN_RW_GAP_BIT     (7)
+#define ADDR_SDRAM_STATUS_IN_WR_GAP_BIT     (8)
+
+#define SDRAM_SETUP_SIZE_IDX            (0)
+#define SDRAM_SETUP_BANK_IDX            (2)
+#define SDRAM_SETUP_RW_GAP_IDX          (3)
+#define SDRAM_SETUP_WR_GAP_IDX          (7)
+#define SDRAM_SETUP_CAS_IDX             (11)
+
+#define SDRAM_AXI_SETUP_RBC_IDX         (0)
+#define SDRAM_AXI_SETUP_SIZE_IDX        (1)
+#define SDRAM_AXI_SETUP_BANK_IDX        (3)
+
+#define SDRAM_ARB_S0_AP_IDX             (0)
+#define SDRAM_ARB_S0_APOD_IDX           (1)
+#define SDRAM_ARB_S0_RW_IDX             (2)
+#define SDRAM_ARB_S0_RWOD_IDX           (3)
+#define SDRAM_ARB_S0_CSP_IDX            (4)
+
+#define SDRAM_ARB_S1_AP_IDX             (8)
+#define SDRAM_ARB_S1_APOD_IDX           (9)
+#define SDRAM_ARB_S1_RW_IDX             (10)
+#define SDRAM_ARB_S1_RWOD_IDX           (11)
+#define SDRAM_ARB_S1_CSP_IDX            (12)
+
+#define SDRAM_ARB_S2_AP_IDX             (0)
+#define SDRAM_ARB_S2_APOD_IDX           (1)
+#define SDRAM_ARB_S2_RW_IDX             (2)
+#define SDRAM_ARB_S2_RWOD_IDX           (3)
+#define SDRAM_ARB_S2_CSP_IDX            (4)
+
+#define SDRAM_ARB_S3_AP_IDX             (8)
+#define SDRAM_ARB_S3_APOD_IDX           (9)
+#define SDRAM_ARB_S3_RW_IDX             (10)
+#define SDRAM_ARB_S3_RWOD_IDX           (11)
+#define SDRAM_ARB_S3_CSP_IDX            (12)
+
+#define PHY_CONFIG_FIRST_RD_IDX         (0)
+#define PHY_CONFIG_FIRST_WR_IDX         (4)
+#define PHY_CONFIG_BL_IDX               (8)
+#define PHY_CONFIG_RDC_WE_TO_RE_IDX     (11)
+#define PHY_CONFIG_FIXED_RE_IDX         (13)
+
+#define MRS_PHY_CONFIG_BL_IDX           (0)
+#define MRS_DDR2_BURST_SEQUENTIAL_IDX   (3)
+#define MRS_DDR2_CAS_IDX                (4)
+#define MRS_DDR2_WR_IDX                 (9)
+
+#define EMRS_ODT_LOW_BIT_IDX            (2)
+#define EMRS_ODT_HIGH_BIT_IDX           (6)
+#define EMRS_DQSN_DISABLE_IDX           (10)
+
+/*****************************************************************************/
+/* Used to create a 'load file' for the pA                                   */
+/*****************************************************************************/
+
+#define LF_PA_AEID_MEMIF                (PA_AEID_MEMIF | PA_CONFIG_AEID)
+
+#define LF_CBFM_SLEEPREG_ADDR           (CBFM_SLEEPREG_ADDR | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_ARB_G0_S0_S1      (ADDR_SDRAM_ARB_G0_S0_S1 | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_ARB_G0_S2_S3      (ADDR_SDRAM_ARB_G0_S2_S3 | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_ARB_G1_S0_S1      (ADDR_SDRAM_ARB_G1_S0_S1 | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_ARB_G1_S2_S3      (ADDR_SDRAM_ARB_G1_S2_S3 | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_VALID_GROUPS      (ADDR_SDRAM_VALID_GROUPS | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_SETUP             (ADDR_SDRAM_SETUP | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_REFRESH           (ADDR_SDRAM_REFRESH | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_ODT_SETUP         (ADDR_SDRAM_ODT_SETUP | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_AXI_CONFIG        (ADDR_SDRAM_AXI_CONFIG | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_MRS               (ADDR_SDRAM_MRS | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_EMRS              (ADDR_SDRAM_EMRS | PA_CONFIG_ADDR)
+#define LF_ADDR_PHY_CONFIG              (ADDR_PHY_CONFIG | PA_CONFIG_ADDR)
+#define LF_ADDR_PHY_LOCAL_ODT_CONFIG    (ADDR_PHY_LOCAL_ODT_CONFIG | PA_CONFIG_ADDR)
+#define LF_ADDR_PHY_RD_SLAVE            (ADDR_PHY_RD_SLAVE | PA_CONFIG_ADDR)
+#define LF_ADDR_PHY_WR_SLAVE            (ADDR_PHY_WR_SLAVE | PA_CONFIG_ADDR)
+#define LF_ADDR_PHY_IO_CELL_CONFIG      (ADDR_PHY_IO_CELL_CONFIG | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_CFG_DONE          (ADDR_SDRAM_CFG_DONE | PA_CONFIG_ADDR)
+
+#define ADDR_SDRAM_ARB_G0_S0_S1_DATA    (0x00000000 | PA_CONFIG_WRITE | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S0_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S0_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S0_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S0_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S0_CSP_IDX)  | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S1_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S1_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S1_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S1_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S1_CSP_IDX))
+
+#define ADDR_SDRAM_ARB_G0_S2_S3_DATA    (0x00000000 | PA_CONFIG_WRITE | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S2_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S2_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S2_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S2_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S2_CSP_IDX)  | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S3_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S3_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S3_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S3_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S3_CSP_IDX))
+
+#define ADDR_SDRAM_ARB_G1_S0_S1_DATA    (0x00000000 | PA_CONFIG_WRITE | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S0_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S0_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S0_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S0_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S0_CSP_IDX)  | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S1_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S1_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S1_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S1_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S1_CSP_IDX))
+
+#define ADDR_SDRAM_ARB_G1_S2_S3_DATA    (0x00000000 | PA_CONFIG_WRITE | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S2_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S2_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S2_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S2_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S2_CSP_IDX)  | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S3_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S3_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S3_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S3_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S3_CSP_IDX))
+
+#define ADDR_SDRAM_VALID_GROUPS_DATA    (0x00000000 | PA_CONFIG_WRITE | SDRAM_ARB_2_VALID_SLOT)
+
+#define ADDR_SDRAM_SETUP_DATA           (0x00000000 | PA_CONFIG_WRITE | \
+                                        (DDR2_ROW_13_COL_10 << SDRAM_SETUP_SIZE_IDX)     | \
+                                        (DDR2_8_BANKS       << SDRAM_SETUP_BANK_IDX)     | \
+                                        (DDR2_RW_GAP        << SDRAM_SETUP_RW_GAP_IDX)   | \
+                                        (DDR2_WR_GAP        << SDRAM_SETUP_WR_GAP_IDX)   | \
+                                        (DDR2_CAS_6         << SDRAM_SETUP_CAS_IDX))
+
+#define ADDR_SDRAM_REFRESH_DATA         (0x00000000 | PA_CONFIG_WRITE | DDR2_REFRESH_TIME)
+
+#define ADDR_SDRAM_AXI_CONFIG_DATA      (0x00000000 | PA_CONFIG_WRITE | \
+                                        (DDR2_BRC_ADDR      << SDRAM_AXI_SETUP_RBC_IDX)   | \
+                                        (DDR2_ROW_13_COL_10 << SDRAM_AXI_SETUP_SIZE_IDX)  | \
+                                        (DDR2_8_BANKS       << SDRAM_AXI_SETUP_BANK_IDX))
+
+#define ADDR_SDRAM_MRS_DATA             (0x00000000 | PA_CONFIG_WRITE | \
+                                        (PHY_CONFIG_BL_4        << MRS_PHY_CONFIG_BL_IDX) | \
+                                        (DDR2_BURST_SEQUENTIAL  << MRS_DDR2_BURST_SEQUENTIAL_IDX) | \
+                                        (DDR2_CAS_6             << MRS_DDR2_CAS_IDX) | \
+                                        (DDR2_WR                << MRS_DDR2_WR_IDX))
+
+#define SDRAM_ODT_75_OHM_LO             (0x1)
+#define SDRAM_ODT_75_OHM_HI             (0x0)
+
+#define ADDR_SDRAM_EMRS_DATA            (0x00000000 | PA_CONFIG_WRITE | \
+                                        (SDRAM_ODT_75_OHM_LO        << EMRS_ODT_LOW_BIT_IDX) | \
+                                        (SDRAM_ODT_75_OHM_HI        << EMRS_ODT_HIGH_BIT_IDX) | \
+                                        (DDR2_DQSN_DISABLE << EMRS_DQSN_DISABLE_IDX))
+
+#define ADDR_PHY_CONFIG_DATA            (0x00000000 | PA_CONFIG_WRITE | \
+                                        (DDR2_CAS_6                 << PHY_CONFIG_FIRST_RD_IDX) | \
+                                        ((DDR2_CAS_6 - 1)           << PHY_CONFIG_FIRST_WR_IDX) | \
+                                        (PHY_CONFIG_BL_4            << PHY_CONFIG_BL_IDX)       | \
+                                        (PHY_CONFIG_RDC_WE_TO_RE_2  << PHY_CONFIG_RDC_WE_TO_RE_IDX) | \
+                                        (PHY_CONFIG_FIXED_RE        << PHY_CONFIG_FIXED_RE_IDX))
+
+#define SDRAM_ODT_ENABLE_IDX            (0)
+#define SDRAM_ODT_ON_DELAY_IDX          (1)
+#define SDRAM_ODT_ON_DURN_IDX           (4)
+#define SDRAM_ODT_ENABLE                (0x1)
+#define SDRAM_ODT_ON_DURN               (0x2)
+
+#define ADDR_SDRAM_ODT_DATA             (0x00000000 | PA_CONFIG_WRITE | \
+                                        (SDRAM_ODT_ENABLE   << SDRAM_ODT_ENABLE_IDX) | \
+                                        ((DDR2_CAS_6 - 4)   << SDRAM_ODT_ON_DELAY_IDX) | \
+                                        (SDRAM_ODT_ON_DURN  << SDRAM_ODT_ON_DURN_IDX))
+
+#define PHY_LOCAL_ODT_75_OHM            (0x1)
+#define PHY_LOCAL_ODT_OFF               (0x0)
+#define PHY_LOCAL_ODT_READ_IDX          (0)
+#define PHY_LOCAL_ODT_WRITE_IDX         (2)
+#define PHY_LOCAL_ODT_IDLE_IDX          (4)
+
+#define ADDR_PHY_LOCAL_ODT_CONFIG_DATA  (0x00000000 | PA_CONFIG_WRITE | \
+                                        (PHY_LOCAL_ODT_75_OHM   << PHY_LOCAL_ODT_READ_IDX) | \
+                                        (PHY_LOCAL_ODT_OFF      << PHY_LOCAL_ODT_WRITE_IDX) | \
+                                        (PHY_LOCAL_ODT_OFF      << PHY_LOCAL_ODT_IDLE_IDX))
+
+#define PHY_RD0_DLL_SLAVE_DELAY         (0x30)
+#define PHY_RD1_DLL_SLAVE_DELAY         (0x30)
+#define PHY_WR_DLL_SLAVE_DELAY          (0x40)
+
+#define PHY_RD0_DLL_SLAVE_IDX           (0)
+#define PHY_RD1_DLL_SLAVE_IDX           (8)
+#define PHY_WR_DLL_SLAVE_IDX            (0)
+
+
+#define ADDR_PHY_RD_SLAVE_DATA          (0x00000000 | PA_CONFIG_WRITE | \
+                                        (PHY_RD0_DLL_SLAVE_DELAY << PHY_RD0_DLL_SLAVE_IDX) | \
+                                        (PHY_RD1_DLL_SLAVE_DELAY << PHY_RD1_DLL_SLAVE_IDX))
+
+#define ADDR_PHY_WR_SLAVE_DATA          (0x00000000 | PA_CONFIG_WRITE | \
+                                        (PHY_WR_DLL_SLAVE_DELAY << PHY_WR_DLL_SLAVE_IDX))
+
+
+#define PHY_IO_CELL_CONFIG_FIFO_WE_IN_ODT_IDX   (4)
+
+#define PHY_CTRL_DRV_STRENGTH_HALF              (1)
+#define PHY_DATA_DRV_STRENGTH_HALF              (1)
+#define PHY_CLK_DRV_STRENGTH_HALF               (1)
+#define PHY_FIFO_WE_DRV_STRENGTH_HALF           (1)
+
+#define PHY_CTRL_DRV_STRENGTH_HALF_IDX          (0)
+#define PHY_DATA_DRV_STRENGTH_HALF_IDX          (1)
+#define PHY_CLK_DRV_STRENGTH_HALF_IDX           (2)
+#define PHY_FIFO_WE_DRV_STRENGTH_HALF_IDX       (3)
+
+
+#define ADDR_PHY_IO_CELL_CONFIG_DATA    (0x00000000 | PA_CONFIG_WRITE | \
+                                        (PHY_LOCAL_ODT_75_OHM           << PHY_IO_CELL_CONFIG_FIFO_WE_IN_ODT_IDX) | \
+                                        (PHY_FIFO_WE_DRV_STRENGTH_HALF  << PHY_FIFO_WE_DRV_STRENGTH_HALF_IDX) | \
+                                        (PHY_CLK_DRV_STRENGTH_HALF      << PHY_CLK_DRV_STRENGTH_HALF_IDX) | \
+                                        (PHY_DATA_DRV_STRENGTH_HALF     << PHY_DATA_DRV_STRENGTH_HALF_IDX) | \
+                                        (PHY_CTRL_DRV_STRENGTH_HALF     << PHY_CTRL_DRV_STRENGTH_HALF_IDX))
+
+#define ADDR_SDRAM_CFG_DONE_DATA        (0x0001 | PA_CONFIG_WRITE)
+
+#define PA_WRITE_ZERO_DATA              (PA_CONFIG_WRITE)
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif /* PC302_MEM_SHD_H */
diff --git a/include/asm-arm/arch-pc302/mii_phy.h b/include/asm-arm/arch-pc302/mii_phy.h
new file mode 100644
index 0000000..010062d
--- /dev/null
+++ b/include/asm-arm/arch-pc302/mii_phy.h
@@ -0,0 +1,66 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file mii_phy.h
+* \brief Definitions for the Ethernet Phy used on hardware platforms.
+*
+* Copyright (c) 2006-2008 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef PC302_MII_PHY_H
+#define PC302_MII_PHY_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/* Constant-s -------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+#define PHY_BMCR                    (0x00)
+#define PHY_BMSR		    (0x01)
+#define PHY_PHYIDR1		    (0x02)
+#define PHY_PHYIDR2		    (0x03)
+#define PHY_ANAR		    (0x04)
+#define PHY_ANLPAR		    (0x05)
+#define PHY_ANER		    (0x06)
+#define PHY_ANNPTR		    (0x07)
+
+/* PHY_BMCR Bits */
+#define PHY_BMCR_RESET		    (1<< 15)
+#define PHY_BMCR_LOOP_BACK	    (1 << 14)
+#define PHY_BMCR_100MB		    (1 << 13)
+#define PHY_BMCR_AUTO_NEG_ENABLE    (1 << 12)
+#define PHY_BMCR_POWER_DOWN         (1 << 11)
+#define PHY_BMCR_ISOLATE	    (1 << 10)
+#define PHY_BMCR_RESTART_NEG	    (1 << 9)
+#define PHY_BMCR_FULL_DUPLEX	    (1 << 8)
+
+/* PHY_BMSR Bits */
+#define PHY_BMSR_100T4		    (1 << 15)
+#define PHY_BMSR_100TXF		    (1 << 14)
+#define PHY_BMSR_100TXH		    (1 << 13)
+#define PHY_BMSR_10TF		    (1 << 12)
+#define PHY_BMSR_10TH		    (1 << 11)
+#define PHY_BMSR_AUTO_NEG_COMPLETE  (1 << 5)
+#define PHY_BMSR_REMOTE_FAULT	    (1 << 4)
+#define PHY_BMSR_AUTO_NEG_ABLE	    (1 << 3)
+#define PHY_BMSR_LINK_UP	    (1 << 2)
+
+/* PHY_ANLPAR Bits */
+#define PHY_ANLPAR_100TXF	    (1 << 8)
+#define PHY_ANLPAR_100TXH           (1 << 7)
+#define PHY_ANLPAR_10TF             (1 << 6)
+#define PHY_ANLPAR_10TH		    (1 << 5)
+
+#endif /* PC302_MII_PHY_H */
diff --git a/include/asm-arm/arch-pc302/pa.h b/include/asm-arm/arch-pc302/pa.h
new file mode 100644
index 0000000..d6fc478
--- /dev/null
+++ b/include/asm-arm/arch-pc302/pa.h
@@ -0,0 +1,41 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file pa.h
+* \brief Definitions for the picoArray.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef PC302_PA_H
+#define PC302_PA_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/* Constants --------------------------------------------------------------- */
+
+#define PA_AEID_MEMIF       (0x0088)
+
+#define PA_CONFIG_WRITE     (0x00010000)
+#define PA_CONFIG_READ      (0x00020000)
+#define PA_CONFIG_ADDR      (0x00040000)
+#define PA_CONFIG_AEID      (0x00080000)
+#define PA_CONFIG_VALID     (0x00010000)
+#define PA_CONFIG_FAIL      (0x00020000)
+#define PA_CONFIG_TIMEOUT   (0x00040000)
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif /* PC302_PA_H */
diff --git a/include/asm-arm/arch-pc302/pc302.h b/include/asm-arm/arch-pc302/pc302.h
new file mode 100644
index 0000000..4d7ee9a
--- /dev/null
+++ b/include/asm-arm/arch-pc302/pc302.h
@@ -0,0 +1,97 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file pc302.h
+* \brief Definitions for the PC302 ARM sub-system.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef PC302_H
+#define PC302_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/*****************************************************************************/
+/* Internal Boot ROM                                                         */
+/*****************************************************************************/
+#define PC302_BOOT_ROM_BASE         (0xFFFF0000)
+
+/*****************************************************************************/
+/* AXI2PICO Buffers                                                          */
+/*****************************************************************************/
+#define PC302_AXI2PICO_BUFFERS_BASE (0xC0000000)
+
+/*****************************************************************************/
+/* Peripheral Bus                                                            */
+/*****************************************************************************/
+#define PC302_MEMIF_BASE            (0x80000000)
+#define PC302_EBI_BASE              (0x80010000)
+#define PC302_EMAC_BASE             (0x80030000)
+#define PC302_DMAC1_BASE            (0x80040000)
+#define PC302_DMAC2_BASE            (0x80050000)
+#define PC302_VIC0_BASE             (0x80060000)
+#define PC302_VIC1_BASE             (0x80064000)
+#define PC302_TZIC_BASE             (0x80068000)
+#define PC302_TZPC_BASE             (0x80070000)
+#define PC302_FUSE_BASE             (0x80080000)
+#define PC302_SSI_BASE              (0x80090000)
+#define PC302_AXI2CFG_BASE          (0x800A0000)
+#define PC302_IPSEC_BASE            (0x80100000)
+#define PC302_SRTP_BASE             (0x80140000)
+#define PC302_CIPHER_BASE           (0x80180000)
+#define PC302_RTCLK_BASE            (0x80200000)
+#define PC302_TIMER_BASE            (0x80210000)
+#define PC302_GPIO_BASE             (0x80220000)
+#define PC302_UART1_BASE            (0x80230000)
+#define PC302_UART2_BASE            (0x80240000)
+#define PC302_WDOG_BASE             (0x80250000)
+
+/*****************************************************************************/
+/* External Memory                                                           */
+/*****************************************************************************/
+#define PC302_DDRBANK_BASE          (0x00000000)
+
+#define PC302_EBI_CS0_BASE          (0x40000000)
+#define PC302_EBI_CS1_BASE          (0x48000000)
+#define PC302_EBI_CS2_BASE          (0x50000000)
+#define PC302_EBI_CS3_BASE          (0x58000000)
+
+#define PC302_FLASH_BASE            (PC302_EBI_CS0_BASE)
+#define PC302_FLASH_START           (PC302_EBI_CS0_BASE)
+#define PC302_FLASH_SIZE            (0x08000000)
+
+/*****************************************************************************/
+/* Internal SRAM Memory                                                      */
+/*****************************************************************************/
+#define PC302_SRAM_BASE             (0x20000000)
+#define PC302_SRAM_START            (0x20000000)
+#define PC302_SRAM_SIZE             (0x00020000)
+
+/*****************************************************************************/
+/* Silicon Revision                                                          */
+/*****************************************************************************/
+#define PC302_REV_A                 (0)
+#define PC302_REV_D                 (1)
+
+/*****************************************************************************/
+/* Device Ids                                                                */
+/*****************************************************************************/
+#define PC302_DEVICE_ID             (3)
+#define PC312_DEVICE_ID             (7)
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif /* PC302_H */
diff --git a/include/asm-arm/arch-pc302/pc302_gpio.h b/include/asm-arm/arch-pc302/pc302_gpio.h
new file mode 100644
index 0000000..06cc7f0
--- /dev/null
+++ b/include/asm-arm/arch-pc302/pc302_gpio.h
@@ -0,0 +1,162 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+ * \file pc302_gpio.h
+ * \brief Definitions use with the PC302 gpio library.
+ *
+ * Copyright (c) 2009 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+#ifndef PC302_PC302_GPIO_H
+#define PC302_PC302_GPIO_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/* Constants --------------------------------------------------------------- */
+
+/*!
+ * \brief GPIO and SDGPIO identifiers for PC302 devices.
+ *
+ * This enum defines a list of (SD)GPIO sources that are available for
+ * use in PC302 devices.
+ */
+enum picoifGpioPinNum_PC302
+{
+    PC302_GPIO_PIN_INVAL = -1,  /*< Invalid pin configuration. */
+    PC302_GPIO_PIN_ARM_0 =  0,  /* ARM GPIO pin identifiers. */
+    PC302_GPIO_PIN_ARM_1,
+    PC302_GPIO_PIN_ARM_2,
+    PC302_GPIO_PIN_ARM_3,
+    PC302_GPIO_PIN_ARM_4,
+    PC302_GPIO_PIN_ARM_5,
+    PC302_GPIO_PIN_ARM_6,
+    PC302_GPIO_PIN_ARM_7,
+    PC302_GPIO_PIN_SDGPIO_0,    /* SDGPIO pin identifiers. */
+    PC302_GPIO_PIN_SDGPIO_1,
+    PC302_GPIO_PIN_SDGPIO_2,
+    PC302_GPIO_PIN_SDGPIO_3,
+    PC302_GPIO_PIN_SDGPIO_4,
+    PC302_GPIO_PIN_SDGPIO_5,
+    PC302_GPIO_PIN_SDGPIO_6,
+    PC302_GPIO_PIN_SDGPIO_7,
+    PC302_GPIO_PIN_ARM_8,      /* ARM shared pins. */
+    PC302_GPIO_PIN_ARM_9,
+    PC302_GPIO_PIN_ARM_10,
+    PC302_GPIO_PIN_ARM_11,
+    PC302_GPIO_PIN_ARM_12,
+    PC302_GPIO_PIN_ARM_13,
+    PC302_GPIO_PIN_ARM_14,
+    PC302_GPIO_PIN_ARM_15,
+    PC302_GPIO_PIN_SDGPIO_8,  /* SDGPIO shared pins. */
+    PC302_GPIO_PIN_SDGPIO_9,
+    PC302_GPIO_PIN_SDGPIO_10,
+    PC302_GPIO_PIN_SDGPIO_11,
+    PC302_GPIO_PIN_SDGPIO_12,
+    PC302_GPIO_PIN_SDGPIO_13,
+    PC302_GPIO_PIN_SDGPIO_14,
+    PC302_GPIO_PIN_SDGPIO_15,
+    PICO_NUM_GPIOS,
+};
+
+/*!
+ * \brief Type for identifying (SD)GPIO pins in a picoArray.
+ *
+ * GPIO identifier. This is used to define an GPIO resource which
+ * should be used rather than absolute GPIO numbers.
+ *
+ * Each device description file will populate this enum with device specific
+ * values.
+ */
+typedef enum picoifGpioPinNum_PC302 picoifGpioPinNum_t;
+
+/* Prototypes--------------------------------------------------------------- */
+/**
+ * Initialise the gpio library for use
+ *
+ * \return Returns zero on success, non-zero on failure.
+ */
+int
+pc302_gpio_init( void );
+
+/**
+ * Request a new GPIO pin. This implements part of the Linux GPIO guidelines.
+ *
+ * \param gpio The pin to request.
+ * \param label The name of the pin - this only serves as a tag for debugging
+ * so can be anything.
+ * \return Returns zero on success, non-zero on failure.
+ */
+int
+pc302_gpio_request( unsigned gpio,
+                    const char *label );
+
+/**
+ * Free a GPIO pin previously requested with gpio_request().
+ *
+ * \param gpio The GPIO pin to free.
+ */
+void
+pc302_gpio_free( unsigned gpio );
+
+/**
+ * Set the direction of a GPIO pin requested with gpio_request() to be an
+ * input.
+ *
+ * \param gpio The GPIO pin to configure.
+ * \return Returns zero on success, non-zero on failure.
+ */
+int
+pc302_gpio_direction_input( unsigned gpio );
+
+/**
+ * Set the direction of a GPIO pin requested with gpio_request() to be an
+ * output.
+ *
+ * \param gpio The GPIO pin to configure.
+ * \param value The initial output value for the gpio pin.
+ * \return Returns zero on success, non-zero on failure.
+ */
+int
+pc302_gpio_direction_output( unsigned gpio,
+                             int value );
+
+/**
+ * Set the value of a GPIO pin.
+ *
+ * \param gpio The number of the pin to set the value of.
+ * \param value The value to set the pin to.
+ */
+int
+pc302_gpio_set_value( unsigned gpio,
+                      int value );
+
+/**
+ * Get the value of a GPIO pin.
+ *
+ * \param gpio The number of the pin to get the value of.
+ * \return Returns the value of the pin on success,
+ * negative on failure.
+ */
+int
+pc302_gpio_get_value( unsigned gpio );
+
+int
+pc302_gpio_configure_dac( unsigned gpio,
+                          u8 converter_size,
+                          u16 analogue_rate );
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif /* !PC302_PC302_GPIO_H */
diff --git a/include/asm-arm/arch-pc302/sizes.h b/include/asm-arm/arch-pc302/sizes.h
new file mode 100644
index 0000000..6e8253a
--- /dev/null
+++ b/include/asm-arm/arch-pc302/sizes.h
@@ -0,0 +1,51 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file sizes.h
+* \brief Define some useful size macros.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __sizes_h
+#define __sizes_h			1
+
+/* Useful sizes (all specified in Bytes)*/
+#define SZ_128      (0x00000080)
+#define SZ_256      (0x00000100)
+#define SZ_512      (0x00000200)
+
+#define SZ_1K       (0x00000400)
+#define SZ_2K       (0x00000800)
+#define SZ_4K	    (0x00001000)
+#define SZ_8K	    (0x00002000)
+#define SZ_16K	    (0x00004000)
+#define SZ_32K      (0x00008000)
+#define SZ_64K	    (0x00010000)
+#define SZ_128K	    (0x00020000)
+#define SZ_256K	    (0x00040000)
+#define SZ_512K	    (0x00080000)
+
+#define SZ_1M	    (0x00100000)
+#define SZ_2M	    (0x00200000)
+#define SZ_4M	    (0x00400000)
+#define SZ_8M	    (0x00800000)
+#define SZ_16M	    (0x01000000)
+#define SZ_32M	    (0x02000000)
+#define SZ_64M	    (0x04000000)
+#define SZ_128M	    (0x08000000)
+#define SZ_256M	    (0x10000000)
+#define SZ_512M	    (0x20000000)
+
+#define SZ_1G	    (0x40000000)
+#define SZ_2G	    (0x80000000)
+
+#endif	/* __sizes_h */
diff --git a/include/asm-arm/arch-pc302/spi.h b/include/asm-arm/arch-pc302/spi.h
new file mode 100644
index 0000000..7b7b76e
--- /dev/null
+++ b/include/asm-arm/arch-pc302/spi.h
@@ -0,0 +1,106 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file spi.h
+* \brief Definitions for the PC302 SSI Block.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef PC302_SSI_H
+#define PC302_SSI_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+/* Functional Registers */
+
+#define SSI_CTRL_REG_0_REG_OFFSET                   (0x00)
+#define SSI_CTRL_REG_1_REG_OFFSET                   (0x04)
+#define SSI_ENABLE_REG_REG_OFFSET                   (0x08)
+#define SSI_MW_CTRL_REG_OFFSET                      (0x0C)
+#define SSI_SLAVE_ENABLE_REG_OFFSET                 (0x10)
+#define SSI_BAUD_RATE_SEL_REG_OFFSET                (0x14)
+#define SSI_TX_FIFO_THRESHOLD_REG_OFFSET            (0x18)
+#define SSI_RX_FIFO_THRESHOLD_REG_OFFSET            (0x1C)
+#define SSI_TX_FIFO_LEVEL_REG_OFFSET                (0x20)
+#define SSI_RX_FIFO_LEVEL_REG_OFFSET                (0x24)
+#define SSI_STATUS_REG_OFFSET                       (0x28)
+#define SSI_IMR_REG_OFFSET                          (0x2C)
+#define SSI_ISR_REG_OFFSET                          (0x30)
+#define SSI_RAW_ISR_REG_OFFSET                      (0x34)
+#define SSI_TX_FIFO_OVRFLOW_INT_CLEAR_REG_OFFSET    (0x38)
+#define SSI_RX_FIFO_OVRFLOW_INT_CLEAR_REG_OFFSET    (0x3C)
+#define SSI_RX_FIFO_UNDFLOW_INT_CLEAR_REG_OFFSET    (0x40)
+#define SSI_MM_INT_CLEAR_REG_OFFSET                 (0x44)
+#define SSI_INT_CLEAR_REG_OFFSET                    (0x48)
+#define SSI_DMA_CTRL_REG_OFFSET                     (0x4C)
+#define SSI_DMA_TX_DATA_LEVEL_REG_OFFSET            (0x50)
+#define SSI_DMA_RX_DATA_LEVEL_REG_OFFSET            (0x54)
+#define SSI_DATA_REG_OFFSET                         (0x60)
+
+/* Identification Registers */
+
+#define SSI_ID_REG_OFFSET                           (0x58)
+#define SSI_COMP_VERSION_REG_OFFSET                 (0x5C)
+
+/* Types ------------------------------------------------------------------- */
+
+/* Macros ------------------------------------------------------------------ */
+#define PC302_MAX_NUMBER_SPI_CS     (4)
+#define PC302_MAX_NUMBER_SPI_BUSSES (1)
+#define PC302_MIN_SPI_CLK_DIVIDER   (2)
+#define PC302_MAX_SPI_CLK_DIVIDER   (65534)
+
+/* SSI_CTRL_REG_0_REG_OFFSET bites */
+#define PC302_SPI_LOOPBACK_MODE     (1 << 11)
+#define PC302_SPI_NORMAL_MODE       (0)
+#define PC302_SPI_TMOD_TX_RX        (0x0)
+#define PC302_SPI_TMOD_TX           (0x1 << 8)
+#define PC302_SPI_TMOD_RX           (0x2 << 8)
+#define PC302_SPI_TMOD_EEPROM_RX    (0x3 << 8)
+#define PC302_SPI_SCPOL             (1 << 7)
+#define PC302_SPI_SCPH              (1 << 6)
+#define PC302_SPI_MOTO_FORMAT       (0x0)
+#define PC302_SPI_DATA_FRM_8_BIT    (0x7)
+
+
+/* SSI_ENABLE_REG_REG_OFFSET bits */
+#define PC302_SPI_ENABLE            (1)
+#define PC302_SPI_DISABLE           (0)
+
+/* SSI_SLAVE_ENABLE_REG_OFFSET bits */
+#define PC302_SPI_SLAVES_DISABLE    (0)
+
+/* SSI_STATUS_REG_OFFSET bits */
+#define PC302_SPI_STATUS_DCOL       (1 << 6)
+#define PC302_SPI_STATUS_TXE        (1 << 5)
+#define PC302_SPI_STATUS_RFF        (1 << 4)
+#define PC302_SPI_STATUS_RFNE       (1 << 3)
+#define PC302_SPI_STATUS_TFE        (1 << 2)
+#define PC302_SPI_STATUS_TFNF       (1 << 1)
+#define PC302_SPI_STATUS_BUSY       (1 << 0)
+
+/* SSI_IMR_REG_RESET bits */
+#define PC302_SPI_MASK_ALL_INTS     (0xFFFF)
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif /* PC302_SSI_H */
diff --git a/include/asm-arm/arch-pc302/timer.h b/include/asm-arm/arch-pc302/timer.h
new file mode 100644
index 0000000..a28eaa4
--- /dev/null
+++ b/include/asm-arm/arch-pc302/timer.h
@@ -0,0 +1,93 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file timer.h
+* \brief Definitions for the PC302 Timer Block.
+*
+* Copyright (c) 2006-2008 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef PC302_TIMER_H
+#define PC302_TIMER_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+/* Individual definitions */
+#define TIMER1_LOAD_COUNT_REG_OFFSET        (0x00)
+#define TIMER1_CURRENT_VALUE_REG_OFFSET     (0x04)
+#define TIMER1_CONTROL_REG_OFFSET           (0x08)
+#define TIMER1_EOI_REG_OFFSET               (0x0c)
+#define TIMER1_INT_STATUS_REG_OFFSET        (0x10)
+
+#define TIMER2_LOAD_COUNT_REG_OFFSET        (0x14)
+#define TIMER2_CURRENT_VALUE_REG_OFFSET     (0x18)
+#define TIMER2_CONTROL_REG_OFFSET           (0x1c)
+#define TIMER2_EOI_REG_OFFSET               (0x20)
+#define TIMER2_INT_STATUS_REG_OFFSET        (0x24)
+
+#define TIMER3_LOAD_COUNT_REG_OFFSET        (0x28)
+#define TIMER3_CURRENT_VALUE_REG_OFFSET     (0x2c)
+#define TIMER3_CONTROL_REG_OFFSET           (0x30)
+#define TIMER3_EOI_REG_OFFSET               (0x34)
+#define TIMER3_INT_STATUS_REG_OFFSET        (0x38)
+
+#define TIMER4_LOAD_COUNT_REG_OFFSET        (0x3c)
+#define TIMER4_CURRENT_VALUE_REG_OFFSET     (0x40)
+#define TIMER4_CONTROL_REG_OFFSET           (0x44)
+#define TIMER4_EOI_REG_OFFSET               (0x48)
+#define TIMER4_INT_STATUS_REG_OFFSET        (0x4c)
+
+#define TIMERS_INT_STATUS_REG_OFFSET        (0xa0)
+#define TIMERS_EOI_REG_OFFSET               (0xa4)
+#define TIMERS_RAW_INT_STATUS_REG_OFFSET    (0xa8)
+#define TIMERS_COMP_VERSION_REG_OFFSET      (0xac)
+
+/* Macros ------------------------------------------------------------------ */
+
+/* Generic definitions 'borrowed' from U-Boot land */
+
+/* The number of timers in the hardware, numbered 0 to N-1 */
+#define TIMERNUMBEROFTIMERS                 (4)
+
+/* Register definitions for the timers */
+#define TIMERNLOADCOUNTREGOFFSET(__N)       (0x0000 + (0x14 * (__N)))
+#define TIMERNCURRENTVALUEREGOFFSET(__N)    (0x0004 + (0x14 * (__N)))
+#define TIMERNCONTROLREGOFFSET(__N)         (0x0008 + (0x14 * (__N)))
+#define TIMERNEOIREGOFFSET(__N)             (0x000c + (0x14 * (__N)))
+#define TIMERNINTERRUPTSTATUSREGOFFSET(__N) (0x0010 + (0x14 * (__N)))
+
+/* Timer N control register bit definitions */
+#define TIMERENABLE                         (0x00000001)
+#define TIMERMODE                           (0x00000002)
+#define TIMERINTERRUPTMASK                  (0x00000004)
+
+
+/* Register definitions for global timer registers */
+#define TIMERSINTERRUPTSTATUSREGOFFSET      (0x00a0)
+#define TIMERSEOIREGOFFSET                  (0x00a4)
+#define TIMERSRAWINTERRUPTSTATUSREGOFFSET   (0x00a8)
+
+/* Global Timer Registers bit definitions */
+#define TIMER(__N)                          (0x00000001 << (__N))
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif /* PC302_TIMER_H */
diff --git a/include/asm-arm/arch-pc302/uart.h b/include/asm-arm/arch-pc302/uart.h
new file mode 100644
index 0000000..a05527e
--- /dev/null
+++ b/include/asm-arm/arch-pc302/uart.h
@@ -0,0 +1,166 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file uart.h
+* \brief Definitions for the PC302 UART Block.
+*
+* Copyright (c) 2006-2008 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef PC302_UART_H
+#define PC302_UART_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define UART_RX_BUFFER_REG_OFFSET               (0x00)
+#define UART_TX_HOLDING_REG_OFFSET		(0x00)
+#define UART_DIVISOR_LOW_REG_OFFSET		(0x00)
+#define UART_DIVISOR_HIGH_REG_OFFSET		(0x04)
+#define UART_INT_ENABLE_REG_OFFSET		(0x04)
+#define UART_INT_IDENTITY_REG_OFFSET		(0x08)
+#define UART_FIFO_CTRL_REG_OFFSET		(0x08)
+#define UART_LINE_CTRL_REG_OFFSET		(0x0c)
+#define UART_MODEM_CTRL_REG_OFFSET		(0x10)
+#define UART_LINE_STATUS_REG_OFFSET		(0x14)
+#define UART_MODEM_STATUS_REG_OFFSET		(0x18)
+#define UART_SCRATCH_REG_OFFSET			(0x1c)
+
+#define UART_UART_STATUS_REG_OFFSET             (0x7c)
+
+#define UART_SHADOW_RTS_REG_OFFSET		(0x8c)
+#define UART_SHADOW_BRK_CTRL_REG_OFFSET		(0x90)
+#define UART_SHADOW_DMA_MODE_REG_OFFSET		(0x94)
+#define UART_SHADOW_FIFO_ENABLE_REG_OFFSET	(0x98)
+#define UART_SHADOW_RCVR_TRIGGER_REG_OFFSET	(0x9c)
+#define UART_SHADOW_TX_EMPTY_TRIGGER_REG_OFFSET	(0xa0)
+#define UART_HALT_TX_REG_OFFSET			(0xa4)
+#define UART_DMA_SOFT_ACK_REG_OFFSET		(0xa8)
+#define UART_COMP_PARAM_REG_OFFSET		(0xf4)
+#define UART_UART_VERSION_REG_OFFSET		(0xf8)
+#define UART_COMP_TYPE_REG_OFFSET		(0xfc)
+
+/* Macros ------------------------------------------------------------------ */
+
+/* DLL & DLH */
+#define UART_DIVISOR_MASK               (0xFF)
+
+/* IER */
+#define UART_INT_ENABLE_PTIME_IDX	(0x7)	/* Programmable THRE Interrupt Mode Enable that can be */
+						/*  written to only when THRE_MODE_USER == Enabled, */
+						/*  always readable. This is used to enable/disable the */
+						/*  generation of THRE Interrupt. */
+#define UART_INT_ENABLE_EDSSI_IDX       (0x3)   /*  R/W Enable Modem Status Interrupt. */
+#define UART_INT_ENABLE_ELSI_IDX        (0x2)   /*  R/W Enable Receiver Line Status Interrupt. */
+#define UART_INT_ENABLE_ETBEI_IDX       (0x1)   /*  R/W Enable Transmit Holding Register Empty Interrupt. */
+#define UART_INT_ENABLE_ERBFI_IDX       (0x0)   /*  R/W Enable Received Data Available Interrupt. */
+
+#define UART_INT_ENABLE_PTIME_MASK          (1 << UART_INT_ENABLE_PTIME_IDX)
+#define UART_INT_ENABLE_EDSSI_MASK          (1 << UART_INT_ENABLE_EDSSI_IDX)
+#define UART_INT_ENABLE_ELSI_MASK           (1 << UART_INT_ENABLE_ELSI_IDX)
+#define UART_INT_ENABLE_ETBEI_MASK          (1 << UART_INT_ENABLE_ETBEI_IDX)
+#define UART_INT_ENABLE_ERBFI_MASK          (1 << UART_INT_ENABLE_ERBFI_IDX)
+
+/* IIR */
+#define UART_INT_IDENTITY_MASK	            (0x0F)
+#define UART_INT_IDENTITY_MODEM_STATUS      (0x00)
+#define UART_INT_IDENTITY_NONE	            (0x01)
+#define UART_INT_IDENTITY_THR_EMPTY	    (0x02)
+#define UART_INT_IDENTITY_RX_DATA	    (0x04)
+#define UART_INT_IDENTITY_RX_LINE_STATUS    (0x06)
+#define UART_INT_IDENTITY_BUSY_DETECT       (0x07)
+#define UART_INT_IDENTITY_CHARACTER_TIMEOUT (0x0C)
+
+/* FCR */
+#define UART_FIFO_CTRL_RCVR_MASK	        (0xC0)
+#define UART_FIFO_CTRL_RCVR1_CHAR	        (0x00)  /* 00 = 1 character in the FIFO */
+#define UART_FIFO_CTRL_RCVR_QUARTER_FULL        (0x40)  /* 01 = FIFO  full */
+#define UART_FIFO_CTRL_RCVR_HALF_FULL           (0x80)  /* 10 = FIFO  full */
+#define UART_FIFO_CTRL_RCVR_2_LESS_THAN_FULL    (0xC0)  /* 11 = FIFO 2 less than full */
+
+#define UART_FIFO_CTRL_TX_EMPTY_MASK	        (0x30)
+#define UART_FIFO_CTRL_TX_EMPTY_EMPTY           (0x00)  /* 00 = FIFO empty */
+#define UART_FIFO_CTRL_TX_EMPTY_2_CHARS         (0x10)  /* 01 = 2 characters in the FIFO */
+#define UART_FIFO_CTRL_TX_EMPTY_QUARTER_FULL    (0x20)  /* 10 = FIFO  full */
+#define UART_FIFO_CTRL_TX_EMPTY_HALF_FULL       (0x30)  /* 11 = FIFO  full */
+
+#define UART_FIFO_CTRL_ENABLE		        (0x01)	/* fifo enable bit */
+
+
+/* LCR indices */
+#define UART_LINE_CTRL_DLAB_IDX                 (7)     /* Divisor latch access bit */
+#define UART_LINE_CTRL_BRK_IDX                  (6)
+#define UART_LINE_CTRL_EPS_IDX                  (4)
+#define UART_LINE_CTRL_PEN_IDX                  (3)
+#define UART_LINE_CTRL_STOP_IDX                 (2)
+#define UART_LINE_CTRL_DLS_IDX                  (0)
+
+/* LCR bit masks */
+#define UART_LINE_CTRL_DLAB_MASK	        (1 << UART_LINE_CTRL_DLAB_IDX)
+#define UART_LINE_CTRL_BRK_MASK	                (1 << UART_LINE_CTRL_BRK_IDX)
+#define UART_LINE_CTRL_EPS_MASK	                (1 << UART_LINE_CTRL_EPS_IDX)
+#define UART_LINE_CTRL_PEN_MASK	                (1 << UART_LINE_CTRL_PEN_IDX)
+#define UART_LINE_CTRL_STOP_MASK                (1 << UART_LINE_CTRL_STOP_IDX)
+#define UART_LINE_CTRL_DLS_MASK	                (3)
+#define UART_LINE_CTRL_DLS_8BITS	        (3)     /* 8 bit data length */
+#define UART_LINE_CTRL_DLS_7BITS	        (2)     /* 7 bit data length */
+#define UART_LINE_CTRL_DLS_6BITS	        (1)     /* 6 bit data length */
+#define UART_LINE_CTRL_DLS_5BITS	        (0)     /* 5 bit data length */
+
+#define UART_LINE_CTRL_1STOP_BIT                (~(UART_LINE_CTRL_STOP_MASK))
+#define UART_LINE_CTRL_PARITY_DISABLE           (~(UART_LINE_CTRL_PEN_MASK))
+
+/* MCR indices */
+#define UART_MODEM_CTRL_LOOPBACK_IDX            (4)
+#define UART_MODEM_CTRL_OUT2_IDX		(3)
+#define UART_MODEM_CTRL_OUT1_IDX		(2)
+#define UART_MODEM_CTRL_CTS_IDX		        (1)
+#define UART_MODEM_CTRL_DTR_IDX		        (0)
+
+/* MCR bit masks */
+#define UART_MODEM_CTRL_LOOPBACK_MASK	        (1 << UART_MODEM_CTRL_LOOPBACK_IDX)
+#define UART_MODEM_CTRL_OUT2_MASK		(1 << UART_MODEM_CTRL_OUT2_IDX)
+#define UART_MODEM_CTRL_OUT1_MASK		(1 << UART_MODEM_CTRL_OUT1_IDX)
+#define UART_MODEM_CTRL_CTS_MASK		(1 << UART_MODEM_CTRL_CTS_IDX)
+#define UART_MODEM_CTRL_DTR_MASK		(1 << UART_MODEM_CTRL_DTR_IDX)
+
+#define UART_MODEM_STATUS_CTS_IDX               (4)     /* CTS input */
+#define UART_MODEM_STATUS_DCTS_IDX              (0)     /* change in CTS input since last read */
+
+#define UART_LINE_STATUS_THRE_IDX	        (5)
+#define UART_LINE_STATUS_DATA_READY_IDX         (0)
+#define UART_LINE_STATUS_THRE_MASK	        (1 << UART_LINE_STATUS_THRE_IDX)
+#define UART_LINE_STATUS_DATA_READY_MASK        (1 << UART_LINE_STATUS_DATA_READY_IDX)
+
+#define UART_UART_STATUS_RFF_IDX                (4)     /* RX FIFO full */
+#define UART_UART_STATUS_RFNE_IDX	        (3)     /* RX FIFO not empty */
+#define UART_UART_STATUS_TFE_IDX	        (2)
+#define UART_UART_STATUS_TFNF_IDX	        (1)
+#define UART_UART_STATUS_BUSY_IDX	        (0)
+
+#define UART_UART_STATUS_RFF_MASK               (1 << UART_UART_STATUS_RFF_IDX)
+#define UART_UART_STATUS_RFNE_MASK              (1 << UART_UART_STATUS_RFNE_IDX)
+#define UART_UART_STATUS_TFE_MASK               (1 << UART_UART_STATUS_TFE_IDX)
+#define UART_UART_STATUS_TFNF_MASK              (1 << UART_UART_STATUS_TFNF_IDX)
+#define UART_UART_STATUS_BUSY_MASK              (1 << UART_UART_STATUS_BUSY_IDX)
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif /* PC302_UART_H */
diff --git a/include/asm-arm/arch-pc302/utilities.h b/include/asm-arm/arch-pc302/utilities.h
new file mode 100644
index 0000000..e0e6a87
--- /dev/null
+++ b/include/asm-arm/arch-pc302/utilities.h
@@ -0,0 +1,113 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file utilities.h
+* \brief Definitions for some useful PC302 functions.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+#ifndef PC302_UTILITIES_H
+#define PC302_UTILITIES_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+
+/* Prototypes--------------------------------------------------------------- */
+/*!
+ *
+ * Read an integer value from a register.
+ *
+ * \param The address to read from
+ * \return The value read
+ */
+__inline unsigned int pc302_read_from_register (const unsigned int address);
+
+/*!
+ *
+ * Write an integer value to a register
+ *
+ * \param The address to write to
+ * \param The value to write.
+ */
+__inline void pc302_write_to_register (const unsigned int address,
+                                       const unsigned int value);
+
+/*!
+ *
+ * Read the device identification code from the axi2cfg block
+ *
+ * \return The value read
+ */
+unsigned int pc302_read_device_id (void);
+
+/*!
+ *
+ * Read the device revision from the axi2cfg block
+ *
+ * \return The value read
+ */
+unsigned int pc302_read_device_revision (void);
+
+/*!
+ *
+ * Read the die id number from the fuse block
+ *
+ * \param die_number Pointer to an array
+ */
+void pc302_read_die_id_number (unsigned int * die_number);
+
+/*!
+ *
+ * Return the state of the Reduced MII (RMII) enabled bit in the
+ * axi2cfg block, system config register.
+ *
+ * \return 0 - RMII not enabled
+ *         1 - RMII enabled
+ */
+unsigned int pc302_get_rmii_enabled (void);
+
+/*!
+ * Read a number of 16 bit words from the PC302 axi2cfg.
+ *
+ * @param caeid The CAEID of the AE to read from.
+ * @param address The start address in the AE to begin reading from.
+ * @param count The number of 16 bit words to read.
+ * @param[out] data The buffer to store the data in.
+ * @return Returns the number of words read on success, negative on failure.
+ */
+int
+pc302_config_read( u16 caeid,
+                   u16 address,
+                   u16 count,
+                   u16 *data );
+
+/*!
+ * Write a number of 16 bit words to the PC302 axi2cfg.
+ *
+ * @param caeid The CAEID of the AE to write to.
+ * @param address The start address in the AE to begin writing to.
+ * @param count The number of 16 bit words to write.
+ * @param[in] data The buffer to write from.
+ * @return Returns the number of words written on success, negative on failure.
+ */
+int
+pc302_config_write( u16 caeid,
+                    u16 address,
+                    u16 count,
+                    u16 *data );
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif /* PC302_UTILITIES_H */
diff --git a/include/asm-arm/arch-pc302/wdog.h b/include/asm-arm/arch-pc302/wdog.h
new file mode 100644
index 0000000..5f93653
--- /dev/null
+++ b/include/asm-arm/arch-pc302/wdog.h
@@ -0,0 +1,68 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file wdog.h
+* \brief Definitions for the PC302 WDOG Block.
+*
+* Copyright (c) 2006-2008 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef PC302_WDOG_H
+#define PC302_WDOG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define WDOG_CONTROL_REG_OFFSET             (0x00)
+#define WDOG_TIMEOUT_RANGE_REG_OFFSET       (0x04)
+#define WDOG_CURRENT_COUNT_REG_OFFSET       (0x08)
+#define WDOG_COUNTER_RESTART_REG_OFFSET     (0x0c)
+#define WDOG_INT_STATUS_REG_OFFSET          (0x10)
+#define WDOG_CLEAR_REG_OFFSET               (0x14)
+
+#define WDOG_PARAMS_5_REG_OFFSET            (0xe4)
+#define WDOG_PARAMS_4_REG_OFFSET            (0xe8)
+#define WDOG_PARAMS_3_REG_OFFSET            (0xec)
+#define WDOG_PARAMS_2_REG_OFFSET            (0xf0)
+#define WDOG_PARAMS_1_REG_OFFSET            (0xf4)
+
+#define WDOG_COMP_VERSION_REG_OFFSET        (0xf8)
+#define WDOG_COMP_TYPE_REG_OFFSET           (0xfc)
+
+/*****************************************************************************/
+/* Register Bit Field Manipulation                                           */
+/*****************************************************************************/
+
+/* Kick value */
+#define WDOG_COUNTER_RESTART_KICK_VALUE	    (0x76)
+
+/* Control bits */
+#define WDOGCONTROLREGWDT_ENIDX		    (0)
+#define WDOGCONTROLREGRMODIDX		    (1)
+#define WDOGCONTROLREGRPLIDX		    (2)
+
+/* Masks */
+#define WDOGCONTROLREGWDT_ENMASK	    (1 << WDOGCONTROLREGWDT_ENIDX)
+#define WDOGCONTROLREGRMODMASK		    (1 << WDOGCONTROLREGRMODIDX)
+#define WDOGCONTROLREGRPLMASK		    (0x7 << WDOGCONTROLREGRPLIDX)
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif /* PC302_WDOG_H */
diff --git a/include/asm-arm/global_data.h b/include/asm-arm/global_data.h
index 7e2a53a..d7aea55 100644
--- a/include/asm-arm/global_data.h
+++ b/include/asm-arm/global_data.h
@@ -64,6 +64,10 @@ typedef	struct	global_data {
 #define	GD_FLG_POSTSTOP	0x00010		/* POST seqeunce aborted		*/
 #define	GD_FLG_LOGINIT	0x00020		/* Log Buffer has been initialized	*/
 
+#ifdef BUILD_FOR_THUMB
+#define DECLARE_GLOBAL_DATA_PTR     register volatile gd_t *gd asm ("r7")
+#else
 #define DECLARE_GLOBAL_DATA_PTR     register volatile gd_t *gd asm ("r8")
+#endif
 
 #endif /* __ASM_GBL_DATA_H */
diff --git a/include/asm-arm/mach-types.h b/include/asm-arm/mach-types.h
index b347857..7d3a360 100644
--- a/include/asm-arm/mach-types.h
+++ b/include/asm-arm/mach-types.h
@@ -1596,6 +1596,9 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_XDACOMET             1603
 #define MACH_TYPE_DEXFLEX2             1604
 #define MACH_TYPE_SFFSDR               1657
+#define MACH_TYPE_PC7302               2220
+#define MACH_TYPE_PC7802               2436
+#define MACH_TYPE_PC72052_I10_REVB     9997
 
 #ifdef CONFIG_ARCH_EBSA110
 # ifdef machine_arch_type
@@ -20605,6 +20608,42 @@ extern unsigned int __machine_arch_type;
 # define machine_is_dexflex2()	(0)
 #endif
 
+#ifdef CONFIG_MACH_PC7302
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PC7302
+# endif
+# define machine_is_pc7302()	(machine_arch_type == MACH_TYPE_PC7302)
+#else
+# define machine_is_pc7302()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PC7802
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PC7802
+# endif
+# define machine_is_pc7802()	(machine_arch_type == MACH_TYPE_PC7802)
+#else
+# define machine_is_pc7802()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PC72052_I10_REVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PC72052_I10_REVB
+# endif
+# define machine_is_pc72052_i10_revb()	(machine_arch_type == MACH_TYPE_PC72052_I10_REVB)
+#else
+# define machine_is_pc72052_i10_revb()	(0)
+#endif
+
 /*
  * These have not yet been registered
  */
diff --git a/include/configs/picochipcpe20x.h b/include/configs/picochipcpe20x.h
new file mode 100644
index 0000000..cd35b68
--- /dev/null
+++ b/include/configs/picochipcpe20x.h
@@ -0,0 +1,388 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file picochipcpe20x.h
+* \brief Configuration file for U-Boot on the CPE20x platform.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <asm/arch/pc20x.h>
+#include <asm/arch/sizes.h>
+#include <asm/arch/uart.h>
+
+/*-----------------------------------------------------------------------------
+ * Platform Identification Stuff
+ */
+#define PICOCHIP "picochip"
+
+/* Which hardware platform I am destined for */
+#define PICOCHIP_PLATFORM "cpe20x"
+
+/* Specific version of this build */
+#ifndef PICOCHIP_PLATFORM_VERSION
+#define PICOCHIP_PLATFORM_VERSION "3.2.4"
+#endif /* PICOCHIP_PLATFORM_VERSION */
+
+#define CONFIG_IDENT_STRING " "PICOCHIP"-"PICOCHIP_PLATFORM_VERSION \
+                            "-"PICOCHIP_PLATFORM
+
+/*-----------------------------------------------------------------------------
+ * High Level Configuration Options
+ */
+/* Running on picoChip PC20x Si */
+#define CONFIG_PICOCHIP_PC20X
+
+/* Running on a picoChip CPE20x platform */
+#define CONFIG_PICOCHIP_CPE20X
+
+/* Define this if you want to run with 2 Banks DDR Ram */
+//#define CONFIG_PC20X_2_DDR_RAM_BANKS
+
+/* Define this if running code in PC20X rtl simulation land */
+#undef CONFIG_PC20X_SIMULATION
+
+/* Bootable Flash memory has to live here (/ebi_decode0) */
+#define PC20X_BOOTABLE_FLASH_BASE   (0x20000000)
+
+/* Base address of the onchip SRAM */
+#define PC20X_ONCHIP_SRAM_BASE      (0x10000000)
+#define PC20X_ONCHIP_SRAM_SIZE      (SZ_128K)
+
+/* ARM Sub-system peripherals are clocked at 140 MHz Rev B Si */
+#define PC20X_AHB_CLOCK_FREQ        (140000000)
+
+/* Don't use Interrupts */
+#undef CONFIG_USE_IRQ
+
+/* Onchip timer runs at this frequency */
+#define CFG_HZ			    (PC20X_AHB_CLOCK_FREQ)
+#define CONFIG_SYS_HZ               (CFG_HZ)
+
+/* Display board info */
+#define CONFIG_DISPLAY_BOARDINFO    (1)
+
+/* Are we are going to be running from RAM ? */
+#ifdef CONFIG_RUN_FROM_RAM
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_SKIP_RELOCATE_UBOOT
+#endif /* CONFIG_RUN_FROM_RAM */
+
+/*-----------------------------------------------------------------------
+ * Stack Sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(SZ_256K)	    /* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(SZ_1K)	            /* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(SZ_1K)	            /* FIQ stack */
+#endif /* CONFIG_USE_IRQ */
+
+/*-----------------------------------------------------------------------------
+ * Size of malloc() pool
+ */
+#define CFG_MALLOC_LEN		(SZ_128K)
+
+ /* Size in bytes reserved for initial data */
+#define CFG_GBL_DATA_SIZE	(SZ_256)
+
+/*-----------------------------------------------------------------------------
+ * Linux Kernel Stuff
+ */
+/* Allow passing of command line args (bootargs) to the linux kernel*/
+#define CONFIG_CMDLINE_TAG
+
+/*-----------------------------------------------------------------------------
+ * DDR2 RAM Memory Map
+ */
+#ifndef CONFIG_PC20X_2_DDR_RAM_BANKS
+/* We want a 4 DDR Bank setup then */
+
+#define CONFIG_NR_DRAM_BANKS    4               /* We have 4 RAM banks */
+#define PHYS_SDRAM_1		0x00000000
+#define PHYS_SDRAM_1_SIZE	SZ_32M          /* 32 Mbytes */
+#define PHYS_SDRAM_2		0x04000000
+#define PHYS_SDRAM_2_SIZE	SZ_32M          /* 32 Mbytes */
+#define PHYS_SDRAM_3		0x08000000
+#define PHYS_SDRAM_3_SIZE	SZ_32M          /* 32 Mbytes */
+#define PHYS_SDRAM_4		0x0C000000
+#define PHYS_SDRAM_4_SIZE	SZ_32M          /* 32 Mbytes */
+
+#else   /* We want a 2 DDR Bank setup then */
+
+#define CONFIG_NR_DRAM_BANKS    2               /* We have 2 RAM banks */
+#define PHYS_SDRAM_1		0x00000000
+#define PHYS_SDRAM_1_SIZE	SZ_32M          /* 32 Mbytes */
+#define PHYS_SDRAM_2		0x04000000
+#define PHYS_SDRAM_2_SIZE	SZ_32M          /* 32 Mbytes */
+
+#endif /* CONFIG_PC20X_2_DDR_RAM_BANKS */
+
+/*-----------------------------------------------------------------------------
+ * Flash Memory Stuff
+ */
+#ifndef CONFIG_RUN_FROM_RAM
+
+/* Define Flash memory sector size
+  256 kbytes (2 off Flash devices with 128K sector size) */
+#define FLASH_SECTOR_SIZE	(SZ_256K)
+
+#define CFG_FLASH_CFI
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_EMPTY_INFO
+
+/* Provide a much improved performance when writing to the Flash */
+#define CFG_FLASH_USE_BUFFER_WRITE
+
+#define CFG_FLASH_BASE		(PC20X_BOOTABLE_FLASH_BASE)
+
+/* Maximum number of memory banks */
+#define CFG_MAX_FLASH_BANKS	(1)
+
+/* Maximum number of sectors per flash device */
+#define CFG_MAX_FLASH_SECT	(512)
+
+/* Timeouts for Flash Erasing and writing */
+#define CFG_FLASH_ERASE_TOUT	(2*CFG_HZ)
+#define CFG_FLASH_WRITE_TOUT	(2*CFG_HZ)
+
+/* U-Boot has its own Flash sector */
+#define CFG_MONITOR_LEN		(FLASH_SECTOR_SIZE)
+
+/* U-Boot lives in the bottom of the Flash memory */
+#define CFG_MONITOR_BASE        (CFG_FLASH_BASE)
+
+#else
+
+/* No flash memory in the system */
+#define CFG_NO_FLASH
+
+#endif /* CONFIG_RUN_FROM_RAM */
+
+/*-----------------------------------------------------------------------------
+ * U-Boot Environment Stuff
+ */
+#ifndef CONFIG_RUN_FROM_RAM
+
+/* Environment variables stored in Flash memory */
+#define CFG_ENV_IS_IN_FLASH     (1)
+#define CFG_ENV_ADDR            (PC20X_BOOTABLE_FLASH_BASE + FLASH_SECTOR_SIZE)
+
+/* One flash sector for environment info */
+#define CFG_ENV_SECT_SIZE       (FLASH_SECTOR_SIZE)
+
+/* Turn off wite protection for vendor parameters */
+#define CONFIG_ENV_OVERWRITE
+
+#else
+
+/* Just use the default environment in the image */
+#define CFG_ENV_IS_NOWHERE
+
+#endif /* CONFIG_RUN_FROM_RAM */
+
+/* Where ever the environment is, 64Kbytes should be sufficient */
+#define CFG_ENV_SIZE		(SZ_64K)
+
+/*-----------------------------------------------------------------------------
+ * Timer Stuff
+ */
+#define CFG_TIMERBASE           (PC20X_TIMER_BASE)
+
+/*-----------------------------------------------------------------------------
+ * Ethernet Stuff
+ */
+#define CFG_DW_EMAC
+#define CONFIG_PHY_ADDR         (0)
+#define CONFIG_NET_MULTI
+
+/*-----------------------------------------------------------------------------
+ * Serial Port Stuff
+ */
+#define CFG_DW_APB_UART
+
+/* Baud rate generators clock with a 3.6864 MHz clock */
+#define CONFIG_DW_APB_UART_CLOCK    (3686400)
+
+/* Console on Uart #0 */
+#define CONFIG_CONS_INDEX	    (1)
+#define CFG_BAUDRATE_TABLE	    { 9600, 19200, 38400, 57600, 115200, 230400 }
+
+/*-----------------------------------------------------------------------------
+ * U-Boot Memory Test (mtest command) Stuff
+ */
+/* Default start address for memory test */
+#define CFG_MEMTEST_START	(PC20X_ONCHIP_SRAM_BASE)
+
+/* Default end address for memory test */
+#define CFG_MEMTEST_END		(CFG_MEMTEST_START + PC20X_ONCHIP_SRAM_SIZE - 1)
+
+/* Define this to use the super duper memory test */
+#define CFG_ALT_MEMTEST
+
+/* Use uart #1 scratch pad reg */
+#define CFG_MEMTEST_SCRATCH     (PC20X_UART1_BASE + UartScratchRegOffset)
+
+/*-----------------------------------------------------------------------------
+ * U-Boot Supported Commands
+ */
+#include "config_cmd_default.h"
+
+#define CONFIG_CMD_PING
+#undef CONFIG_CMD_AUTOSCRIPT
+#undef CONFIG_CMD_BOOTD
+#undef CONFIG_CMD_CONSOLE
+#undef CONFIG_CMD_ECHO
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_ITEST
+#undef CONFIG_CMD_LOADB
+#undef CONFIG_CMD_LOADS
+#undef CONFIG_CMD_MISC
+#undef CONFIG_CMD_NFS
+#undef CONFIG_CMD_XIMG
+
+#ifdef CFG_NO_FLASH
+#undef CONFIG_CMD_FLASH
+#undef CONFIG_CMD_ENV
+#endif /* CFG_NO_FLASH */
+
+/* Use the HUSH parser */
+#define CFG_HUSH_PARSER
+
+#ifdef  CFG_HUSH_PARSER
+/* This defines the secondary prompt string */
+#define CFG_PROMPT_HUSH_PS2 "> "
+#endif /* CFG_HUSH_PARSER */
+
+/* Enable command line editing and history */
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------------
+ * Miscellaneous Configurable Options...
+ */
+/* Use 'long' help messages */
+#define CFG_LONGHELP
+
+/* Monitor Command Prompt */
+#define CFG_PROMPT	"=> "
+
+/* Console I/O Buffer Size*/
+#define CFG_CBSIZE	(SZ_1K)
+
+/* Print buffer size */
+#define CFG_PBSIZE	(CFG_CBSIZE+sizeof(CFG_PROMPT)+16)
+
+/* Maximum number of command args */
+#define CFG_MAXARGS	(16)
+
+/* Boot Argument Buffer Size*/
+#define CFG_BARGSIZE	(CFG_CBSIZE)
+
+/* everything, incl board info, in Hz */
+#undef	CFG_CLKS_IN_HZ
+
+/* Default load address for bootm and friends */
+#define CFG_LOAD_ADDR	(0x20080000)
+
+/*-----------------------------------------------------------------------
+ * Environment Configuration
+ */
+
+/* Note: This MAC address is based on the real picoChip OUI, it
+ * will need to be modified (as per the picoChip MAC address creation spec)
+ * for each and every board.
+ */
+
+#if defined(CFG_DW_EMAC)
+
+/* picoChip OUI, will need noodling by users */
+#define CONFIG_ETHADDR          00:15:E1:00:00:00
+
+/* picoChip default for testing, will need noodling by users */
+#define CONFIG_IPADDR           172.17.9.248
+
+#define CONFIG_HOSTNAME	        picocpe
+#define CONFIG_ROOTPATH	        /var/nfscpe20x
+#define CONFIG_BOOTFILE	        uImage-cpe20x
+
+#define CONFIG_SERVERIP         172.17.7.100
+#define CONFIG_GATEWAYIP        172.17.0.1
+#define CONFIG_NETMASK          255.255.0.0
+
+#endif
+
+/* Second flash sector... */
+#define CFG_FLASH_KERNEL_BASE   0x20080000
+
+/* Default location for tftp and bootm */
+#define CONFIG_LOADADDR         0x00200000
+
+/* Time in seconds before autoboot, -1 disables auto-boot */
+#define CONFIG_BOOTDELAY        5
+
+/* The boot command will set bootargs */
+#undef  CONFIG_BOOTARGS
+
+/* Default console baud rate */
+#define CONFIG_BAUDRATE	        115200
+
+#ifndef CONFIG_PC20X_2_DDR_RAM_BANKS
+/* We want a 4 DDR Bank setup then */
+
+/* Unless specified here we'll just rely on the kernel default */
+#define OTHERBOOTARGS
+
+#else   /* We want a 2 DDR Bank setup then */
+
+/* We need to 'over ride' the kernel default */
+#define OTHERBOOTARGS pc20x_mem=32M@PHYS_SDRAM_1 pc20x_mem=32M@PHYS_SDRAM_2
+
+#endif /* CONFIG_PC20X_2_DDR_RAM_BANKS */
+
+#define	CONFIG_EXTRA_ENV_SETTINGS				        \
+   "othbootargs=" MK_STR (OTHERBOOTARGS) "\0"                           \
+   "netdev=eth0\0"                                                      \
+   "consoledev=ttyS0\0"                                                 \
+   "kernel_flash_addr=" MK_STR(CFG_FLASH_KERNEL_BASE) "\0"		\
+   "flash_jffs2=run jffs2_args; bootm $kernel_flash_addr\0"		\
+   "fixed_nfs=run nfs_args; tftp; bootm\0"				\
+   "jffs2_args=setenv bootargs root=/dev/mtdblock1 rw rootfstype=jffs2 " \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "    \
+   "console=$consoledev,$baudrate $othbootargs;\0"                      \
+   "nfs_args=setenv bootargs root=/dev/nfs rw nfsroot=$serverip:$rootpath " \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "    \
+   "console=$consoledev,$baudrate $othbootargs;"                        \
+
+#define CONFIG_NFSBOOTCOMMAND	                                        \
+   "setenv bootargs root=/dev/nfs rw "                                  \
+   "nfsroot=$serverip:$rootpath "                                       \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "    \
+   "console=$consoledev,$baudrate $othbootargs;"                        \
+   "bootm $kernel_flash_addr"
+
+#define CONFIG_RAMBOOTCOMMAND                                           \
+   "setenv bootargs root=/dev/ram rw "                                  \
+   "console=$consoledev,$baudrate $othbootargs;"                        \
+   "tftp $ramdiskaddr $ramdiskfile;"                                    \
+   "tftp $loadaddr $bootfile;"                                          \
+   "bootm $loadaddr $ramdiskaddr"
+
+/* Define as "run flash_jffs2" for on-board boot, or "run fixed_nfs" for
+ * standard NFS with fixed IP.  Or use NFSBOOTCOMMAND etc as above.
+ */
+#define CONFIG_BOOTCOMMAND  "run flash_jffs2"
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/picochiphdp203.h b/include/configs/picochiphdp203.h
new file mode 100644
index 0000000..676dbe1
--- /dev/null
+++ b/include/configs/picochiphdp203.h
@@ -0,0 +1,540 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Configuration for picoChip HDP203 target (www.picochip.com)
+ *     by david.warman@zetetica.co.uk
+ * 
+ * Copyright 2005 Zetetica Ltd.
+ * 
+ * parts derived from MPC8560 ADS configuration,
+ *     Copyright 2004 Freescale Semiconductor.
+ *     (C) Copyright 2002,2003 Motorola,Inc.
+ *     Xianghua Xiao <X.Xiao@motorola.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * picoChip HDP203 board.  If you have one of these, you'll know what it is.
+ *
+ * Make sure you change the MAC address and other network params first,
+ * search for CONFIG_ETHADDR, CONFIG_SERVERIP, etc in this file.
+ *
+ * Revision April 13, 2007 - stuartr
+ *  	CFG_BR2_PRELIM, CFG_OR2_PRELIM, CFG_BR3_PRELIM and CFG_OR3_PRELIM
+ *	register settings revised to use UPMA instead of GPCM local bus accesses 
+ * 
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*-----------------------------------------------------------------------------
+ * Platform Identification Stuff
+ */
+#define PICOCHIP "picochip"
+
+/* Which hardware platform I am destined for */
+#define PICOCHIP_PLATFORM "hdp203"
+
+/* Specific version of this build */
+#ifndef PICOCHIP_PLATFORM_VERSION
+#define PICOCHIP_PLATFORM_VERSION "3.2.4"
+#endif /* PICOCHIP_PLATFORM_VERSION */
+
+#define CONFIG_IDENT_STRING " "PICOCHIP"-"PICOCHIP_PLATFORM_VERSION \
+                            "-"PICOCHIP_PLATFORM
+
+/*-----------------------------------------------------------------------------
+ * High Level Configuration Options
+ */
+#define CONFIG_BOOKE		1	/* BOOKE */
+#define CONFIG_E500		1	/* BOOKE e500 family */
+#define CONFIG_MPC85xx		1	/* MPC8540/MPC8560 */
+#define CONFIG_CPM2		1	/* has CPM2 */
+#define CONFIG_PICOHDP	    	1	/* Board specific symbol */
+#define CONFIG_PCI                      /* Include PCI support */
+#define CONFIG_TSEC_ENET 		/* tsec ethernet support */
+#undef  CONFIG_ETHER_ON_FCC             /* cpm FCC ethernet support */
+
+#define CONFIG_SPD_EEPROM		/* Use SPD EEPROM for DDR setup*/
+#define CONFIG_DDR_DLL			/* possible DLL fix needed */
+#define CONFIG_DDR_2T_TIMING		/* Sets the 2T timing bit */
+//#define CONFIG_DDR_ECC			/* only for ECC DDR module */
+#define CONFIG_MEM_INIT_VALUE		0xDeadBeef
+
+#define CONFIG_FSL_LAW          1       /* Use common FSL init code */
+
+/* sysclk for MPC85xx -- 66.67MHz on this target */
+#ifndef CONFIG_SYS_CLK_FREQ
+#define CONFIG_SYS_CLK_FREQ	66670000
+#endif
+
+/* These can be toggled for performance analysis, otherwise use default */
+#define CONFIG_L2_CACHE			/* toggle L2 cache */
+#define CONFIG_BTB			/* toggle branch predition */
+#define CONFIG_ADDR_STREAMING		/* toggle addr streaming */
+
+/* Not used at present, but may need it later */
+/* Used to call the platform specific board_early_init_f() */
+#define CONFIG_BOARD_EARLY_INIT_F	1	
+
+#define CFG_INIT_DBCR DBCR_IDM		/* Enable Debug Exceptions */
+
+#undef	CFG_DRAM_TEST			/* memory test, takes time */
+#define CFG_MEMTEST_START	0x00200000	/* memtest region */
+#define CFG_MEMTEST_END		0x00400000
+
+/* Base addresses -- Note these are effective addresses where the
+   actual resources get mapped (not physical addresses) */
+#define CFG_CCSRBAR_DEFAULT 	0xFF700000	/* CCSRBAR Default */
+#define CFG_CCSRBAR		0x80000000	/* relocated CCSRBAR */
+#define CFG_CCSRBAR_PHYS	CFG_CCSRBAR	/* physical addr of CCSRBAR */ 
+#define CFG_IMMR		CFG_CCSRBAR	/* PQII uses CFG_IMMR */
+
+#define CFG_CPLD_MEM_BASE	0xE0000000
+#define CFG_PREG_MEM_BASE	0xD0000000
+#define CFG_PFIFO_MEM_BASE	0xC0000000
+#define CFG_DCARD_MEM_BASE	0xB0000000
+
+/* DDR Setup */
+#define CFG_DDR_SDRAM_BASE	0x00000000	/* DDR is system memory*/
+#define CFG_SDRAM_BASE		CFG_DDR_SDRAM_BASE
+
+#if defined(CONFIG_SPD_EEPROM)
+    /* Determine DDR configuration from I2C interface. */
+    #define SPD_EEPROM_ADDRESS	0x50		/* DDR DIMM */
+#else
+    /* Manually set up DDR parameters */
+    #define CFG_SDRAM_SIZE	256		/* DDR is 256MBytes */
+    #define CFG_DDR_CS0_BNDS	0x0000000F	/* 0-256MB */
+    #define CFG_DDR_CS0_CONFIG	0x80000102
+    #define CFG_DDR_TIMING_1	0x36332321	/* See notes */
+    #define CFG_DDR_TIMING_2	0x00000C00	/* See notes */
+    #define CFG_DDR_CONTROL	0xC2008000	/* unbuffered,no DYN_PWR */
+    #define CFG_DDR_MODE	0x00000022	/* SDMODE=63  */
+    #define CFG_DDR_INTERVAL	0x04110100	/* See notes */
+#endif /* CONFIG_SPD_EEPROM */
+
+#undef CONFIG_WATCHDOG			        /* watchdog disabled */
+
+/*-----------------------------------------------------------------------------
+ * Flash Memory Stuff
+ */
+#ifdef CFG_PICOHDP_FLASH32M
+#define CFG_BR0_PRELIM		0xFE001801	/* port size 32bit */
+#define CFG_OR0_PRELIM		0xFE000E62	/* 32MB Flash */
+#define CFG_FLASH_BASE		0xFE000000	/* start of FLASH 32M */
+#else
+/* Note: in 128M mode we rely on the upper part of the flash not
+ * moving when we change the mapping to allow us access to the entire
+ * device.  
+ */
+#define CFG_BR0_PRELIM		0xF8001801	/* port size 32bit */
+#define CFG_OR0_PRELIM		0xF8000E62	/* 128MB Flash */
+#define CFG_FLASH_BASE		0xF8000000	/* start of FLASH 128M */
+#endif /* CFG_PICOHDP_FLASH32M */
+
+/* Maximum number of memory banks */
+#define CFG_MAX_FLASH_BANKS	1
+
+/* Maximum number of sectors per flash device */
+#define CFG_MAX_FLASH_SECT	512
+#undef	CFG_FLASH_CHECKSUM
+#define CFG_FLASH_ERASE_TOUT	40000	/* Flash Erase Timeout (ms) */
+#define CFG_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#define CFG_MONITOR_BASE    	TEXT_BASE	/* start of monitor */
+#define CFG_FLASH_KERNEL_BASE	0xFFE00000	/* start of kernel */
+
+#if (CFG_MONITOR_BASE < CFG_FLASH_BASE)
+#define CFG_RAMBOOT
+#else
+#undef  CFG_RAMBOOT
+/* If not doing a ram boot, set up for Flash */
+#define CFG_FLASH_CFI
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_EMPTY_INFO
+#endif
+
+/* Provide a much improved performance when writing to the Flash */
+#define CFG_FLASH_USE_BUFFER_WRITE
+
+/*-----------------------------------------------------------------------------
+ * Local Bus Definitions
+ */
+/*
+ * CS0 - Flash (above)
+ * CS1 - CPLD (LEDs, etc)
+ * CS2 - picoArray GPR regs
+ * CS3 - picoArray FIFOs
+ * CS4 - picoArray AHB
+ *
+ * SCS1 - SDRAM Bank 1
+ * SCS0 - SDRAM Bank 0
+ */
+
+/* These are actually _final_ mappings, but it avoids a patch to keep the
+ * symbol names the same.
+ */
+
+/* CPLD mapping on CS1 */
+#define CFG_BR1_PRELIM	0xE0001001
+#define CFG_OR1_PRELIM	0xFFFF8010
+
+/* PicoChip Registers */
+#define CFG_BR2_PRELIM	0xD0001881         /* Use UPMA for GPR register accesses, base addr 0xD0000000, 32bit port, 
+       					      error check disabled, r/w accesses, not atomic, bank is valid */
+#define CFG_OR2_PRELIM	0xFFFF0010         /* 64k allocated to pA registers, BCTLD=0, BI=1 bursts inhibited  							   
+					      TRLX=0 (normal timing), EHTR=0 (no extended hold time)
+					      EAD=0 (no additional external ALE cycle) */
+					   /* NOTE - Burst accesses inhibited (as per HDP102) */
+
+/* PicoChip FIFOs */
+#define CFG_BR3_PRELIM	0xC0001881         /* Use UPMA for FIFO accesses, base addr 0xC0000000 */
+#define CFG_OR3_PRELIM	0xFFF00010         /* 1MB allocated to pA Fifos (256k per pA). BCTLD=0, BI=1 bursts inhibited    
+ 					      TRLX=0 (normal timing), EHTR=0 (no extended hold time)
+					      EAD=0 (no additional external ALE cycle) */
+					   /* NOTE - Burst accesses inhibited (as per HDP102) */
+
+/* PC203 AHB */
+#define CFG_BR4_PRELIM	0xB0001801         /* These settings not verified, AHB accesses untested on HDP203 */
+#define CFG_OR4_PRELIM	0xFFFF8010         /* Ditto */
+
+/*-----------------------------------------------------------------------------
+ * Local Bus Configuration
+ */
+#define CFG_LBC_LCRR		0x00030004    /* LB clock ratio reg */
+#define CFG_LBC_LBCR		0x00000000    /* LB config reg */
+#define CFG_LBC_LSRT		0x20000000    /* LB sdram refresh timer */
+#define CFG_LBC_MRTPR		0x20000000    /* LB refresh timer prescal*/
+
+#define CONFIG_L1_INIT_RAM
+#define CFG_INIT_RAM_LOCK 	1
+#define CFG_INIT_RAM_ADDR	0xA0000000	/* Initial RAM address */
+#define CFG_INIT_RAM_END    	0x4000	    	/* End of used area in RAM */
+
+#define CFG_GBL_DATA_SIZE  	128		/* num bytes initial data */
+#define CFG_GBL_DATA_OFFSET	(CFG_INIT_RAM_END - CFG_GBL_DATA_SIZE)
+#define CFG_INIT_SP_OFFSET	CFG_GBL_DATA_OFFSET
+
+#define CFG_MONITOR_LEN	    	(384 * 1024)    /* Reserve 384 kB for Mon */
+#define CFG_MALLOC_LEN	    	(128 * 1024)    /* Reserved for malloc */
+
+/*-----------------------------------------------------------------------------
+ * Serial Port
+ */
+#define CONFIG_CONS_ON_SCC	/* define if console on SCC */
+#undef  CONFIG_CONS_NONE	/* define if console on something else */
+#define CONFIG_CONS_INDEX       3  /* which serial channel for console */
+
+#define CONFIG_BAUDRATE	 	115200
+
+#define CFG_BAUDRATE_TABLE  \
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400,115200}
+
+/*-----------------------------------------------------------------------------
+ * I2C
+ */ 
+#define CONFIG_HARD_I2C                 /* I2C with hardware support*/
+#define CONFIG_I2C_ON_CPM	        /* Main I2C is on CPM interface */
+#undef  CONFIG_SOFT_I2C                 /* I2C bit-banged */
+#define CFG_I2C_SPEED           400000	/* I2C speed (Hz) */
+#define CFG_I2C_SLAVE           0x7F    /* I2C Slave address */
+#define CFG_I2C_NOPROBES        {0x50}	/* Don't probe these addrs */
+#define CFG_I2C_OFFSET          0x3000
+
+/*-----------------------------------------------------------------------------
+ * General PCI
+ * Addresses are mapped 1-1
+ */  
+#define CFG_PCI1_MEM_BASE	0x40000000
+#define CFG_PCI1_MEM_PHYS	CFG_PCI1_MEM_BASE
+#define CFG_PCI1_MEM_SIZE	0x10000000	/* 256M */
+
+#define CFG_PCI1_IO_BASE	0x48000000
+#define CFG_PCI1_IO_PHYS	CFG_PCI1_IO_BASE
+#define CFG_PCI1_IO_SIZE	0x10000000	/* 256M */
+
+#if defined(CONFIG_PCI)
+
+#define CONFIG_NET_MULTI
+#define CONFIG_PCI_PNP	               	/* do pci plug-and-play */
+
+#undef CONFIG_EEPRO100
+#undef CONFIG_TULIP
+
+#undef CONFIG_PCI_SCAN_SHOW		/* show pci devices on startup */
+#define CFG_PCI_SUBSYS_VENDORID 0x1057  /* Motorola */
+
+#endif	/* CONFIG_PCI */
+
+/*-----------------------------------------------------------------------------
+ * Ethernet
+ */
+#if defined(CONFIG_TSEC_ENET)
+
+#ifndef CONFIG_NET_MULTI
+#define CONFIG_NET_MULTI 	1
+#endif
+
+#define CONFIG_MII		1	/* MII PHY management */
+#define CONFIG_TSEC1	        1
+#define CONFIG_TSEC1_NAME	"TSEC0"
+#define CONFIG_TSEC2	        1
+#define CONFIG_TSEC2_NAME	"TSEC1"
+#undef CONFIG_MPC85XX_FEC
+#define TSEC1_PHY_ADDR		0
+#define TSEC2_PHY_ADDR		1
+#define TSEC1_PHYIDX		0
+#define TSEC2_PHYIDX		0
+#define TSEC1_FLAGS             TSEC_GIGABIT
+#define TSEC2_FLAGS             TSEC_GIGABIT
+
+/* Options are: TSEC[0-1] */
+#define CONFIG_ETHPRIME		"TSEC0"
+
+#elif defined(CONFIG_ETHER_ON_FCC)	/* CPM FCC Ethernet */
+
+#define CONFIG_ETHER_ON_FCC	        /* define if ether on FCC   */
+#undef  CONFIG_ETHER_NONE	        /* define if ether on something else */
+#define CONFIG_ETHER_INDEX      2       /* which channel for ether */
+
+#if (CONFIG_ETHER_INDEX == 2)
+  /*
+   * - Rx-CLK is CLK13
+   * - Tx-CLK is CLK14
+   * - Select bus for bd/buffers
+   * - Full duplex
+   */
+  #define CFG_CMXFCR_MASK       (CMXFCR_FC2 | CMXFCR_RF2CS_MSK | CMXFCR_TF2CS_MSK)
+  #define CFG_CMXFCR_VALUE      (CMXFCR_RF2CS_CLK13 | CMXFCR_TF2CS_CLK14)
+  #define CFG_CPMFCR_RAMTYPE    0
+  #define CFG_FCC_PSMR          (FCC_PSMR_FDE)
+  #define FETH2_RST		0x01
+#elif (CONFIG_ETHER_INDEX == 3)
+  /* need more definitions here for FE3 */
+  #define FETH3_RST		0x80
+#endif  				/* CONFIG_ETHER_INDEX */
+
+#define CONFIG_MII			/* MII PHY management */
+#define CONFIG_BITBANGMII		/* bit-bang MII PHY management */
+
+/*
+ * GPIO pins used for bit-banged MII communications (not used at present)
+ */
+#define MDIO_PORT	2		/* Port C */
+#define MDIO_ACTIVE	(iop->pdir |=  0x00400000)
+#define MDIO_TRISTATE	(iop->pdir &= ~0x00400000)
+#define MDIO_READ	((iop->pdat &  0x00400000) != 0)
+
+#define MDIO(bit)	if(bit) iop->pdat |=  0x00400000; \
+			else	iop->pdat &= ~0x00400000
+
+#define MDC(bit)	if(bit) iop->pdat |=  0x00200000; \
+			else	iop->pdat &= ~0x00200000
+
+#define MIIDELAY	udelay(1)
+
+#endif
+
+/*-----------------------------------------------------------------------
+ * Environment Configuration
+ */
+ 
+/* Turn off wite protection for vendor parameters */
+#define CONFIG_ENV_OVERWRITE   
+ 
+#ifndef CFG_RAMBOOT
+  #define CFG_ENV_IS_IN_FLASH	1
+  #define CFG_ENV_ADDR		0xFFF80000  /* First 256K of boot space is env */
+  #define CFG_ENV_SECT_SIZE	0x40000	    /* 256K(one sector) for env */
+  #define CFG_ENV_SIZE		0x10000     /* But 64K is sufficient */
+  /* TEXT_BASE is at 0xFFFC0000 = ENV_ADDR + ENV_SECT_SIZE */
+#else
+  #define CFG_NO_FLASH		1	    /* Flash is not usable now */
+  #define CFG_ENV_IS_NOWHERE	1	    /* Store ENV in memory only */
+  #define CFG_ENV_ADDR		(CFG_MONITOR_BASE - 0x2000)
+  #define CFG_ENV_SIZE		0x2000
+#endif /* CFG_RAMBOOT */
+
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download */
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change */
+
+/*-----------------------------------------------------------------------------
+ * U-Boot Supported Commands
+ */
+#include "config_cmd_default.h"
+
+#define CONFIG_CMD_PING
+#undef CONFIG_CMD_AUTOSCRIPT
+#undef CONFIG_CMD_BOOTD
+#undef CONFIG_CMD_CONSOLE
+#undef CONFIG_CMD_ECHO
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_ITEST
+#undef CONFIG_CMD_LOADB
+#undef CONFIG_CMD_LOADS
+#undef CONFIG_CMD_MISC
+#undef CONFIG_CMD_NFS
+#undef CONFIG_CMD_XIMG
+
+#ifdef CFG_NO_FLASH
+#undef CONFIG_CMD_FLASH
+#undef CONFIG_CMD_ENV
+#endif /* CFG_NO_FLASH */
+
+#define CONFIG_CMD_PCI
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_DHCP
+
+/* Use the HUSH parser */
+#define CFG_HUSH_PARSER
+
+#ifdef  CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "> "
+#endif
+
+/*-----------------------------------------------------------------------------
+ * Miscellaneous Configurable Options...
+ */
+ 
+/* Use 'long' help messages */
+#define CFG_LONGHELP
+
+/* default load address */
+#define CFG_LOAD_ADDR	0x1000000
+
+/* Monitor Command Prompt */
+#define CFG_PROMPT	"=> "
+
+/* Console I/O Buffer Size*/
+#define CFG_CBSIZE	1024
+
+/* Print buffer size */
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)
+
+/* Maximum number of command args */
+#define CFG_MAXARGS	16
+
+/* Boot Argument Buffer Size*/
+#define CFG_BARGSIZE	CFG_CBSIZE
+
+/* decrementer freq: 1ms ticks */
+#define CFG_HZ		1000
+
+/* clocks NOT passsed to Linux in MHz */
+#undef CONFIG_CLOCKS_IN_MHZ
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 8 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CFG_BOOTMAPSZ	(8 << 20)	/* Initial Memory map for Linux*/
+
+/* Cache Configuration */
+#define CFG_DCACHE_SIZE		32768
+#define CFG_CACHELINE_SIZE	32
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CFG_CACHELINE_SHIFT	5	/*log base 2 of the above value*/
+#endif
+
+/*
+ * Internal Definitions
+ *
+ * Boot Flags
+ */
+#define BOOTFLAG_COLD	0x01		/* Normal Power-On: Boot from FLASH */
+#define BOOTFLAG_WARM	0x02		/* Software reboot */
+
+/*
+ * Environment Configuration
+ */
+
+/* Preliminary settings - may need changing, particularly for different
+ * NFS arrangements...
+ */
+
+/* These MAC addresses are based on the real picoChip OUI, they 
+ * will need to be modified (as per the MAC address creation spec) for
+ * each and every hdp board.
+ */
+
+#if defined(CONFIG_TSEC_ENET) || defined(CONFIG_ETHER_ON_FCC)
+
+#define CONFIG_ETHADDR   00:15:E1:00:00:00
+#define CONFIG_HAS_ETH1
+#define CONFIG_ETH1ADDR  00:15:E1:00:00:01
+/* There are only ever two Ethernets on this target */
+
+#define CONFIG_IPADDR    172.17.10.248
+
+#define CONFIG_HOSTNAME	 picohdp
+#define CONFIG_ROOTPATH	 /var/nfshdp203
+#define CONFIG_BOOTFILE	 uImage-hdp203
+
+#define CONFIG_SERVERIP  172.17.7.100
+#define CONFIG_GATEWAYIP 172.17.0.1
+#define CONFIG_NETMASK   255.255.0.0
+
+#endif
+
+#define CONFIG_LOADADDR  200000	/* default location for tftp and bootm */
+
+#define CONFIG_BOOTDELAY 5	/* -1 disables auto-boot */
+#undef  CONFIG_BOOTARGS		/* the boot command will set bootargs */
+
+#define CONFIG_BAUDRATE	115200
+
+#define	CONFIG_EXTRA_ENV_SETTINGS				        \
+   "netdev=eth0\0"                                                      \
+   "consoledev=ttyCPM0\0"                                               \
+   "kernel_flash_addr=" MK_STR(CFG_FLASH_KERNEL_BASE) "\0"		\
+   "flash_jffs2=run jffs2_args; bootm $kernel_flash_addr\0"		\
+   "fixed_nfs=run nfs_args; tftp; bootm\0"				\
+   "jffs2_args=setenv bootargs root=/dev/mtdblock1 rw rootfstype=jffs2 " \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "    \
+   "console=$consoledev,$baudrate $othbootargs;\0"                      \
+   "nfs_args=setenv bootargs root=/dev/nfs rw nfsroot=$serverip:$rootpath " \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "    \
+   "console=$consoledev,$baudrate $othbootargs;"                        \
+
+#define CONFIG_NFSBOOTCOMMAND	                                        \
+   "setenv bootargs root=/dev/nfs rw "                                  \
+   "nfsroot=$serverip:$rootpath "                                       \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "    \
+   "console=$consoledev,$baudrate $othbootargs;"                        \
+   "bootm $kernel_flash_addr"
+
+#define CONFIG_RAMBOOTCOMMAND \
+   "setenv bootargs root=/dev/ram rw "                                  \
+   "console=$consoledev,$baudrate $othbootargs;"                        \
+   "tftp $ramdiskaddr $ramdiskfile;"                                    \
+   "tftp $loadaddr $bootfile;"                                          \
+   "bootm $loadaddr $ramdiskaddr"
+
+/* Define as "run flash_jffs2" for on-board boot, or "run fixed_nfs" for
+ * standard NFS with fixed IP.  Or use NFSBOOTCOMMAND etc as above.
+ */
+#define CONFIG_BOOTCOMMAND  "run flash_jffs2"
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/picochippc7302.h b/include/configs/picochippc7302.h
new file mode 100644
index 0000000..06031ef
--- /dev/null
+++ b/include/configs/picochippc7302.h
@@ -0,0 +1,546 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file picochippc7302.h
+* \brief Configuration file for U-Boot on the PC7302 platform.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <asm/arch/pc302.h>
+#include <asm/arch/sizes.h>
+#include <asm/arch/uart.h>
+
+/*-----------------------------------------------------------------------------
+ * Platform Identification Stuff
+ */
+#define PICOCHIP "picochip"
+
+/* Which hardware platform I am destined for */
+#define PICOCHIP_PLATFORM "pc7302"
+
+/* Specific version of this build */
+#ifndef PICOCHIP_PLATFORM_VERSION
+#define PICOCHIP_PLATFORM_VERSION "3.2.4"
+#endif /* PICOCHIP_PLATFORM_VERSION */
+
+#define CONFIG_IDENT_STRING " "PICOCHIP"-"PICOCHIP_PLATFORM_VERSION \
+                            "-"PICOCHIP_PLATFORM
+
+/*-----------------------------------------------------------------------------
+ * High Level Configuration Options
+ */
+/* Running on picoChip PC302 Silicon */
+#define CONFIG_PICOCHIP_PC302
+
+/* Running on a picoChip PC7302 platform */
+#define CONFIG_PICOCHIP_PC7302
+
+/* Define this if running code in PC302 rtl simulation land */
+#undef CONFIG_PC302_SIMULATION
+
+/* Define to disable the verify after U-Boot has relocated from ROM to RAM */
+#undef CONFIG_SKIP_VERIFY_RELOCATE_UBOOT
+
+/* Bootable Flash memory has to live here (/ebi_decode0) */
+#define PC302_BOOTABLE_FLASH_BASE   (PC302_FLASH_BASE)
+
+/* Base address of the onchip SRAM */
+#define PC302_ONCHIP_SRAM_BASE      (PC302_SRAM_BASE)
+#define PC302_ONCHIP_SRAM_SIZE      (PC302_SRAM_SIZE)
+
+/* ARM Sub-system peripherals are clocked at 200MHz */
+#define PC302_AHB_CLOCK_FREQ        (200000000)
+
+/* Don't use Interrupts */
+#undef CONFIG_USE_IRQ
+
+/* Onchip timer runs at this frequency */
+#define CFG_HZ			    (PC302_AHB_CLOCK_FREQ)
+#define CONFIG_SYS_HZ               (CFG_HZ)
+
+/* Display board info */
+#define CONFIG_DISPLAY_BOARDINFO    (1)
+
+/* Are we are going to be running from RAM ? */
+#ifdef CONFIG_RUN_FROM_RAM
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_SKIP_RELOCATE_UBOOT
+#endif /* CONFIG_RUN_FROM_RAM */
+
+/*-----------------------------------------------------------------------
+ * Stack Sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#if defined(CONFIG_PC302_SIMULATION)
+/* We are running in RTL simulation land, reduce the stack sizes
+   so we do not have any memory model problems */
+#define CONFIG_STACKSIZE	(SZ_1K)             /* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(SZ_128)            /* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(SZ_128)    	    /* FIQ stack */
+#endif /* CONFIG_USE_IRQ */
+#else
+/* We are running on a real hardware platform, therefore set the stack
+   sizes to their 'correct' values */
+#define CONFIG_STACKSIZE	(SZ_256K) 	    /* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(SZ_4K)             /* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(SZ_4K)    	    /* FIQ stack */
+#endif /* CONFIG_USE_IRQ */
+
+#endif  /* CONFIG_PC302_SIMULATION */
+
+/*-----------------------------------------------------------------------------
+ * Size of malloc() pool
+ */
+#if defined(CONFIG_PC302_SIMULATION)
+/* We are running in RTL simulation land */
+
+/* Memory size for use by malloc () */
+#define CFG_MALLOC_LEN		(SZ_4K)
+#else
+/* We are running on a real hardware platform */
+
+/* Memory size for use by malloc () */
+#define CFG_MALLOC_LEN		(SZ_256K)
+#endif  /* CONFIG_PC302_SIMULATION */
+
+/* Size in bytes reserved for initial data */
+#define CFG_GBL_DATA_SIZE	(SZ_256)
+
+/*-----------------------------------------------------------------------------
+ * Linux Kernel Stuff
+ */
+/* Allow passing of command line args (bootargs) to the linux kernel*/
+#define CONFIG_CMDLINE_TAG          1
+#define CONFIG_SETUP_MEMORY_TAGS    1
+
+/*-----------------------------------------------------------------------------
+ * DDR2 RAM Memory Map
+ */
+/* We have 1 linear addressable RAM bank */
+#define CONFIG_NR_DRAM_BANKS    (1)
+#define PHYS_SDRAM_1		(PC302_DDRBANK_BASE)
+#define PHYS_SDRAM_1_SIZE	(SZ_128M)
+
+/*-----------------------------------------------------------------------------
+ * Flash Memory Stuff
+ */
+#ifndef CONFIG_RUN_FROM_RAM
+
+/* Define Flash memory sector size */
+#define FLASH_SECTOR_SIZE	(SZ_128K)
+
+#define CFG_FLASH_CFI
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_EMPTY_INFO
+
+/* Provide a much improved performance when writing to the Flash */
+#define CFG_FLASH_USE_BUFFER_WRITE
+
+#define CFG_FLASH_BASE		(PC302_BOOTABLE_FLASH_BASE)
+
+/* Maximum number of memory banks (devices) */
+#define CFG_MAX_FLASH_BANKS	(1)
+
+/* Maximum number of sectors per flash device */
+#define CFG_MAX_FLASH_SECT	(1024)
+
+/* Timeouts for Flash Erasing and writing */
+#define CFG_FLASH_ERASE_TOUT	(2*CFG_HZ)
+#define CFG_FLASH_WRITE_TOUT	(2*CFG_HZ)
+
+/* U-Boot has its own Flash sector */
+#define CFG_MONITOR_LEN		(FLASH_SECTOR_SIZE)
+
+/* U-Boot lives in the bottom of the Flash memory */
+#define CFG_MONITOR_BASE        (CFG_FLASH_BASE)
+
+#else
+
+/* No flash memory in the system */
+#define CFG_NO_FLASH
+
+#endif /* CONFIG_RUN_FROM_RAM */
+
+/*-----------------------------------------------------------------------------
+ * NAND Flash Memory Stuff
+ */
+#define CONFIG_SYS_NAND_BASE        PC302_EBI_CS2_BASE
+#define CONFIG_SYS_NAND_MAX_CHIPS   1
+#define CONFIG_SYS_MAX_NAND_DEVICE  1
+
+#define NAND_FLASH_SECTOR_SIZE      (SZ_128K)
+
+/* Pin definitions for NAND Flash control signals are
+ * defined in file board/picochip/pc7302/mt29f2g08aadwp.c
+ */
+
+/* Include support / commands for NAND Flash
+ *
+ * Note: Please read the comments in file
+ *       board/picochip/pc7302/mt29f2g08aadwp.c about gpio pins used
+ *       and PC302 booting modes before defining CONFIG_CMD_NAND
+ */
+// #define CONFIG_CMD_NAND
+
+/*-----------------------------------------------------------------------------
+ * SPI Flash Memory Stuff
+ */
+#define CFG_DW_SPI
+
+/* Include generic support for SPI Flash memory devices */
+#define CONFIG_SPI_FLASH
+
+/* Include support for SPI Flash memory devices from Spansion */
+#define CONFIG_SPI_FLASH_SPANSION
+
+/* Include support for SPI Flash memory devices from AMIC */
+#undef CONFIG_SPI_FLASH_AMIC
+
+/* Include support for SPI Flash memory devices from ST Micro/Numonyx */
+#define CONFIG_SPI_FLASH_STMICRO
+
+/* Include support for SPI Flash memory devices from EON */
+#define CONFIG_SPI_FLASH_EON
+
+/*-----------------------------------------------------------------------------
+ * U-Boot Environment Stuff
+ */
+#if defined(CONFIG_PC302_SIMULATION)
+
+/* We are running in RTL simulation land */
+
+/* No writable environment available in RTL sim land */
+#define CFG_ENV_IS_NOWHERE      (1)
+#define CFG_ENV_ADDR            (PC302_BOOTABLE_FLASH_BASE + FLASH_SECTOR_SIZE)
+
+/* One flash sector for environment info */
+#define CFG_ENV_SECT_SIZE       (FLASH_SECTOR_SIZE)
+
+/* But 2KBytes is sufficient */
+#define CFG_ENV_SIZE		(SZ_2K)
+
+/* Turn off wite protection for vendor parameters */
+#define CONFIG_ENV_OVERWRITE
+
+#else
+
+/* We are running on a real hardware platform */
+#ifndef CONFIG_RUN_FROM_RAM
+
+/* Environment variables stored in Flash memory */
+#define CFG_ENV_IS_IN_FLASH     (1)
+#define CFG_ENV_ADDR            (PC302_BOOTABLE_FLASH_BASE + FLASH_SECTOR_SIZE)
+
+/* One flash sector for environment info */
+#define CFG_ENV_SECT_SIZE       (FLASH_SECTOR_SIZE)
+
+/* But 64 KBytes is sufficient */
+#define CFG_ENV_SIZE		(SZ_64K)
+
+/* Turn off wite protection for vendor parameters */
+#define CONFIG_ENV_OVERWRITE
+
+#elif defined(CONFIG_CMD_NAND)
+
+/* We are runing from ram with NAND support */
+
+/* NAND Flash memory map
+ *
+ *  Block 0 U-Boot image
+ *  Block 1 Redundant U-Boot image
+ *  Block 2 Spare
+ *  Block 3 Spare
+ *  Block 4 U-Boot Environment
+ *  Block 5 Redundant U-Boot environment
+ *  Block 6 Spare
+ *  Block 7 Spare
+ *  Block 8 Linux kernel
+ *
+ */
+#define CFG_ENV_IS_IN_NAND      (1)
+#define CFG_ENV_OFFSET          (NAND_FLASH_SECTOR_SIZE * 4)
+#define CFG_ENV_SIZE            (NAND_FLASH_SECTOR_SIZE)
+#define CFG_ENV_OFFSET_REDUND   (NAND_FLASH_SECTOR_SIZE * 5)
+
+/* Turn off wite protection for vendor parameters */
+#define CONFIG_ENV_OVERWRITE
+
+#else
+
+/* We are running from ram, therefore no environment */
+#define CFG_ENV_IS_NOWHERE
+
+/* Need to define this for the build to be successful */
+#define CFG_ENV_SIZE		(SZ_64K)
+
+#endif /* CONFIG_RUN_FROM_RAM */
+
+#endif /* CONFIG_PC302_SIMULATION */
+
+/*-----------------------------------------------------------------------------
+ * Timer Stuff
+ */
+#define CFG_TIMERBASE           (PC302_TIMER_BASE)
+
+/*-----------------------------------------------------------------------------
+ * Ethernet Stuff
+ */
+#define CFG_DW_EMAC
+#define CONFIG_PHY_ADDR         (1)
+#define CONFIG_NET_MULTI
+
+/*-----------------------------------------------------------------------------
+ * Serial Port Stuff
+ */
+#define CFG_DW_APB_UART
+
+/* Baud rate generators clock with a 3.6864 MHz clock */
+#define CONFIG_DW_APB_UART_CLOCK    (3686400)
+
+/* Console on Uart #0 */
+#define CONFIG_CONS_INDEX	    (1)
+#define CFG_BAUDRATE_TABLE	    { 9600, 19200, 38400, 57600, 115200, 230400 }
+
+/*-----------------------------------------------------------------------------
+ * Watchdog Stuff
+ */
+/* Use the GPIO reset method as supported on this hardware platform
+   Note: Undef this macro to use the 'fallback' watcdog reset method */
+#undef CONFIG_USE_GPIO_RESET_METHOD
+
+/*-----------------------------------------------------------------------------
+ * U-Boot Memory Test (mtest command) Stuff
+ */
+/* Default start address for memory test */
+#define CFG_MEMTEST_START	(PC302_ONCHIP_SRAM_BASE)
+
+/* Default end address for memory test */
+#define CFG_MEMTEST_END		(CFG_MEMTEST_START + PC302_ONCHIP_SRAM_SIZE - 1)
+
+/* Define this to use the super duper memory test */
+#define CFG_ALT_MEMTEST
+
+/* Use Uart #1 scratch pad reg */
+#define CFG_MEMTEST_SCRATCH     (PC302_UART1_BASE + UART_SCRATCH_REG_OFFSET)
+
+/*-----------------------------------------------------------------------------
+ * U-Boot Supported Commands
+ */
+#include "config_cmd_default.h"
+
+#define CONFIG_CMD_PING
+
+/* Include commands for SPI bus */
+#undef CONFIG_CMD_SPI
+
+/* Include commands for SPI Flash memory */
+#define CONFIG_CMD_SF
+
+#undef CONFIG_CMD_AUTOSCRIPT
+#undef CONFIG_CMD_BOOTD
+#undef CONFIG_CMD_CONSOLE
+#undef CONFIG_CMD_ECHO
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_ITEST
+#undef CONFIG_CMD_LOADB
+#undef CONFIG_CMD_LOADS
+#undef CONFIG_CMD_MISC
+#undef CONFIG_CMD_NFS
+#undef CONFIG_CMD_SETGETDCR
+#undef CONFIG_CMD_XIMG
+
+#ifdef CFG_NO_FLASH
+#undef CONFIG_CMD_FLASH
+#endif /* CFG_NO_FLASH */
+
+#ifdef CFG_ENV_IS_NOWHERE
+#undef CONFIG_CMD_ENV
+#endif /* CFG_ENV_IS_NOWHERE */
+
+
+#if defined(CONFIG_PC302_SIMULATION)
+/* We are running in RTL simulation land */
+
+/* Do not use the HUSH parser */
+#undef  CFG_HUSH_PARSER
+#else
+/* We are running on a real hardware platform */
+
+/* Use the HUSH parser */
+#define CFG_HUSH_PARSER
+#endif /* CONFIG_PC302_SIMULATION */
+
+#ifdef  CFG_HUSH_PARSER
+/* This defines the secondary prompt string */
+#define CFG_PROMPT_HUSH_PS2 "> "
+#endif /* CFG_HUSH_PARSER */
+
+/* Enable command line editing and history */
+#define CONFIG_CMDLINE_EDITING
+
+/* Enable gpio test commands */
+//#define CONFIG_CMD_PC302_GPIO
+
+/*-----------------------------------------------------------------------------
+ * Miscellaneous Configurable Options...
+ */
+/* Use 'long' help messages */
+#define CFG_LONGHELP
+
+/* Monitor Command Prompt */
+#define CFG_PROMPT	"=> "
+
+/* Console I/O Buffer Size*/
+#define CFG_CBSIZE	(SZ_1K)
+
+/* Print buffer size */
+#define CFG_PBSIZE	(CFG_CBSIZE+sizeof(CFG_PROMPT)+16)
+
+/* Maximum number of command args */
+#define CFG_MAXARGS	(16)
+#define CONFIG_SYS_MAXARGS (CFG_MAXARGS)
+
+#define CONFIG_SYS_HELP_CMD_WIDTH (79)
+
+/* Boot Argument Buffer Size */
+#define CFG_BARGSIZE	(CFG_CBSIZE)
+
+/* everything, incl board info, in Hz */
+#undef	CFG_CLKS_IN_HZ
+
+/* Default load address for bootm and friends */
+#define CFG_LOAD_ADDR	        (0x00200000)
+#define CONFIG_SYS_LOAD_ADDR    (CFG_LOAD_ADDR)
+/*-----------------------------------------------------------------------
+ * Environment Configuration
+ */
+
+/* Note: The MAC Address defined by 'CONFIG_ETHADDR' is based on
+ * picoChip's OUI,see http://standards.ieee.org/regauth/oui/index.shtml
+ * for more information. It will need to be modified for each and every
+ * individual hardware platform.
+ */
+
+#if defined(CFG_DW_EMAC)
+
+/* picoChip OUI, will need noodling by users */
+#define CONFIG_ETHADDR          00:15:E1:00:00:00
+
+/* picoChip default for testing, will need noodling by users */
+#define CONFIG_IPADDR           172.17.13.248
+
+#define CONFIG_HOSTNAME	        picopc7302
+#define CONFIG_ROOTPATH	        /var/nfspc7302
+#define CONFIG_BOOTFILE	        uImage-pc7302
+
+#define CONFIG_SERVERIP         172.17.7.100
+#define CONFIG_GATEWAYIP        172.17.0.1
+#define CONFIG_NETMASK          255.255.0.0
+
+#endif /* CFG_DW_EMAC */
+
+/* This is the address in NOR Flash where the Linux kernel
+ * can be found.
+ * Note: this is the second flash sector
+ */
+#define CFG_FLASH_KERNEL_BASE   0x40040000
+
+/* This is the offset from the start of NAND Flash
+ * to where the Linux kernel can be found.
+ */
+#define NAND_KERNEL_OFFSET      0x00100000
+
+/* Default location for tftp and bootm */
+#define CONFIG_LOADADDR         0x00200000
+
+#if defined(CONFIG_PC302_SIMULATION)
+/* We are running in RTL simulation land */
+
+/* Time in seconds before autoboot, -1 disables auto-boot */
+#define CONFIG_BOOTDELAY        -1
+#else
+/* We are running on a real hardware platform */
+
+/* Time in seconds before autoboot, -1 disables auto-boot */
+#define CONFIG_BOOTDELAY        5
+#endif  /* CONFIG_PC302_SIMULATION */
+
+/* The boot command will set bootargs */
+#undef  CONFIG_BOOTARGS
+
+/* Default console baud rate */
+#define CONFIG_BAUDRATE	        115200
+
+/* Unless specified here we'll just rely on the kernel default */
+#define OTHERBOOTARGS
+
+#define	CONFIG_EXTRA_ENV_SETTINGS				            \
+   "othbootargs=" MK_STR (OTHERBOOTARGS) "\0"                               \
+   "netdev=eth0\0"                                                          \
+   "consoledev=ttyS0\0"                                                     \
+   "kernel_flash_addr=" MK_STR(CFG_FLASH_KERNEL_BASE) "\0"		    \
+   "kernel_nand_offset=" MK_STR(NAND_KERNEL_OFFSET) "\0"                    \
+   "flash_jffs2=run jffs2_args; bootm $kernel_flash_addr\0"		    \
+   "flash_ubifs=run ubifs_args; bootm $kernel_flash_addr\0"		    \
+   "nand_jffs2=run nand_jffs2_args; nboot $loadaddr 0 "                     \
+   "$kernel_nand_offset; bootm $loadaddr\0"                                 \
+   "nand_ubifs=run nand_ubifs_args; nboot $loadaddr 0 "                     \
+   "$kernel_nand_offset; bootm $loadaddr\0"                                 \
+   "fixed_nfs=run nfs_args; tftp; bootm\0"				    \
+   "jffs2_args=setenv bootargs root=/dev/mtdblock1 rw rootfstype=jffs2 "    \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "        \
+   "console=$consoledev,$baudrate $othbootargs;\0"                          \
+   "ubifs_args=setenv bootargs root=ubi0:rootfs rw rootfstype=ubifs "       \
+   "ubi.mtd=1 "                                                             \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "        \
+   "console=$consoledev,$baudrate $othbootargs;\0"                          \
+   "nand_jffs2_args=setenv bootargs root=/dev/mtdblock6 rw "                \
+   "rootfstype=jffs2 "                                                      \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "        \
+   "console=$consoledev,$baudrate $othbootargs;\0"                          \
+   "nand_ubifs_args=setenv bootargs root=ubi0:rootfs rw rootfstype=ubifs "  \
+   "ubi.mtd=6,2048 "                                                        \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "        \
+   "console=$consoledev,$baudrate $othbootargs;\0"                          \
+   "nfs_args=setenv bootargs root=/dev/nfs rw nfsroot=$serverip:$rootpath " \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "        \
+   "console=$consoledev,$baudrate $othbootargs;"                            \
+
+/* Define CONFIG_BOOTCOMMAND as
+ * "run nand_ubifs" for boot from NAND flash with ubifs filesystem
+ * "run nand_jffs2" for boot from NAND flash with jffs2 filesystem
+ * "run flash_ubifs" for boot from NOR flash with ubifs filesystem
+ * "run flash_jffs2" for boot from NOR flash with jffs2 filesystem
+ * "run fixed_nfs" for standard NFS with fixed IP address.
+ */
+#if defined(CONFIG_CMD_NAND)
+    #if defined(PICO_USE_UBIFS)
+        #define CONFIG_BOOTCOMMAND  "run nand_ubifs"
+    #else
+        #define CONFIG_BOOTCOMMAND  "run nand_jffs2"
+    #endif
+#else /* !defined(CONFIG_CMD_NAND) */
+    #if defined(PICO_USE_UBIFS)
+        #define CONFIG_BOOTCOMMAND  "run flash_ubifs"
+    #else
+        #define CONFIG_BOOTCOMMAND  "run flash_jffs2"
+    #endif
+#endif
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/picochippc7802.h b/include/configs/picochippc7802.h
new file mode 100644
index 0000000..c35e0e0
--- /dev/null
+++ b/include/configs/picochippc7802.h
@@ -0,0 +1,388 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file picochippc7802.h
+* \brief Configuration file for U-Boot on the PC7802 platform.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <asm/arch/pc20x.h>
+#include <asm/arch/sizes.h>
+#include <asm/arch/uart.h>
+
+/*-----------------------------------------------------------------------------
+ * Platform Identification Stuff
+ */
+#define PICOCHIP "picochip"
+
+/* Which hardware platform I am destined for */
+#define PICOCHIP_PLATFORM "pc7802"
+
+/* Specific version of this build */
+#ifndef PICOCHIP_PLATFORM_VERSION
+#define PICOCHIP_PLATFORM_VERSION "3.2.4"
+#endif /* PICOCHIP_PLATFORM_VERSION */
+
+#define CONFIG_IDENT_STRING " "PICOCHIP"-"PICOCHIP_PLATFORM_VERSION \
+                            "-"PICOCHIP_PLATFORM
+
+/*-----------------------------------------------------------------------------
+ * High Level Configuration Options
+ */
+/* Running on picoChip PC20x Si */
+#define CONFIG_PICOCHIP_PC20X
+
+/* Running on a picoChip PC7802 platform */
+#define CONFIG_PICOCHIP_PC7802
+
+/* Define this if you want to run with 2 Banks DDR Ram */
+#define CONFIG_PC20X_2_DDR_RAM_BANKS
+
+/* Define this if running code in PC20X rtl simulation land */
+#undef CONFIG_PC20X_SIMULATION
+
+/* Bootable Flash memory has to live here (/ebi_decode0) */
+#define PC20X_BOOTABLE_FLASH_BASE   (0x20000000)
+
+/* Base address of the onchip SRAM */
+#define PC20X_ONCHIP_SRAM_BASE      (0x10000000)
+#define PC20X_ONCHIP_SRAM_SIZE      (SZ_128K)
+
+/* ARM Sub-system peripherals are clocked at 140 MHz Rev B Si */
+#define PC20X_AHB_CLOCK_FREQ        (140000000)
+
+/* Don't use Interrupts */
+#undef CONFIG_USE_IRQ
+
+/* Onchip timer runs at this frequency */
+#define CFG_HZ			    (PC20X_AHB_CLOCK_FREQ)
+#define CONFIG_SYS_HZ               (CFG_HZ)
+
+/* Display board info */
+#define CONFIG_DISPLAY_BOARDINFO    (1)
+
+/* Are we are going to be running from RAM ? */
+#ifdef CONFIG_RUN_FROM_RAM
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_SKIP_RELOCATE_UBOOT
+#endif /* CONFIG_RUN_FROM_RAM */
+
+/*-----------------------------------------------------------------------
+ * Stack Sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(SZ_256K)	    /* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(SZ_1K)	            /* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(SZ_1K)	            /* FIQ stack */
+#endif /* CONFIG_USE_IRQ */
+
+/*-----------------------------------------------------------------------------
+ * Size of malloc() pool
+ */
+#define CFG_MALLOC_LEN		(SZ_128K)
+
+ /* Size in bytes reserved for initial data */
+#define CFG_GBL_DATA_SIZE	(SZ_256)
+
+/*-----------------------------------------------------------------------------
+ * Linux Kernel Stuff
+ */
+/* Allow passing of command line args (bootargs) to the linux kernel*/
+#define CONFIG_CMDLINE_TAG
+
+/*-----------------------------------------------------------------------------
+ * DDR2 RAM Memory Map
+ */
+#ifndef CONFIG_PC20X_2_DDR_RAM_BANKS
+/* We want a 4 DDR Bank setup then */
+
+#define CONFIG_NR_DRAM_BANKS    4               /* We have 4 RAM banks */
+#define PHYS_SDRAM_1		0x00000000
+#define PHYS_SDRAM_1_SIZE	SZ_32M          /* 32 Mbytes */
+#define PHYS_SDRAM_2		0x04000000
+#define PHYS_SDRAM_2_SIZE	SZ_32M          /* 32 Mbytes */
+#define PHYS_SDRAM_3		0x08000000
+#define PHYS_SDRAM_3_SIZE	SZ_32M          /* 32 Mbytes */
+#define PHYS_SDRAM_4		0x0C000000
+#define PHYS_SDRAM_4_SIZE	SZ_32M          /* 32 Mbytes */
+
+#else   /* We want a 2 DDR Bank setup then */
+
+#define CONFIG_NR_DRAM_BANKS    2               /* We have 2 RAM banks */
+#define PHYS_SDRAM_1		0x00000000
+#define PHYS_SDRAM_1_SIZE	SZ_32M          /* 32 Mbytes */
+#define PHYS_SDRAM_2		0x04000000
+#define PHYS_SDRAM_2_SIZE	SZ_32M          /* 32 Mbytes */
+
+#endif /* CONFIG_PC20X_2_DDR_RAM_BANKS */
+
+/*-----------------------------------------------------------------------------
+ * Flash Memory Stuff
+ */
+#ifndef CONFIG_RUN_FROM_RAM
+
+/* Define Flash memory sector size
+  256 kbytes (2 off Flash devices with 128K sector size) */
+#define FLASH_SECTOR_SIZE	(SZ_256K)
+
+#define CFG_FLASH_CFI
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_EMPTY_INFO
+
+/* Provide a much improved performance when writing to the Flash */
+#define CFG_FLASH_USE_BUFFER_WRITE
+
+#define CFG_FLASH_BASE		(PC20X_BOOTABLE_FLASH_BASE)
+
+/* Maximum number of memory banks */
+#define CFG_MAX_FLASH_BANKS	(1)
+
+/* Maximum number of sectors per flash device */
+#define CFG_MAX_FLASH_SECT	(512)
+
+/* Timeouts for Flash Erasing and writing */
+#define CFG_FLASH_ERASE_TOUT	(2*CFG_HZ)
+#define CFG_FLASH_WRITE_TOUT	(2*CFG_HZ)
+
+/* U-Boot has its own Flash sector */
+#define CFG_MONITOR_LEN		(FLASH_SECTOR_SIZE)
+
+/* U-Boot lives in the bottom of the Flash memory */
+#define CFG_MONITOR_BASE        (CFG_FLASH_BASE)
+
+#else
+
+/* No flash memory in the system */
+#define CFG_NO_FLASH
+
+#endif /* CONFIG_RUN_FROM_RAM */
+
+/*-----------------------------------------------------------------------------
+ * U-Boot Environment Stuff
+ */
+#ifndef CONFIG_RUN_FROM_RAM
+
+/* Environment variables stored in Flash memory */
+#define CFG_ENV_IS_IN_FLASH     (1)
+#define CFG_ENV_ADDR            (PC20X_BOOTABLE_FLASH_BASE + FLASH_SECTOR_SIZE)
+
+/* One flash sector for environment info */
+#define CFG_ENV_SECT_SIZE       (FLASH_SECTOR_SIZE)
+
+/* Turn off wite protection for vendor parameters */
+#define CONFIG_ENV_OVERWRITE
+
+#else
+
+/* Just use the default environment in the image */
+#define CFG_ENV_IS_NOWHERE
+
+#endif /* CONFIG_RUN_FROM_RAM */
+
+/* Where ever the environment is, 64Kbytes should be sufficient */
+#define CFG_ENV_SIZE		(SZ_64K)
+
+/*-----------------------------------------------------------------------------
+ * Timer Stuff
+ */
+#define CFG_TIMERBASE           (PC20X_TIMER_BASE)
+
+/*-----------------------------------------------------------------------------
+ * Ethernet Stuff
+ */
+#define CFG_DW_EMAC
+#define CONFIG_PHY_ADDR         (1)
+#define CONFIG_NET_MULTI
+
+/*-----------------------------------------------------------------------------
+ * Serial Port Stuff
+ */
+#define CFG_DW_APB_UART
+
+/* Baud rate generators clock with a 3.6864 MHz clock */
+#define CONFIG_DW_APB_UART_CLOCK    (3686400)
+
+/* Console on Uart #0 */
+#define CONFIG_CONS_INDEX	    (1)
+#define CFG_BAUDRATE_TABLE	    { 9600, 19200, 38400, 57600, 115200, 230400 }
+
+/*-----------------------------------------------------------------------------
+ * U-Boot Memory Test (mtest command) Stuff
+ */
+/* Default start address for memory test */
+#define CFG_MEMTEST_START	(PC20X_ONCHIP_SRAM_BASE)
+
+/* Default end address for memory test */
+#define CFG_MEMTEST_END		(CFG_MEMTEST_START + PC20X_ONCHIP_SRAM_SIZE - 1)
+
+/* Define this to use the super duper memory test */
+#define CFG_ALT_MEMTEST
+
+/* Use uart #1 scratch pad reg */
+#define CFG_MEMTEST_SCRATCH     (PC20X_UART1_BASE + UartScratchRegOffset)
+
+/*-----------------------------------------------------------------------------
+ * U-Boot Supported Commands
+ */
+#include "config_cmd_default.h"
+
+#define CONFIG_CMD_PING
+#undef CONFIG_CMD_AUTOSCRIPT
+#undef CONFIG_CMD_BOOTD
+#undef CONFIG_CMD_CONSOLE
+#undef CONFIG_CMD_ECHO
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_ITEST
+#undef CONFIG_CMD_LOADB
+#undef CONFIG_CMD_LOADS
+#undef CONFIG_CMD_MISC
+#undef CONFIG_CMD_NFS
+#undef CONFIG_CMD_XIMG
+
+#ifdef CFG_NO_FLASH
+#undef CONFIG_CMD_FLASH
+#undef CONFIG_CMD_ENV
+#endif /* CFG_NO_FLASH */
+
+/* Use the HUSH parser */
+#define CFG_HUSH_PARSER
+
+#ifdef  CFG_HUSH_PARSER
+/* This defines the secondary prompt string */
+#define CFG_PROMPT_HUSH_PS2 "> "
+#endif /* CFG_HUSH_PARSER */
+
+/* Enable command line editing and history */
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------------
+ * Miscellaneous Configurable Options...
+ */
+/* Use 'long' help messages */
+#define CFG_LONGHELP
+
+/* Monitor Command Prompt */
+#define CFG_PROMPT	"=> "
+
+/* Console I/O Buffer Size*/
+#define CFG_CBSIZE	(SZ_1K)
+
+/* Print buffer size */
+#define CFG_PBSIZE	(CFG_CBSIZE+sizeof(CFG_PROMPT)+16)
+
+/* Maximum number of command args */
+#define CFG_MAXARGS	(16)
+
+/* Boot Argument Buffer Size*/
+#define CFG_BARGSIZE	(CFG_CBSIZE)
+
+/* everything, incl board info, in Hz */
+#undef	CFG_CLKS_IN_HZ
+
+/* Default load address for bootm and friends */
+#define CFG_LOAD_ADDR	(0x20080000)
+
+/*-----------------------------------------------------------------------
+ * Environment Configuration
+ */
+
+/* Note: This MAC address is based on the real picoChip OUI, it
+ * will need to be modified (as per the picoChip MAC address creation spec)
+ * for each and every board.
+ */
+
+#if defined(CFG_DW_EMAC)
+
+/* picoChip OUI, will need noodling by users */
+#define CONFIG_ETHADDR          00:15:E1:00:00:00
+
+/* picoChip default for testing, will need noodling by users */
+#define CONFIG_IPADDR           172.17.14.248
+
+#define CONFIG_HOSTNAME	        picopc7802
+#define CONFIG_ROOTPATH	        /var/nfspc7802
+#define CONFIG_BOOTFILE	        uImage-pc7802
+
+#define CONFIG_SERVERIP         172.17.7.100
+#define CONFIG_GATEWAYIP        172.17.0.1
+#define CONFIG_NETMASK          255.255.0.0
+
+#endif
+
+/* Second flash sector... */
+#define CFG_FLASH_KERNEL_BASE   0x20080000
+
+/* Default location for tftp and bootm */
+#define CONFIG_LOADADDR         0x00200000
+
+/* Time in seconds before autoboot, -1 disables auto-boot */
+#define CONFIG_BOOTDELAY        5
+
+/* The boot command will set bootargs */
+#undef  CONFIG_BOOTARGS
+
+/* Default console baud rate */
+#define CONFIG_BAUDRATE	        115200
+
+#ifndef CONFIG_PC20X_2_DDR_RAM_BANKS
+/* We want a 4 DDR Bank setup then */
+
+/* Unless specified here we'll just rely on the kernel default */
+#define OTHERBOOTARGS
+
+#else   /* We want a 2 DDR Bank setup then */
+
+/* We need to 'over ride' the kernel default */
+#define OTHERBOOTARGS pc20x_mem=32M@PHYS_SDRAM_1 pc20x_mem=32M@PHYS_SDRAM_2
+
+#endif /* CONFIG_PC20X_2_DDR_RAM_BANKS */
+
+#define	CONFIG_EXTRA_ENV_SETTINGS				        \
+   "othbootargs=" MK_STR (OTHERBOOTARGS) "\0"                           \
+   "netdev=eth0\0"                                                      \
+   "consoledev=ttyS0\0"                                                 \
+   "kernel_flash_addr=" MK_STR(CFG_FLASH_KERNEL_BASE) "\0"		\
+   "flash_jffs2=run jffs2_args; bootm $kernel_flash_addr\0"		\
+   "fixed_nfs=run nfs_args; tftp; bootm\0"				\
+   "jffs2_args=setenv bootargs root=/dev/mtdblock1 rw rootfstype=jffs2 " \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "    \
+   "console=$consoledev,$baudrate $othbootargs;\0"                      \
+   "nfs_args=setenv bootargs root=/dev/nfs rw nfsroot=$serverip:$rootpath " \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "    \
+   "console=$consoledev,$baudrate $othbootargs;"                        \
+
+#define CONFIG_NFSBOOTCOMMAND	                                        \
+   "setenv bootargs root=/dev/nfs rw "                                  \
+   "nfsroot=$serverip:$rootpath "                                       \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "    \
+   "console=$consoledev,$baudrate $othbootargs;"                        \
+   "bootm $kernel_flash_addr"
+
+#define CONFIG_RAMBOOTCOMMAND                                           \
+   "setenv bootargs root=/dev/ram rw "                                  \
+   "console=$consoledev,$baudrate $othbootargs;"                        \
+   "tftp $ramdiskaddr $ramdiskfile;"                                    \
+   "tftp $loadaddr $bootfile;"                                          \
+   "bootm $loadaddr $ramdiskaddr"
+
+/* Define as "run flash_jffs2" for on-board boot, or "run fixed_nfs" for
+ * standard NFS with fixed IP.  Or use NFSBOOTCOMMAND etc as above.
+ */
+#define CONFIG_BOOTCOMMAND  "run flash_jffs2"
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/picochipsvb302.h b/include/configs/picochipsvb302.h
new file mode 100644
index 0000000..5ba96b7
--- /dev/null
+++ b/include/configs/picochipsvb302.h
@@ -0,0 +1,444 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file picochipsvb302.h
+* \brief Configuration file for U-Boot on the SVB302 platform.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <asm/arch/pc302.h>
+#include <asm/arch/sizes.h>
+#include <asm/arch/uart.h>
+
+/*-----------------------------------------------------------------------------
+ * Platform Identification Stuff
+ */
+#define PICOCHIP "picochip"
+
+/* Which hardware platform I am destined for */
+#define PICOCHIP_PLATFORM "svb302"
+
+/* Specific version of this build */
+#ifndef PICOCHIP_PLATFORM_VERSION
+#define PICOCHIP_PLATFORM_VERSION "3.2.4"
+#endif /* PICOCHIP_PLATFORM_VERSION */
+
+#define CONFIG_IDENT_STRING " "PICOCHIP"-"PICOCHIP_PLATFORM_VERSION \
+                            "-"PICOCHIP_PLATFORM
+
+/*-----------------------------------------------------------------------------
+ * High Level Configuration Options
+ */
+/* Running on picoChip PC302 Silicon */
+#define CONFIG_PICOCHIP_PC302
+
+/* Running on a picoChip SVB302 platform */
+#define CONFIG_PICOCHIP_SVB302
+
+/* Define this if running code in PC302 rtl simulation land */
+#undef CONFIG_PC302_SIMULATION
+
+/* Define to disable the verify after U-Boot has relocated from ROM to RAM */
+#undef CONFIG_SKIP_VERIFY_RELOCATE_UBOOT
+
+/* Bootable Flash memory has to live here (/ebi_decode0) */
+#define PC302_BOOTABLE_FLASH_BASE   (PC302_FLASH_BASE)
+
+/* Base address of the onchip SRAM */
+#define PC302_ONCHIP_SRAM_BASE      (PC302_SRAM_BASE)
+#define PC302_ONCHIP_SRAM_SIZE      (PC302_SRAM_SIZE)
+
+/* ARM Sub-system peripherals are clocked at 200MHz */
+#define PC302_AHB_CLOCK_FREQ        (200000000)
+
+/* Don't use Interrupts */
+#undef CONFIG_USE_IRQ
+
+/* Onchip timer runs at this frequency */
+#define CFG_HZ			    (PC302_AHB_CLOCK_FREQ)
+
+/* Display board info */
+#define CONFIG_DISPLAY_BOARDINFO    (1)
+
+/* Are we are going to be running from RAM ? */
+#ifdef CONFIG_RUN_FROM_RAM
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_SKIP_RELOCATE_UBOOT
+#endif /* CONFIG_RUN_FROM_RAM */
+
+/*-----------------------------------------------------------------------
+ * Stack Sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#if defined(CONFIG_PC302_SIMULATION)
+/* We are running in RTL simulation land, reduce the stack sizes
+   so we do not have any memory model problems */
+#define CONFIG_STACKSIZE	(SZ_1K)             /* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(SZ_128)            /* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(SZ_128)    	    /* FIQ stack */
+#endif /* CONFIG_USE_IRQ */
+#else
+/* We are running on a real hardware platform, therefore set the stack
+   sizes to their 'correct' values */
+#define CONFIG_STACKSIZE	(SZ_128K) 	    /* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(SZ_4K)             /* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(SZ_4K)    	    /* FIQ stack */
+#endif /* CONFIG_USE_IRQ */
+
+#endif  /* CONFIG_PC302_SIMULATION */
+
+/*-----------------------------------------------------------------------------
+ * Size of malloc() pool
+ */
+#if defined(CONFIG_PC302_SIMULATION)
+/* We are running in RTL simulation land */
+
+/* Memory size for use by malloc () */
+#define CFG_MALLOC_LEN		(SZ_4K)
+#else
+/* We are running on a real hardware platform */
+
+/* Memory size for use by malloc () */
+#define CFG_MALLOC_LEN		(SZ_128K)
+#endif  /* CONFIG_PC302_SIMULATION */
+
+/* Size in bytes reserved for initial data */
+#define CFG_GBL_DATA_SIZE	(SZ_256)
+
+/*-----------------------------------------------------------------------------
+ * Linux Kernel Stuff
+ */
+/* Allow passing of command line args (bootargs) to the linux kernel*/
+#define CONFIG_CMDLINE_TAG
+
+/*-----------------------------------------------------------------------------
+ * DDR2 RAM Memory Map
+ */
+/* We have 1 linear addressable RAM bank */
+#define CONFIG_NR_DRAM_BANKS    (1)
+#define PHYS_SDRAM_1		(PC302_DDRBANK_BASE)
+#define PHYS_SDRAM_1_SIZE	(SZ_256M)
+
+/*-----------------------------------------------------------------------------
+ * Flash Memory Stuff
+ */
+#ifndef CONFIG_RUN_FROM_RAM
+
+/* Define Flash memory sector size */
+#define FLASH_SECTOR_SIZE	(SZ_128K)
+
+#define CFG_FLASH_CFI
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_EMPTY_INFO
+
+/* Provide a much improved performance when writing to the Flash */
+#define CFG_FLASH_USE_BUFFER_WRITE
+
+#define CFG_FLASH_BASE		(PC302_BOOTABLE_FLASH_BASE)
+
+/* Maximum number of memory banks (devices) */
+#define CFG_MAX_FLASH_BANKS	(1)
+
+/* Maximum number of sectors per flash device */
+#define CFG_MAX_FLASH_SECT	(1024)
+
+/* Timeouts for Flash Erasing and writing */
+#define CFG_FLASH_ERASE_TOUT	(2*CFG_HZ)
+#define CFG_FLASH_WRITE_TOUT	(2*CFG_HZ)
+
+/* U-Boot has its own Flash sector */
+#define CFG_MONITOR_LEN		(FLASH_SECTOR_SIZE)
+
+/* U-Boot lives in the bottom of the Flash memory */
+#define CFG_MONITOR_BASE        (CFG_FLASH_BASE)
+
+#else
+
+/* No flash memory in the system */
+#define CFG_NO_FLASH
+
+#endif /* CONFIG_RUN_FROM_RAM */
+
+/*-----------------------------------------------------------------------------
+ * SPI Flash Memory Stuff
+ */
+#define CFG_DW_SPI
+
+/* Include generic support for SPI Flash memory devices */
+#define CONFIG_SPI_FLASH
+
+/* Include support for SPI Flash memory devices from Spansion */
+#define CONFIG_SPI_FLASH_SPANSION
+
+/* Include support for SPI Flash memory devices from AMIC */
+#define CONFIG_SPI_FLASH_AMIC
+
+/*-----------------------------------------------------------------------------
+ * U-Boot Environment Stuff
+ */
+#if defined(CONFIG_PC302_SIMULATION)
+
+/* We are running in RTL simulation land */
+
+/* No writable environment available in RTL sim land */
+#define CFG_ENV_IS_NOWHERE      (1)
+#define CFG_ENV_ADDR            (PC302_BOOTABLE_FLASH_BASE + FLASH_SECTOR_SIZE)
+
+/* One flash sector for environment info */
+#define CFG_ENV_SECT_SIZE       (FLASH_SECTOR_SIZE)
+
+/* But 2KBytes is sufficient */
+#define CFG_ENV_SIZE		(SZ_2K)
+
+/* Turn off wite protection for vendor parameters */
+#define CONFIG_ENV_OVERWRITE
+
+#else
+
+/* We are running on a real hardware platform */
+#ifndef CONFIG_RUN_FROM_RAM
+
+/* Environment variables stored in Flash memory */
+#define CFG_ENV_IS_IN_FLASH     (1)
+#define CFG_ENV_ADDR            (PC302_BOOTABLE_FLASH_BASE + FLASH_SECTOR_SIZE)
+
+/* One flash sector for environment info */
+#define CFG_ENV_SECT_SIZE       (FLASH_SECTOR_SIZE)
+
+/* Turn off wite protection for vendor parameters */
+#define CONFIG_ENV_OVERWRITE
+
+#else
+
+/* Where ever the environment is, 64Kbytes should be sufficient */
+#define CFG_ENV_IS_NOWHERE
+
+#endif /* CONFIG_RUN_FROM_RAM */
+
+/* But 64 KBytes is sufficient */
+#define CFG_ENV_SIZE		(SZ_64K)
+
+#endif /* CONFIG_PC302_SIMULATION */
+
+/*-----------------------------------------------------------------------------
+ * Timer Stuff
+ */
+#define CFG_TIMERBASE           (PC302_TIMER_BASE)
+
+/*-----------------------------------------------------------------------------
+ * Ethernet Stuff
+ */
+#define CFG_DW_EMAC
+#define CONFIG_PHY_ADDR         (1)
+#define CONFIG_NET_MULTI
+
+/*-----------------------------------------------------------------------------
+ * Serial Port Stuff
+ */
+#define CFG_DW_APB_UART
+
+/* Baud rate generators clock with a 3.6864 MHz clock */
+#define CONFIG_DW_APB_UART_CLOCK    (3686400)
+
+/* Console on Uart #0 */
+#define CONFIG_CONS_INDEX	    (1)
+#define CFG_BAUDRATE_TABLE	    { 9600, 19200, 38400, 57600, 115200, 230400 }
+
+/*-----------------------------------------------------------------------------
+ * U-Boot Memory Test (mtest command) Stuff
+ */
+/* Default start address for memory test */
+#define CFG_MEMTEST_START	(PC302_ONCHIP_SRAM_BASE)
+
+/* Default end address for memory test */
+#define CFG_MEMTEST_END		(CFG_MEMTEST_START + PC302_ONCHIP_SRAM_SIZE - 1)
+
+/* Define this to use the super duper memory test */
+#define CFG_ALT_MEMTEST
+
+/* Use Uart #1 scratch pad reg */
+#define CFG_MEMTEST_SCRATCH     (PC302_UART1_BASE + UART_SCRATCH_REG_OFFSET)
+
+/*-----------------------------------------------------------------------------
+ * U-Boot Supported Commands
+ */
+#include "config_cmd_default.h"
+
+#define CONFIG_CMD_PING
+
+/* Include commands for SPI bus */
+#define CONFIG_CMD_SPI
+
+/* Include commands for SPI Flash memory */
+#define CONFIG_CMD_SF
+
+#undef CONFIG_CMD_AUTOSCRIPT
+#undef CONFIG_CMD_BOOTD
+#undef CONFIG_CMD_CONSOLE
+#undef CONFIG_CMD_ECHO
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_ITEST
+#undef CONFIG_CMD_LOADB
+#undef CONFIG_CMD_LOADS
+#undef CONFIG_CMD_MISC
+#undef CONFIG_CMD_NFS
+#undef CONFIG_CMD_SETGETDCR
+#undef CONFIG_CMD_XIMG
+
+#ifdef CFG_NO_FLASH
+#undef CONFIG_CMD_FLASH
+#undef CONFIG_CMD_ENV
+#endif /* CFG_NO_FLASH */
+
+#if defined(CONFIG_PC302_SIMULATION)
+/* We are running in RTL simulation land */
+
+/* Do not use the HUSH parser */
+#undef  CFG_HUSH_PARSER
+#else
+/* We are running on a real hardware platform */
+
+/* Use the HUSH parser */
+#define CFG_HUSH_PARSER
+#endif /* CONFIG_PC302_SIMULATION */
+
+#ifdef  CFG_HUSH_PARSER
+/* This defines the secondary prompt string */
+#define CFG_PROMPT_HUSH_PS2 "> "
+#endif /* CFG_HUSH_PARSER */
+
+/* Enable command line editing and history */
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------------
+ * Miscellaneous Configurable Options...
+ */
+/* Use 'long' help messages */
+#define CFG_LONGHELP
+
+/* Monitor Command Prompt */
+#define CFG_PROMPT	"=> "
+
+/* Console I/O Buffer Size*/
+#define CFG_CBSIZE	(SZ_1K)
+
+/* Print buffer size */
+#define CFG_PBSIZE	(CFG_CBSIZE+sizeof(CFG_PROMPT)+16)
+
+/* Maximum number of command args */
+#define CFG_MAXARGS	(16)
+
+/* Boot Argument Buffer Size */
+#define CFG_BARGSIZE	(CFG_CBSIZE)
+
+/* everything, incl board info, in Hz */
+#undef	CFG_CLKS_IN_HZ
+
+/* Default load address for bootm and friends */
+#define CFG_LOAD_ADDR	(0x20040000)
+
+/*-----------------------------------------------------------------------
+ * Environment Configuration
+ */
+
+/* Note: The MAC Address defined by 'CONFIG_ETHADDR' is based on
+ * picoChip's OUI,see http://standards.ieee.org/regauth/oui/index.shtml
+ * for more information. It will need to be modified for each and every
+ * individual hardware platform.
+ */
+
+#if defined(CFG_DW_EMAC)
+
+/* picoChip OUI, will need noodling by users */
+#define CONFIG_ETHADDR          00:15:E1:00:00:00
+
+/* picoChip default for testing, will need noodling by users */
+#define CONFIG_IPADDR           172.17.12.248
+
+#define CONFIG_HOSTNAME	        picosvb
+#define CONFIG_ROOTPATH	        /var/nfssvb302
+#define CONFIG_BOOTFILE	        uImage-svb302
+
+#define CONFIG_SERVERIP         172.17.7.100
+#define CONFIG_GATEWAYIP        172.17.0.1
+#define CONFIG_NETMASK          255.255.0.0
+
+#endif /* CFG_DW_EMAC */
+
+/* Second flash sector... */
+#define CFG_FLASH_KERNEL_BASE   0x20040000
+
+/* Default location for tftp and bootm */
+#define CONFIG_LOADADDR         0x00200000
+
+#if defined(CONFIG_PC302_SIMULATION)
+/* We are running in RTL simulation land */
+
+/* Time in seconds before autoboot, -1 disables auto-boot */
+#define CONFIG_BOOTDELAY        -1
+#else
+/* We are running on a real hardware platform */
+
+/* Time in seconds before autoboot, -1 disables auto-boot */
+#define CONFIG_BOOTDELAY        5
+#endif  /* CONFIG_PC302_SIMULATION */
+
+/* The boot command will set bootargs */
+#undef  CONFIG_BOOTARGS
+
+/* Default console baud rate */
+#define CONFIG_BAUDRATE	        115200
+
+/* Unless specified here we'll just rely on the kernel default */
+#define OTHERBOOTARGS
+
+#define	CONFIG_EXTRA_ENV_SETTINGS				        \
+   "othbootargs=" MK_STR (OTHERBOOTARGS) "\0"                           \
+   "netdev=eth0\0"                                                      \
+   "consoledev=ttyS0\0"                                                 \
+   "kernel_flash_addr=" MK_STR(CFG_FLASH_KERNEL_BASE) "\0"		\
+   "flash_jffs2=run jffs2_args; bootm $kernel_flash_addr\0"		\
+   "fixed_nfs=run nfs_args; tftp; bootm\0"				\
+   "jffs2_args=setenv bootargs root=/dev/mtdblock1 rw rootfstype=jffs2 " \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "    \
+   "console=$consoledev,$baudrate $othbootargs;\0"                      \
+   "nfs_args=setenv bootargs root=/dev/nfs rw nfsroot=$serverip:$rootpath " \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "    \
+   "console=$consoledev,$baudrate $othbootargs;"                        \
+
+#define CONFIG_NFSBOOTCOMMAND	                                        \
+   "setenv bootargs root=/dev/nfs rw "                                  \
+   "nfsroot=$serverip:$rootpath "                                       \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "    \
+   "console=$consoledev,$baudrate $othbootargs;"                        \
+   "bootm $kernel_flash_addr"
+
+#define CONFIG_RAMBOOTCOMMAND                                           \
+   "setenv bootargs root=/dev/ram rw "                                  \
+   "console=$consoledev,$baudrate $othbootargs;"                        \
+   "tftp $ramdiskaddr $ramdiskfile;"                                    \
+   "tftp $loadaddr $bootfile;"                                          \
+   "bootm $loadaddr $ramdiskaddr"
+
+/* Define as "run flash_jffs2" for on-board boot, or "run fixed_nfs" for
+ * standard NFS with fixed IP.  Or use NFSBOOTCOMMAND etc as above.
+ */
+#define CONFIG_BOOTCOMMAND  "run flash_jffs2"
+
+#endif /* __CONFIG_H */
diff --git a/include/linux/err.h b/include/linux/err.h
new file mode 100644
index 0000000..4e08c4f
--- /dev/null
+++ b/include/linux/err.h
@@ -0,0 +1,45 @@
+#ifndef _LINUX_ERR_H
+#define _LINUX_ERR_H
+
+/* XXX U-BOOT XXX */
+#if 0
+#include <linux/compiler.h>
+#else
+#include <linux/mtd/compat.h>
+#endif
+
+#include <asm/errno.h>
+
+
+/*
+ * Kernel pointers have redundant information, so we can use a
+ * scheme where we can return either an error code or a dentry
+ * pointer with the same return value.
+ *
+ * This should be a per-architecture thing, to allow different
+ * error and pointer decisions.
+ */
+#define MAX_ERRNO	4095
+
+#ifndef __ASSEMBLY__
+
+#define IS_ERR_VALUE(x) unlikely((x) >= (unsigned long)-MAX_ERRNO)
+
+static inline void *ERR_PTR(long error)
+{
+	return (void *) error;
+}
+
+static inline long PTR_ERR(const void *ptr)
+{
+	return (long) ptr;
+}
+
+static inline long IS_ERR(const void *ptr)
+{
+	return IS_ERR_VALUE((unsigned long)ptr);
+}
+
+#endif
+
+#endif /* _LINUX_ERR_H */
diff --git a/include/linux/mtd/compat.h b/include/linux/mtd/compat.h
index fe55087..9036b74 100644
--- a/include/linux/mtd/compat.h
+++ b/include/linux/mtd/compat.h
@@ -18,7 +18,12 @@
 #define KERN_DEBUG
 
 #define kmalloc(size, flags)	malloc(size)
-#define kfree(ptr)		free(ptr)
+#define kzalloc(size, flags)	calloc(size, 1)
+#define vmalloc(size)			malloc(size)
+#define kfree(ptr)				free(ptr)
+#define vfree(ptr)				free(ptr)
+
+#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
 
 /*
  * ..and if you can't take the strict
diff --git a/include/linux/mtd/mtd-abi.h b/include/linux/mtd/mtd-abi.h
index 4cebea9..410c5dd 100644
--- a/include/linux/mtd/mtd-abi.h
+++ b/include/linux/mtd/mtd-abi.h
@@ -1,5 +1,5 @@
 /*
- * $Id: mtd-abi.h,v 1.7 2004/11/23 15:37:32 gleixner Exp $
+ * $Id: mtd-abi.h,v 1.13 2005/11/07 11:14:56 gleixner Exp $
  *
  * Portions of MTD ABI definition which are shared by kernel and user space
  */
@@ -7,6 +7,10 @@
 #ifndef __MTD_ABI_H__
 #define __MTD_ABI_H__
 
+#if 1
+#include <linux/mtd/compat.h>
+#endif
+
 struct erase_info_user {
 	uint32_t start;
 	uint32_t length;
@@ -15,7 +19,7 @@ struct erase_info_user {
 struct mtd_oob_buf {
 	uint32_t start;
 	uint32_t length;
-	unsigned char *ptr;
+	unsigned char __user *ptr;
 };
 
 #define MTD_ABSENT		0
@@ -23,32 +27,19 @@ struct mtd_oob_buf {
 #define MTD_ROM			2
 #define MTD_NORFLASH		3
 #define MTD_NANDFLASH		4
-#define MTD_PEROM		5
-#define MTD_OTHER		14
-#define MTD_UNKNOWN		15
-
-#define MTD_CLEAR_BITS		1       /* Bits can be cleared (flash) */
-#define MTD_SET_BITS		2       /* Bits can be set */
-#define MTD_ERASEABLE		4       /* Has an erase function */
-#define MTD_WRITEB_WRITEABLE	8       /* Direct IO is possible */
-#define MTD_VOLATILE		16      /* Set for RAMs */
-#define MTD_XIP			32	/* eXecute-In-Place possible */
-#define MTD_OOB			64	/* Out-of-band data (NAND flash) */
-#define MTD_ECC			128	/* Device capable of automatic ECC */
-#define MTD_NO_VIRTBLOCKS	256	/* Virtual blocks not allowed */
+#define MTD_DATAFLASH		6
+#define MTD_UBIVOLUME		7
+
+#define MTD_WRITEABLE		0x400	/* Device is writeable */
+#define MTD_BIT_WRITEABLE	0x800	/* Single bits can be flipped */
+#define MTD_NO_ERASE		0x1000	/* No erase necessary */
+#define MTD_STUPID_LOCK		0x2000	/* Always locked after reset */
 
 /* Some common devices / combinations of capabilities */
 #define MTD_CAP_ROM		0
-#define MTD_CAP_RAM		(MTD_CLEAR_BITS|MTD_SET_BITS|MTD_WRITEB_WRITEABLE)
-#define MTD_CAP_NORFLASH        (MTD_CLEAR_BITS|MTD_ERASEABLE)
-#define MTD_CAP_NANDFLASH       (MTD_CLEAR_BITS|MTD_ERASEABLE|MTD_OOB)
-#define MTD_WRITEABLE		(MTD_CLEAR_BITS|MTD_SET_BITS)
-
-
-/* Types of automatic ECC/Checksum available */
-#define MTD_ECC_NONE		0	/* No automatic ECC available */
-#define MTD_ECC_RS_DiskOnChip	1	/* Automatic ECC on DiskOnChip */
-#define MTD_ECC_SW		2	/* SW ECC for Toshiba & Samsung devices */
+#define MTD_CAP_RAM		(MTD_WRITEABLE | MTD_BIT_WRITEABLE | MTD_NO_ERASE)
+#define MTD_CAP_NORFLASH	(MTD_WRITEABLE | MTD_BIT_WRITEABLE)
+#define MTD_CAP_NANDFLASH	(MTD_WRITEABLE)
 
 /* ECC byte placement */
 #define MTD_NANDECC_OFF		0	/* Switch off ECC (Not recommended) */
@@ -57,13 +48,20 @@ struct mtd_oob_buf {
 #define MTD_NANDECC_PLACEONLY	3	/* Use the given placement in the structure (Do not store ecc result on read) */
 #define MTD_NANDECC_AUTOPL_USR	4	/* Use the given autoplacement scheme rather than using the default */
 
+/* OTP mode selection */
+#define MTD_OTP_OFF		0
+#define MTD_OTP_FACTORY		1
+#define MTD_OTP_USER		2
+
 struct mtd_info_user {
 	uint8_t type;
 	uint32_t flags;
-	uint32_t size;	 /* Total size of the MTD */
+	uint32_t size;			/* Total size of the MTD */
 	uint32_t erasesize;
-	uint32_t oobblock;  /* Size of OOB blocks (e.g. 512) */
-	uint32_t oobsize;   /* Amount of OOB data per block (e.g. 16) */
+	uint32_t writesize;
+	uint32_t oobsize;		/* Amount of OOB data per block (e.g. 16) */
+	/* The below two fields are obsolete and broken, do not use them
+	 * (TODO: remove at some point) */
 	uint32_t ecctype;
 	uint32_t eccsize;
 };
@@ -76,19 +74,36 @@ struct region_info_user {
 	uint32_t regionindex;
 };
 
-#define MEMGETINFO              _IOR('M', 1, struct mtd_info_user)
-#define MEMERASE                _IOW('M', 2, struct erase_info_user)
-#define MEMWRITEOOB             _IOWR('M', 3, struct mtd_oob_buf)
-#define MEMREADOOB              _IOWR('M', 4, struct mtd_oob_buf)
-#define MEMLOCK                 _IOW('M', 5, struct erase_info_user)
-#define MEMUNLOCK               _IOW('M', 6, struct erase_info_user)
+struct otp_info {
+	uint32_t start;
+	uint32_t length;
+	uint32_t locked;
+};
+
+#define MEMGETINFO		_IOR('M', 1, struct mtd_info_user)
+#define MEMERASE		_IOW('M', 2, struct erase_info_user)
+#define MEMWRITEOOB		_IOWR('M', 3, struct mtd_oob_buf)
+#define MEMREADOOB		_IOWR('M', 4, struct mtd_oob_buf)
+#define MEMLOCK			_IOW('M', 5, struct erase_info_user)
+#define MEMUNLOCK		_IOW('M', 6, struct erase_info_user)
 #define MEMGETREGIONCOUNT	_IOR('M', 7, int)
 #define MEMGETREGIONINFO	_IOWR('M', 8, struct region_info_user)
 #define MEMSETOOBSEL		_IOW('M', 9, struct nand_oobinfo)
 #define MEMGETOOBSEL		_IOR('M', 10, struct nand_oobinfo)
 #define MEMGETBADBLOCK		_IOW('M', 11, loff_t)
 #define MEMSETBADBLOCK		_IOW('M', 12, loff_t)
+#define OTPSELECT		_IOR('M', 13, int)
+#define OTPGETREGIONCOUNT	_IOW('M', 14, int)
+#define OTPGETREGIONINFO	_IOW('M', 15, struct otp_info)
+#define OTPLOCK			_IOR('M', 16, struct otp_info)
+#define ECCGETLAYOUT		_IOR('M', 17, struct nand_ecclayout)
+#define ECCGETSTATS		_IOR('M', 18, struct mtd_ecc_stats)
+#define MTDFILEMODE		_IO('M', 19)
 
+/*
+ * Obsolete legacy interface. Keep it in order not to break userspace
+ * interfaces
+ */
 struct nand_oobinfo {
 	uint32_t useecc;
 	uint32_t eccbytes;
@@ -96,4 +111,46 @@ struct nand_oobinfo {
 	uint32_t eccpos[48];
 };
 
+struct nand_oobfree {
+	uint32_t offset;
+	uint32_t length;
+};
+
+#define MTD_MAX_OOBFREE_ENTRIES	8
+/*
+ * ECC layout control structure. Exported to userspace for
+ * diagnosis and to allow creation of raw images
+ */
+struct nand_ecclayout {
+	uint32_t eccbytes;
+	uint32_t eccpos[64];
+	uint32_t oobavail;
+	struct nand_oobfree oobfree[MTD_MAX_OOBFREE_ENTRIES];
+};
+
+/**
+ * struct mtd_ecc_stats - error correction stats
+ *
+ * @corrected:	number of corrected bits
+ * @failed:	number of uncorrectable errors
+ * @badblocks:	number of bad blocks in this partition
+ * @bbtblocks:	number of blocks reserved for bad block tables
+ */
+struct mtd_ecc_stats {
+	uint32_t corrected;
+	uint32_t failed;
+	uint32_t badblocks;
+	uint32_t bbtblocks;
+};
+
+/*
+ * Read/write file modes for access to MTD
+ */
+enum mtd_file_modes {
+	MTD_MODE_NORMAL = MTD_OTP_OFF,
+	MTD_MODE_OTP_FACTORY = MTD_OTP_FACTORY,
+	MTD_MODE_OTP_USER = MTD_OTP_USER,
+	MTD_MODE_RAW,
+};
+
 #endif /* __MTD_ABI_H__ */
diff --git a/include/linux/mtd/mtd.h b/include/linux/mtd/mtd.h
index 05ba375..354e3a0 100644
--- a/include/linux/mtd/mtd.h
+++ b/include/linux/mtd/mtd.h
@@ -1,6 +1,4 @@
 /*
- * $Id: mtd.h,v 1.56 2004/08/09 18:46:04 dmarlin Exp $
- *
  * Copyright (C) 1999-2003 David Woodhouse <dwmw2@infradead.org> et al.
  *
  * Released under GPL
@@ -8,10 +6,13 @@
 
 #ifndef __MTD_MTD_H__
 #define __MTD_MTD_H__
+
 #include <linux/types.h>
 #include <linux/mtd/mtd-abi.h>
 
-#define MAX_MTD_DEVICES 16
+#define MTD_CHAR_MAJOR 90
+#define MTD_BLOCK_MAJOR 31
+#define MAX_MTD_DEVICES 32
 
 #define MTD_ERASE_PENDING	0x01
 #define MTD_ERASING		0x02
@@ -19,6 +20,22 @@
 #define MTD_ERASE_DONE          0x08
 #define MTD_ERASE_FAILED        0x10
 
+/*
+ * Enumeration for NAND/OneNAND flash chip state
+ */
+enum {
+	FL_READY,
+	FL_READING,
+	FL_WRITING,
+	FL_ERASING,
+	FL_SYNCING,
+	FL_CACHEDPRG,
+	FL_RESETING,
+	FL_UNLOCKING,
+	FL_LOCKING,
+	FL_PM_SUSPENDED,
+};
+
 /* If the erase fails, fail_addr might indicate exactly which block failed.  If
    fail_addr = 0xffffffff, the failure was not at the device level or was not
    specific to any particular block. */
@@ -41,6 +58,53 @@ struct mtd_erase_region_info {
 	u_int32_t offset;			/* At which this region starts, from the beginning of the MTD */
 	u_int32_t erasesize;		/* For this region */
 	u_int32_t numblocks;		/* Number of blocks of erasesize in this region */
+	unsigned long *lockmap;		/* If keeping bitmap of locks */
+};
+
+/*
+ * oob operation modes
+ *
+ * MTD_OOB_PLACE:	oob data are placed at the given offset
+ * MTD_OOB_AUTO:	oob data are automatically placed at the free areas
+ *			which are defined by the ecclayout
+ * MTD_OOB_RAW:		mode to read raw data+oob in one chunk. The oob data
+ *			is inserted into the data. Thats a raw image of the
+ *			flash contents.
+ */
+typedef enum {
+	MTD_OOB_PLACE,
+	MTD_OOB_AUTO,
+	MTD_OOB_RAW,
+} mtd_oob_mode_t;
+
+/**
+ * struct mtd_oob_ops - oob operation operands
+ * @mode:	operation mode
+ *
+ * @len:	number of data bytes to write/read
+ *
+ * @retlen:	number of data bytes written/read
+ *
+ * @ooblen:	number of oob bytes to write/read
+ * @oobretlen:	number of oob bytes written/read
+ * @ooboffs:	offset of oob data in the oob area (only relevant when
+ *		mode = MTD_OOB_PLACE)
+ * @datbuf:	data buffer - if NULL only oob data are read/written
+ * @oobbuf:	oob data buffer
+ *
+ * Note, it is allowed to read more then one OOB area at one go, but not write.
+ * The interface assumes that the OOB write requests program only one page's
+ * OOB area.
+ */
+struct mtd_oob_ops {
+	mtd_oob_mode_t	mode;
+	size_t		len;
+	size_t		retlen;
+	size_t		ooblen;
+	size_t		oobretlen;
+	uint32_t	ooboffs;
+	uint8_t		*datbuf;
+	uint8_t		*oobbuf;
 };
 
 struct mtd_info {
@@ -48,25 +112,29 @@ struct mtd_info {
 	u_int32_t flags;
 	u_int32_t size;	 /* Total size of the MTD */
 
-	/* "Major" erase size for the device. Nave users may take this
+	/* "Major" erase size for the device. Nave users may take this
 	 * to be the only erase size available, or may use the more detailed
 	 * information below if they desire
 	 */
 	u_int32_t erasesize;
+	/* Minimal writable flash unit size. In case of NOR flash it is 1 (even
+	 * though individual bits can be cleared), in case of NAND flash it is
+	 * one NAND page (or half, or one-fourths of it), in case of ECC-ed NOR
+	 * it is of ECC block size, etc. It is illegal to have writesize = 0.
+	 * Any driver registering a struct mtd_info must ensure a writesize of
+	 * 1 or larger.
+	 */
+	u_int32_t writesize;
 
-	u_int32_t oobblock;  /* Size of OOB blocks (e.g. 512) */
 	u_int32_t oobsize;   /* Amount of OOB data per block (e.g. 16) */
-	u_int32_t oobavail;  /* Number of bytes in OOB area available for fs  */
-	u_int32_t ecctype;
-	u_int32_t eccsize;
-
+	u_int32_t oobavail;  /* Available OOB bytes per block */
 
 	/* Kernel-only stuff starts here. */
-	char *name;
+	const char *name;
 	int index;
 
-	/* oobinfo is a nand_oobinfo structure, which can be set by iotcl (MEMSETOOBINFO) */
-	struct nand_oobinfo oobinfo;
+	/* ecc layout structure pointer - read only ! */
+	struct nand_ecclayout *ecclayout;
 
 	/* Data for variable erase regions. If numeraseregions is zero,
 	 * it means that the whole device has erasesize as given above.
@@ -74,54 +142,65 @@ struct mtd_info {
 	int numeraseregions;
 	struct mtd_erase_region_info *eraseregions;
 
-	/* This really shouldn't be here. It can go away in 2.5 */
-	u_int32_t bank_size;
-
+	/*
+	 * Erase is an asynchronous operation.  Device drivers are supposed
+	 * to call instr->callback() whenever the operation completes, even
+	 * if it completes with a failure.
+	 * Callers are supposed to pass a callback function and wait for it
+	 * to be called before writing to the block.
+	 */
 	int (*erase) (struct mtd_info *mtd, struct erase_info *instr);
 
 	/* This stuff for eXecute-In-Place */
-	int (*point) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char **mtdbuf);
+	/* phys is optional and may be set to NULL */
+	int (*point) (struct mtd_info *mtd, loff_t from, size_t len,
+			size_t *retlen, void **virt, phys_addr_t *phys);
 
 	/* We probably shouldn't allow XIP if the unpoint isn't a NULL */
-	void (*unpoint) (struct mtd_info *mtd, u_char * addr, loff_t from, size_t len);
+	void (*unpoint) (struct mtd_info *mtd, loff_t from, size_t len);
 
 
 	int (*read) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
 	int (*write) (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf);
 
-	int (*read_ecc) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf, u_char *eccbuf, struct nand_oobinfo *oobsel);
-	int (*write_ecc) (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf, u_char *eccbuf, struct nand_oobinfo *oobsel);
+	/* In blackbox flight recorder like scenarios we want to make successful
+	   writes in interrupt context. panic_write() is only intended to be
+	   called when its known the kernel is about to panic and we need the
+	   write to succeed. Since the kernel is not going to be running for much
+	   longer, this function can break locks and delay to ensure the write
+	   succeeds (but not sleep). */
 
-	int (*read_oob) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
-	int (*write_oob) (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf);
+	int (*panic_write) (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf);
+
+	int (*read_oob) (struct mtd_info *mtd, loff_t from,
+			 struct mtd_oob_ops *ops);
+	int (*write_oob) (struct mtd_info *mtd, loff_t to,
+			 struct mtd_oob_ops *ops);
 
 	/*
 	 * Methods to access the protection register area, present in some
 	 * flash devices. The user data is one time programmable but the
 	 * factory data is read only.
 	 */
-	int (*read_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
-
+	int (*get_fact_prot_info) (struct mtd_info *mtd, struct otp_info *buf, size_t len);
 	int (*read_fact_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
-
-	/* This function is not yet implemented */
+	int (*get_user_prot_info) (struct mtd_info *mtd, struct otp_info *buf, size_t len);
+	int (*read_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
 	int (*write_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
+	int (*lock_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len);
+
+/* XXX U-BOOT XXX */
 #if 0
-	/* kvec-based read/write methods. We need these especially for NAND flash,
-	   with its limited number of write cycles per erase.
+	/* kvec-based read/write methods.
 	   NB: The 'count' parameter is the number of _vectors_, each of
 	   which contains an (ofs, len) tuple.
 	*/
-	int (*readv) (struct mtd_info *mtd, struct kvec *vecs, unsigned long count, loff_t from, size_t *retlen);
-	int (*readv_ecc) (struct mtd_info *mtd, struct kvec *vecs, unsigned long count, loff_t from,
-		size_t *retlen, u_char *eccbuf, struct nand_oobinfo *oobsel);
 	int (*writev) (struct mtd_info *mtd, const struct kvec *vecs, unsigned long count, loff_t to, size_t *retlen);
-	int (*writev_ecc) (struct mtd_info *mtd, const struct kvec *vecs, unsigned long count, loff_t to,
-		size_t *retlen, u_char *eccbuf, struct nand_oobinfo *oobsel);
 #endif
+
 	/* Sync */
 	void (*sync) (struct mtd_info *mtd);
-#if 0
+
 	/* Chip-supported device locking */
 	int (*lock) (struct mtd_info *mtd, loff_t ofs, size_t len);
 	int (*unlock) (struct mtd_info *mtd, loff_t ofs, size_t len);
@@ -129,15 +208,32 @@ struct mtd_info {
 	/* Power Management functions */
 	int (*suspend) (struct mtd_info *mtd);
 	void (*resume) (struct mtd_info *mtd);
-#endif
+
 	/* Bad block management functions */
 	int (*block_isbad) (struct mtd_info *mtd, loff_t ofs);
 	int (*block_markbad) (struct mtd_info *mtd, loff_t ofs);
 
+/* XXX U-BOOT XXX */
+#if 0
+	struct notifier_block reboot_notifier;  /* default mode before reboot */
+#endif
+
+	/* ECC status information */
+	struct mtd_ecc_stats ecc_stats;
+	/* Subpage shift (NAND) */
+	int subpage_sft;
+
 	void *priv;
 
 	struct module *owner;
 	int usecount;
+
+	/* If the driver is something smart, like UBI, it may need to maintain
+	 * its own reference counting. The below functions are only for driver.
+	 * The driver may register its callbacks. These callbacks are not
+	 * supposed to be called by MTD users */
+	int (*get_device) (struct mtd_info *mtd);
+	void (*put_device) (struct mtd_info *mtd);
 };
 
 
@@ -147,9 +243,11 @@ extern int add_mtd_device(struct mtd_info *mtd);
 extern int del_mtd_device (struct mtd_info *mtd);
 
 extern struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num);
+extern struct mtd_info *get_mtd_device_nm(const char *name);
 
 extern void put_mtd_device(struct mtd_info *mtd);
 
+/* XXX U-BOOT XXX */
 #if 0
 struct mtd_notifier {
 	void (*add)(struct mtd_info *mtd);
@@ -157,7 +255,6 @@ struct mtd_notifier {
 	struct list_head list;
 };
 
-
 extern void register_mtd_user (struct mtd_notifier *new);
 extern int unregister_mtd_user (struct mtd_notifier *old);
 
@@ -168,20 +265,6 @@ int default_mtd_readv(struct mtd_info *mtd, struct kvec *vecs,
 		      unsigned long count, loff_t from, size_t *retlen);
 #endif
 
-#define MTD_ERASE(mtd, args...) (*(mtd->erase))(mtd, args)
-#define MTD_POINT(mtd, a,b,c,d) (*(mtd->point))(mtd, a,b,c, (u_char **)(d))
-#define MTD_UNPOINT(mtd, arg) (*(mtd->unpoint))(mtd, (u_char *)arg)
-#define MTD_READ(mtd, args...) (*(mtd->read))(mtd, args)
-#define MTD_WRITE(mtd, args...) (*(mtd->write))(mtd, args)
-#define MTD_READV(mtd, args...) (*(mtd->readv))(mtd, args)
-#define MTD_WRITEV(mtd, args...) (*(mtd->writev))(mtd, args)
-#define MTD_READECC(mtd, args...) (*(mtd->read_ecc))(mtd, args)
-#define MTD_WRITEECC(mtd, args...) (*(mtd->write_ecc))(mtd, args)
-#define MTD_READOOB(mtd, args...) (*(mtd->read_oob))(mtd, args)
-#define MTD_WRITEOOB(mtd, args...) (*(mtd->write_oob))(mtd, args)
-#define MTD_SYNC(mtd) do { if (mtd->sync) (*(mtd->sync))(mtd);  } while (0)
-
-
 #ifdef CONFIG_MTD_PARTITIONS
 void mtd_erase_callback(struct erase_info *instr);
 #else
@@ -207,8 +290,11 @@ static inline void mtd_erase_callback(struct erase_info *instr)
 			printk(KERN_INFO args);		\
 	} while(0)
 #else /* CONFIG_MTD_DEBUG */
-#define MTDDEBUG(n, args...) do { } while(0)
-
+#define MTDDEBUG(n, args...)				\
+	do {						\
+		if (0)					\
+			printk(KERN_INFO args);		\
+	} while(0)
 #endif /* CONFIG_MTD_DEBUG */
 
 #endif /* __MTD_MTD_H__ */
diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index e2a25a6..a4ad571 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -1,115 +1,118 @@
 /*
  *  linux/include/linux/mtd/nand.h
  *
- *  Copyright (c) 2000 David Woodhouse <dwmw2@mvhi.com>
- *		       Steven J. Hill <sjhill@realitydiluted.com>
+ *  Copyright (c) 2000 David Woodhouse <dwmw2@infradead.org>
+ *                     Steven J. Hill <sjhill@realitydiluted.com>
  *		       Thomas Gleixner <tglx@linutronix.de>
  *
- * $Id: nand.h,v 1.68 2004/11/12 10:40:37 gleixner Exp $
- *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  *
- *  Info:
- *   Contains standard defines and IDs for NAND flash devices
- *
- *  Changelog:
- *   01-31-2000 DMW	Created
- *   09-18-2000 SJH	Moved structure out of the Disk-On-Chip drivers
- *			so it can be used by other NAND flash device
- *			drivers. I also changed the copyright since none
- *			of the original contents of this file are specific
- *			to DoC devices. David can whack me with a baseball
- *			bat later if I did something naughty.
- *   10-11-2000 SJH	Added private NAND flash structure for driver
- *   10-24-2000 SJH	Added prototype for 'nand_scan' function
- *   10-29-2001 TG	changed nand_chip structure to support
- *			hardwarespecific function for accessing control lines
- *   02-21-2002 TG	added support for different read/write adress and
- *			ready/busy line access function
- *   02-26-2002 TG	added chip_delay to nand_chip structure to optimize
- *			command delay times for different chips
- *   04-28-2002 TG	OOB config defines moved from nand.c to avoid duplicate
- *			defines in jffs2/wbuf.c
- *   08-07-2002 TG	forced bad block location to byte 5 of OOB, even if
- *			CONFIG_MTD_NAND_ECC_JFFS2 is not set
- *   08-10-2002 TG	extensions to nand_chip structure to support HW-ECC
- *
- *   08-29-2002 tglx	nand_chip structure: data_poi for selecting
- *			internal / fs-driver buffer
- *			support for 6byte/512byte hardware ECC
- *			read_ecc, write_ecc extended for different oob-layout
- *			oob layout selections: NAND_NONE_OOB, NAND_JFFS2_OOB,
- *			NAND_YAFFS_OOB
- *  11-25-2002 tglx	Added Manufacturer code FUJITSU, NATIONAL
- *			Split manufacturer and device ID structures
+ * Info:
+ *	Contains standard defines and IDs for NAND flash devices
  *
- *  02-08-2004 tglx	added option field to nand structure for chip anomalities
- *  05-25-2004 tglx	added bad block table support, ST-MICRO manufacturer id
- *			update of nand_chip structure description
+ * Changelog:
+ *	See git changelog.
  */
 #ifndef __LINUX_MTD_NAND_H
 #define __LINUX_MTD_NAND_H
 
-#include <linux/mtd/compat.h>
+/* XXX U-BOOT XXX */
+#if 0
+#include <linux/wait.h>
+#include <linux/spinlock.h>
 #include <linux/mtd/mtd.h>
+#endif
+
+#include "config.h"
+
+#include "linux/mtd/compat.h"
+#include "linux/mtd/mtd.h"
+#include "linux/mtd/bbm.h"
+
 
 struct mtd_info;
 /* Scan and identify a NAND device */
 extern int nand_scan (struct mtd_info *mtd, int max_chips);
+/* Separate phases of nand_scan(), allowing board driver to intervene
+ * and override command or ECC setup according to flash type */
+extern int nand_scan_ident(struct mtd_info *mtd, int max_chips);
+extern int nand_scan_tail(struct mtd_info *mtd);
+
 /* Free resources held by the NAND device */
 extern void nand_release (struct mtd_info *mtd);
 
-/* Read raw data from the device without ECC */
-extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_t len, size_t ooblen);
-
+/* Internal helper for board drivers which need to override command function */
+extern void nand_wait_ready(struct mtd_info *mtd);
 
 /* This constant declares the max. oobsize / page, which
  * is supported now. If you add a chip with bigger oobsize/page
  * adjust this accordingly.
  */
-#define NAND_MAX_OOBSIZE	64
+#define NAND_MAX_OOBSIZE	128
+#define NAND_MAX_PAGESIZE	4096
 
 /*
  * Constants for hardware specific CLE/ALE/NCE function
-*/
+ *
+ * These are bits which can be or'ed to set/clear multiple
+ * bits in one go.
+ */
 /* Select the chip by setting nCE to low */
-#define NAND_CTL_SETNCE		1
-/* Deselect the chip by setting nCE to high */
-#define NAND_CTL_CLRNCE		2
+#define NAND_NCE		0x01
 /* Select the command latch by setting CLE to high */
-#define NAND_CTL_SETCLE		3
-/* Deselect the command latch by setting CLE to low */
-#define NAND_CTL_CLRCLE		4
+#define NAND_CLE		0x02
 /* Select the address latch by setting ALE to high */
-#define NAND_CTL_SETALE		5
-/* Deselect the address latch by setting ALE to low */
-#define NAND_CTL_CLRALE		6
-/* Set write protection by setting WP to high. Not used! */
-#define NAND_CTL_SETWP		7
-/* Clear write protection by setting WP to low. Not used! */
-#define NAND_CTL_CLRWP		8
+#define NAND_ALE		0x04
+
+#define NAND_CTRL_CLE		(NAND_NCE | NAND_CLE)
+#define NAND_CTRL_ALE		(NAND_NCE | NAND_ALE)
+#define NAND_CTRL_CHANGE	0x80
 
 /*
  * Standard NAND flash commands
  */
 #define NAND_CMD_READ0		0
 #define NAND_CMD_READ1		1
+#define NAND_CMD_RNDOUT		5
 #define NAND_CMD_PAGEPROG	0x10
 #define NAND_CMD_READOOB	0x50
 #define NAND_CMD_ERASE1		0x60
 #define NAND_CMD_STATUS		0x70
 #define NAND_CMD_STATUS_MULTI	0x71
 #define NAND_CMD_SEQIN		0x80
+#define NAND_CMD_RNDIN		0x85
 #define NAND_CMD_READID		0x90
 #define NAND_CMD_ERASE2		0xd0
 #define NAND_CMD_RESET		0xff
 
 /* Extended commands for large page devices */
 #define NAND_CMD_READSTART	0x30
+#define NAND_CMD_RNDOUTSTART	0xE0
 #define NAND_CMD_CACHEDPROG	0x15
 
+/* Extended commands for AG-AND device */
+/*
+ * Note: the command for NAND_CMD_DEPLETE1 is really 0x00 but
+ *       there is no way to distinguish that from NAND_CMD_READ0
+ *       until the remaining sequence of commands has been completed
+ *       so add a high order bit and mask it off in the command.
+ */
+#define NAND_CMD_DEPLETE1	0x100
+#define NAND_CMD_DEPLETE2	0x38
+#define NAND_CMD_STATUS_MULTI	0x71
+#define NAND_CMD_STATUS_ERROR	0x72
+/* multi-bank error status (banks 0-3) */
+#define NAND_CMD_STATUS_ERROR0	0x73
+#define NAND_CMD_STATUS_ERROR1	0x74
+#define NAND_CMD_STATUS_ERROR2	0x75
+#define NAND_CMD_STATUS_ERROR3	0x76
+#define NAND_CMD_STATUS_RESET	0x7f
+#define NAND_CMD_STATUS_CLEAR	0xff
+
+#define NAND_CMD_NONE		-1
+
 /* Status bits */
 #define NAND_STATUS_FAIL	0x01
 #define NAND_STATUS_FAIL_N1	0x02
@@ -120,25 +123,16 @@ extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_
 /*
  * Constants for ECC_MODES
  */
-
-/* No ECC. Usage is not recommended ! */
-#define NAND_ECC_NONE		0
-/* Software ECC 3 byte ECC per 256 Byte data */
-#define NAND_ECC_SOFT		1
-/* Hardware ECC 3 byte ECC per 256 Byte data */
-#define NAND_ECC_HW3_256	2
-/* Hardware ECC 3 byte ECC per 512 Byte data */
-#define NAND_ECC_HW3_512	3
-/* Hardware ECC 6 byte ECC per 512 Byte data */
-#define NAND_ECC_HW6_512	4
-/* Hardware ECC 8 byte ECC per 512 Byte data */
-#define NAND_ECC_HW8_512	6
-/* Hardware ECC 12 byte ECC per 2048 Byte data */
-#define NAND_ECC_HW12_2048	7
+typedef enum {
+	NAND_ECC_NONE,
+	NAND_ECC_SOFT,
+	NAND_ECC_HW,
+	NAND_ECC_HW_SYNDROME,
+} nand_ecc_modes_t;
 
 /*
  * Constants for Hardware ECC
-*/
+ */
 /* Reset Hardware ECC for read */
 #define NAND_ECC_READ		0
 /* Reset Hardware ECC for write */
@@ -146,6 +140,10 @@ extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_
 /* Enable Hardware ECC before syndrom is read back from flash */
 #define NAND_ECC_READSYN	2
 
+/* Bit mask for flags passed to do_nand_read_ecc */
+#define NAND_GET_DEVICE		0x80
+
+
 /* Option constants for bizarre disfunctionality and real
 *  features
 */
@@ -165,6 +163,17 @@ extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_
 /* Chip has a array of 4 pages which can be read without
  * additional ready /busy waits */
 #define NAND_4PAGE_ARRAY	0x00000040
+/* Chip requires that BBT is periodically rewritten to prevent
+ * bits from adjacent blocks from 'leaking' in altering data.
+ * This happens with the Renesas AG-AND chips, possibly others.  */
+#define BBT_AUTO_REFRESH	0x00000080
+/* Chip does not require ready check on read. True
+ * for all large page devices, as they do not support
+ * autoincrement.*/
+#define NAND_NO_READRDY		0x00000100
+/* Chip does not allow subpage writes */
+#define NAND_NO_SUBPAGE_WRITE	0x00000200
+
 
 /* Options valid for Samsung large page devices */
 #define NAND_SAMSUNG_LP_OPTIONS \
@@ -175,6 +184,9 @@ extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_
 #define NAND_MUST_PAD(chip) (!(chip->options & NAND_NO_PADDING))
 #define NAND_HAS_CACHEPROG(chip) ((chip->options & NAND_CACHEPRG))
 #define NAND_HAS_COPYBACK(chip) ((chip->options & NAND_COPYBACK))
+/* Large page NAND with SOFT_ECC should support subpage reads */
+#define NAND_SUBPAGE_READ(chip) ((chip->ecc.mode == NAND_ECC_SOFT) \
+					&& (chip->page_shift > 9))
 
 /* Mask to zero out the chip options, which come from the id table */
 #define NAND_CHIPOPTIONS_MSK	(0x0000ffff & ~NAND_NO_AUTOINCR)
@@ -183,159 +195,233 @@ extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_
 /* Use a flash based bad block table. This option is passed to the
  * default bad block table function. */
 #define NAND_USE_FLASH_BBT	0x00010000
-/* The hw ecc generator provides a syndrome instead a ecc value on read
- * This can only work if we have the ecc bytes directly behind the
- * data bytes. Applies for DOC and AG-AND Renesas HW Reed Solomon generators */
-#define NAND_HWECC_SYNDROME	0x00020000
-
-
+/* This option skips the bbt scan during initialization. */
+#define NAND_SKIP_BBTSCAN	0x00020000
+/* This option is defined if the board driver allocates its own buffers
+   (e.g. because it needs them DMA-coherent */
+#define NAND_OWN_BUFFERS	0x00040000
 /* Options set by nand scan */
-/* Nand scan has allocated oob_buf */
-#define NAND_OOBBUF_ALLOC	0x40000000
-/* Nand scan has allocated data_buf */
-#define NAND_DATABUF_ALLOC	0x80000000
+/* bbt has already been read */
+#define NAND_BBT_SCANNED	0x40000000
+/* Nand scan has allocated controller struct */
+#define NAND_CONTROLLER_ALLOC	0x80000000
 
-
-/*
- * nand_state_t - chip states
- * Enumeration for NAND flash chip state
- */
-typedef enum {
-	FL_READY,
-	FL_READING,
-	FL_WRITING,
-	FL_ERASING,
-	FL_SYNCING,
-	FL_CACHEDPRG,
-} nand_state_t;
+/* Cell info constants */
+#define NAND_CI_CHIPNR_MSK	0x03
+#define NAND_CI_CELLTYPE_MSK	0x0C
 
 /* Keep gcc happy */
 struct nand_chip;
 
-#if 0
 /**
- * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independend devices
- * @lock:		protection lock
+ * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independent devices
+ * @lock:               protection lock
  * @active:		the mtd device which holds the controller currently
+ * @wq:			wait queue to sleep on if a NAND operation is in progress
+ *                      used instead of the per chip wait queue when a hw controller is available
  */
 struct nand_hw_control {
+/* XXX U-BOOT XXX */
+#if 0
 	spinlock_t	 lock;
+	wait_queue_head_t wq;
+#endif
 	struct nand_chip *active;
 };
-#endif
+
+/**
+ * struct nand_ecc_ctrl - Control structure for ecc
+ * @mode:	ecc mode
+ * @steps:	number of ecc steps per page
+ * @size:	data bytes per ecc step
+ * @bytes:	ecc bytes per step
+ * @total:	total number of ecc bytes per page
+ * @prepad:	padding information for syndrome based ecc generators
+ * @postpad:	padding information for syndrome based ecc generators
+ * @layout:	ECC layout control struct pointer
+ * @hwctl:	function to control hardware ecc generator. Must only
+ *		be provided if an hardware ECC is available
+ * @calculate:	function for ecc calculation or readback from ecc hardware
+ * @correct:	function for ecc correction, matching to ecc generator (sw/hw)
+ * @read_page_raw:	function to read a raw page without ECC
+ * @write_page_raw:	function to write a raw page without ECC
+ * @read_page:	function to read a page according to the ecc generator requirements
+ * @write_page:	function to write a page according to the ecc generator requirements
+ * @read_oob:	function to read chip OOB data
+ * @write_oob:	function to write chip OOB data
+ */
+struct nand_ecc_ctrl {
+	nand_ecc_modes_t	mode;
+	int			steps;
+	int			size;
+	int			bytes;
+	int			total;
+	int			prepad;
+	int			postpad;
+	struct nand_ecclayout	*layout;
+	void			(*hwctl)(struct mtd_info *mtd, int mode);
+	int			(*calculate)(struct mtd_info *mtd,
+					     const uint8_t *dat,
+					     uint8_t *ecc_code);
+	int			(*correct)(struct mtd_info *mtd, uint8_t *dat,
+					   uint8_t *read_ecc,
+					   uint8_t *calc_ecc);
+	int			(*read_page_raw)(struct mtd_info *mtd,
+						 struct nand_chip *chip,
+						 uint8_t *buf);
+	void			(*write_page_raw)(struct mtd_info *mtd,
+						  struct nand_chip *chip,
+						  const uint8_t *buf);
+	int			(*read_page)(struct mtd_info *mtd,
+					     struct nand_chip *chip,
+					     uint8_t *buf);
+	int			(*read_subpage)(struct mtd_info *mtd,
+					     struct nand_chip *chip,
+					     uint32_t offs, uint32_t len,
+					     uint8_t *buf);
+	void			(*write_page)(struct mtd_info *mtd,
+					      struct nand_chip *chip,
+					      const uint8_t *buf);
+	int			(*read_oob)(struct mtd_info *mtd,
+					    struct nand_chip *chip,
+					    int page,
+					    int sndcmd);
+	int			(*write_oob)(struct mtd_info *mtd,
+					     struct nand_chip *chip,
+					     int page);
+};
+
+/**
+ * struct nand_buffers - buffer structure for read/write
+ * @ecccalc:	buffer for calculated ecc
+ * @ecccode:	buffer for ecc read from flash
+ * @databuf:	buffer for data - dynamically sized
+ *
+ * Do not change the order of buffers. databuf and oobrbuf must be in
+ * consecutive order.
+ */
+struct nand_buffers {
+	uint8_t	ecccalc[NAND_MAX_OOBSIZE];
+	uint8_t	ecccode[NAND_MAX_OOBSIZE];
+	uint8_t databuf[NAND_MAX_PAGESIZE + NAND_MAX_OOBSIZE];
+};
 
 /**
  * struct nand_chip - NAND Private Flash Chip Data
  * @IO_ADDR_R:		[BOARDSPECIFIC] address to read the 8 I/O lines of the flash device
  * @IO_ADDR_W:		[BOARDSPECIFIC] address to write the 8 I/O lines of the flash device
  * @read_byte:		[REPLACEABLE] read one byte from the chip
- * @write_byte:		[REPLACEABLE] write one byte to the chip
  * @read_word:		[REPLACEABLE] read one word from the chip
- * @write_word:		[REPLACEABLE] write one word to the chip
  * @write_buf:		[REPLACEABLE] write data from the buffer to the chip
  * @read_buf:		[REPLACEABLE] read data from the chip into the buffer
  * @verify_buf:		[REPLACEABLE] verify buffer contents against the chip data
  * @select_chip:	[REPLACEABLE] select chip nr
  * @block_bad:		[REPLACEABLE] check, if the block is bad
  * @block_markbad:	[REPLACEABLE] mark the block bad
- * @hwcontrol:		[BOARDSPECIFIC] hardwarespecific function for accesing control-lines
+ * @cmd_ctrl:		[BOARDSPECIFIC] hardwarespecific funtion for controlling
+ *			ALE/CLE/nCE. Also used to write command and address
  * @dev_ready:		[BOARDSPECIFIC] hardwarespecific function for accesing device ready/busy line
  *			If set to NULL no access to ready/busy is available and the ready/busy information
  *			is read from the chip status register
  * @cmdfunc:		[REPLACEABLE] hardwarespecific function for writing commands to the chip
  * @waitfunc:		[REPLACEABLE] hardwarespecific function for wait on ready
- * @calculate_ecc:	[REPLACEABLE] function for ecc calculation or readback from ecc hardware
- * @correct_data:	[REPLACEABLE] function for ecc correction, matching to ecc generator (sw/hw)
- * @enable_hwecc:	[BOARDSPECIFIC] function to enable (reset) hardware ecc generator. Must only
- *			be provided if a hardware ECC is available
+ * @ecc:		[BOARDSPECIFIC] ecc control ctructure
+ * @buffers:		buffer structure for read/write
+ * @hwcontrol:		platform-specific hardware control structure
+ * @ops:		oob operation operands
  * @erase_cmd:		[INTERN] erase command write function, selectable due to AND support
  * @scan_bbt:		[REPLACEABLE] function to scan bad block table
- * @eccmode:		[BOARDSPECIFIC] mode of ecc, see defines
- * @eccsize:		[INTERN] databytes used per ecc-calculation
- * @eccbytes:		[INTERN] number of ecc bytes per ecc-calculation step
- * @eccsteps:		[INTERN] number of ecc calculation steps per page
  * @chip_delay:		[BOARDSPECIFIC] chip dependent delay for transfering data from array to read regs (tR)
- * @chip_lock:		[INTERN] spinlock used to protect access to this structure and the chip
  * @wq:			[INTERN] wait queue to sleep on if a NAND operation is in progress
  * @state:		[INTERN] the current state of the NAND device
+ * @oob_poi:		poison value buffer
  * @page_shift:		[INTERN] number of address bits in a page (column address bits)
  * @phys_erase_shift:	[INTERN] number of address bits in a physical eraseblock
  * @bbt_erase_shift:	[INTERN] number of address bits in a bbt entry
  * @chip_shift:		[INTERN] number of address bits in one chip
- * @data_buf:		[INTERN] internal buffer for one page + oob
- * @oob_buf:		[INTERN] oob buffer for one eraseblock
+ * @datbuf:		[INTERN] internal buffer for one page + oob
+ * @oobbuf:		[INTERN] oob buffer for one eraseblock
  * @oobdirty:		[INTERN] indicates that oob_buf must be reinitialized
  * @data_poi:		[INTERN] pointer to a data buffer
  * @options:		[BOARDSPECIFIC] various chip options. They can partly be set to inform nand_scan about
  *			special functionality. See the defines for further explanation
  * @badblockpos:	[INTERN] position of the bad block marker in the oob area
+ * @cellinfo:		[INTERN] MLC/multichip data from chip ident
  * @numchips:		[INTERN] number of physical chips
  * @chipsize:		[INTERN] the size of one chip for multichip arrays
  * @pagemask:		[INTERN] page number mask = number of (pages / chip) - 1
  * @pagebuf:		[INTERN] holds the pagenumber which is currently in data_buf
- * @autooob:		[REPLACEABLE] the default (auto)placement scheme
+ * @subpagesize:	[INTERN] holds the subpagesize
+ * @ecclayout:		[REPLACEABLE] the default ecc placement scheme
  * @bbt:		[INTERN] bad block table pointer
  * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash lookup
  * @bbt_md:		[REPLACEABLE] bad block table mirror descriptor
  * @badblock_pattern:	[REPLACEABLE] bad block scan pattern used for initial bad block scan
- * @controller:		[OPTIONAL] a pointer to a hardware controller structure which is shared among multiple independend devices
+ * @controller:		[REPLACEABLE] a pointer to a hardware controller structure
+ *			which is shared among multiple independend devices
  * @priv:		[OPTIONAL] pointer to private chip date
+ * @errstat:		[OPTIONAL] hardware specific function to perform additional error status checks
+ *			(determine if errors are correctable)
+ * @write_page:		[REPLACEABLE] High-level page write function
  */
 
 struct nand_chip {
 	void  __iomem	*IO_ADDR_R;
 	void  __iomem	*IO_ADDR_W;
 
-	u_char		(*read_byte)(struct mtd_info *mtd);
-	void		(*write_byte)(struct mtd_info *mtd, u_char byte);
+	uint8_t		(*read_byte)(struct mtd_info *mtd);
 	u16		(*read_word)(struct mtd_info *mtd);
-	void		(*write_word)(struct mtd_info *mtd, u16 word);
-
-	void		(*write_buf)(struct mtd_info *mtd, const u_char *buf, int len);
-	void		(*read_buf)(struct mtd_info *mtd, u_char *buf, int len);
-	int		(*verify_buf)(struct mtd_info *mtd, const u_char *buf, int len);
+	void		(*write_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
+	void		(*read_buf)(struct mtd_info *mtd, uint8_t *buf, int len);
+	int		(*verify_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
 	void		(*select_chip)(struct mtd_info *mtd, int chip);
 	int		(*block_bad)(struct mtd_info *mtd, loff_t ofs, int getchip);
 	int		(*block_markbad)(struct mtd_info *mtd, loff_t ofs);
-	void		(*hwcontrol)(struct mtd_info *mtd, int cmd);
+	void		(*cmd_ctrl)(struct mtd_info *mtd, int dat,
+				    unsigned int ctrl);
 	int		(*dev_ready)(struct mtd_info *mtd);
 	void		(*cmdfunc)(struct mtd_info *mtd, unsigned command, int column, int page_addr);
-	int		(*waitfunc)(struct mtd_info *mtd, struct nand_chip *this, int state);
-	int		(*calculate_ecc)(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code);
-	int		(*correct_data)(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc);
-	void		(*enable_hwecc)(struct mtd_info *mtd, int mode);
+	int		(*waitfunc)(struct mtd_info *mtd, struct nand_chip *this);
 	void		(*erase_cmd)(struct mtd_info *mtd, int page);
 	int		(*scan_bbt)(struct mtd_info *mtd);
-	int		eccmode;
-	int		eccsize;
-	int		eccbytes;
-	int		eccsteps;
+	int		(*errstat)(struct mtd_info *mtd, struct nand_chip *this, int state, int status, int page);
+	int		(*write_page)(struct mtd_info *mtd, struct nand_chip *chip,
+				      const uint8_t *buf, int page, int cached, int raw);
+
 	int		chip_delay;
-#if 0
-	spinlock_t	chip_lock;
-	wait_queue_head_t wq;
-	nand_state_t	state;
-#endif
+	unsigned int	options;
+
 	int		page_shift;
 	int		phys_erase_shift;
 	int		bbt_erase_shift;
 	int		chip_shift;
-	u_char		*data_buf;
-	u_char		*oob_buf;
-	int		oobdirty;
-	u_char		*data_poi;
-	unsigned int	options;
-	int		badblockpos;
 	int		numchips;
 	unsigned long	chipsize;
 	int		pagemask;
 	int		pagebuf;
-	struct nand_oobinfo	*autooob;
+	int		subpagesize;
+	uint8_t		cellinfo;
+	int		badblockpos;
+
+	int 		state;
+
+	uint8_t		*oob_poi;
+	struct nand_hw_control  *controller;
+	struct nand_ecclayout	*ecclayout;
+
+	struct nand_ecc_ctrl ecc;
+	struct nand_buffers *buffers;
+
+	struct nand_hw_control hwcontrol;
+
+	struct mtd_oob_ops ops;
+
 	uint8_t		*bbt;
 	struct nand_bbt_descr	*bbt_td;
 	struct nand_bbt_descr	*bbt_md;
+
 	struct nand_bbt_descr	*badblock_pattern;
-	struct nand_hw_control	*controller;
+
 	void		*priv;
 };
 
@@ -348,11 +434,12 @@ struct nand_chip {
 #define NAND_MFR_NATIONAL	0x8f
 #define NAND_MFR_RENESAS	0x07
 #define NAND_MFR_STMICRO	0x20
+#define NAND_MFR_HYNIX		0xad
 #define NAND_MFR_MICRON		0x2c
+#define NAND_MFR_AMD		0x01
 
 /**
  * struct nand_flash_dev - NAND Flash Device ID Structure
- *
  * @name:	Identify the device type
  * @id:		device ID code
  * @pagesize:	Pagesize in bytes. Either 256 or 512 or 0
@@ -385,89 +472,82 @@ struct nand_manufacturers {
 extern struct nand_flash_dev nand_flash_ids[];
 extern struct nand_manufacturers nand_manuf_ids[];
 
-#ifndef NAND_MAX_CHIPS
-#define NAND_MAX_CHIPS 8
-#endif
+extern int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd);
+extern int nand_update_bbt(struct mtd_info *mtd, loff_t offs);
+extern int nand_default_bbt(struct mtd_info *mtd);
+extern int nand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt);
+extern int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
+			   int allowbbt);
+extern int nand_do_read(struct mtd_info *mtd, loff_t from, size_t len,
+			size_t * retlen, uint8_t * buf);
+
+/*
+* Constants for oob configuration
+*/
+#define NAND_SMALL_BADBLOCK_POS		5
+#define NAND_LARGE_BADBLOCK_POS		0
 
 /**
- * struct nand_bbt_descr - bad block table descriptor
- * @options:	options for this descriptor
- * @pages:	the page(s) where we find the bbt, used with option BBT_ABSPAGE
- *		when bbt is searched, then we store the found bbts pages here.
- *		Its an array and supports up to 8 chips now
- * @offs:	offset of the pattern in the oob area of the page
- * @veroffs:	offset of the bbt version counter in the oob are of the page
- * @version:	version read from the bbt page during scan
- * @len:	length of the pattern, if 0 no pattern check is performed
- * @maxblocks:	maximum number of blocks to search for a bbt. This number of
- *		blocks is reserved at the end of the device where the tables are
- *		written.
- * @reserved_block_code: if non-0, this pattern denotes a reserved (rather than
- *		bad) block in the stored bbt
- * @pattern:	pattern to identify bad block table or factory marked good /
- *		bad blocks, can be NULL, if len = 0
+ * struct platform_nand_chip - chip level device structure
+ * @nr_chips:		max. number of chips to scan for
+ * @chip_offset:	chip number offset
+ * @nr_partitions:	number of partitions pointed to by partitions (or zero)
+ * @partitions:		mtd partition list
+ * @chip_delay:		R/B delay value in us
+ * @options:		Option flags, e.g. 16bit buswidth
+ * @ecclayout:		ecc layout info structure
+ * @part_probe_types:	NULL-terminated array of probe types
+ * @priv:		hardware controller specific settings
+ */
+struct platform_nand_chip {
+	int			nr_chips;
+	int			chip_offset;
+	int			nr_partitions;
+	struct mtd_partition	*partitions;
+	struct nand_ecclayout	*ecclayout;
+	int			chip_delay;
+	unsigned int		options;
+	const char		**part_probe_types;
+	void			*priv;
+};
+
+/**
+ * struct platform_nand_ctrl - controller level device structure
+ * @hwcontrol:		platform specific hardware control structure
+ * @dev_ready:		platform specific function to read ready/busy pin
+ * @select_chip:	platform specific chip select function
+ * @cmd_ctrl:		platform specific function for controlling
+ *			ALE/CLE/nCE. Also used to write command and address
+ * @priv:		private data to transport driver specific settings
  *
- * Descriptor for the bad block table marker and the descriptor for the
- * pattern which identifies good and bad blocks. The assumption is made
- * that the pattern and the version count are always located in the oob area
- * of the first block.
+ * All fields are optional and depend on the hardware driver requirements
+ */
+struct platform_nand_ctrl {
+	void		(*hwcontrol)(struct mtd_info *mtd, int cmd);
+	int		(*dev_ready)(struct mtd_info *mtd);
+	void		(*select_chip)(struct mtd_info *mtd, int chip);
+	void		(*cmd_ctrl)(struct mtd_info *mtd, int dat,
+				    unsigned int ctrl);
+	void		*priv;
+};
+
+/**
+ * struct platform_nand_data - container structure for platform-specific data
+ * @chip:		chip level chip structure
+ * @ctrl:		controller level device structure
  */
-struct nand_bbt_descr {
-	int	options;
-	int	pages[NAND_MAX_CHIPS];
-	int	offs;
-	int	veroffs;
-	uint8_t version[NAND_MAX_CHIPS];
-	int	len;
-	int	maxblocks;
-	int	reserved_block_code;
-	uint8_t *pattern;
+struct platform_nand_data {
+	struct platform_nand_chip	chip;
+	struct platform_nand_ctrl	ctrl;
 };
 
-/* Options for the bad block table descriptors */
-
-/* The number of bits used per block in the bbt on the device */
-#define NAND_BBT_NRBITS_MSK	0x0000000F
-#define NAND_BBT_1BIT		0x00000001
-#define NAND_BBT_2BIT		0x00000002
-#define NAND_BBT_4BIT		0x00000004
-#define NAND_BBT_8BIT		0x00000008
-/* The bad block table is in the last good block of the device */
-#define NAND_BBT_LASTBLOCK	0x00000010
-/* The bbt is at the given page, else we must scan for the bbt */
-#define NAND_BBT_ABSPAGE	0x00000020
-/* The bbt is at the given page, else we must scan for the bbt */
-#define NAND_BBT_SEARCH		0x00000040
-/* bbt is stored per chip on multichip devices */
-#define NAND_BBT_PERCHIP	0x00000080
-/* bbt has a version counter at offset veroffs */
-#define NAND_BBT_VERSION	0x00000100
-/* Create a bbt if none axists */
-#define NAND_BBT_CREATE		0x00000200
-/* Search good / bad pattern through all pages of a block */
-#define NAND_BBT_SCANALLPAGES	0x00000400
-/* Scan block empty during good / bad block scan */
-#define NAND_BBT_SCANEMPTY	0x00000800
-/* Write bbt if neccecary */
-#define NAND_BBT_WRITE		0x00001000
-/* Read and write back block contents when writing bbt */
-#define NAND_BBT_SAVECONTENT	0x00002000
-/* Search good / bad pattern on the first and the second page */
-#define NAND_BBT_SCAN2NDPAGE	0x00004000
-
-/* The maximum number of blocks to scan for a bbt */
-#define NAND_BBT_SCAN_MAXBLOCKS 4
-
-extern int nand_scan_bbt (struct mtd_info *mtd, struct nand_bbt_descr *bd);
-extern int nand_update_bbt (struct mtd_info *mtd, loff_t offs);
-extern int nand_default_bbt (struct mtd_info *mtd);
-extern int nand_isbad_bbt (struct mtd_info *mtd, loff_t offs, int allowbbt);
-extern int nand_erase_nand (struct mtd_info *mtd, struct erase_info *instr, int allowbbt);
+/* Some helpers to access the data structures */
+static inline
+struct platform_nand_chip *get_platform_nandchip(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
 
-/*
-* Constants for oob configuration
-*/
-#define NAND_SMALL_BADBLOCK_POS		5
-#define NAND_LARGE_BADBLOCK_POS		0
+	return chip->priv;
+}
 
 #endif /* __LINUX_MTD_NAND_H */
diff --git a/include/nand.h b/include/nand.h
index e1285cd..065a42c 100644
--- a/include/nand.h
+++ b/include/nand.h
@@ -26,11 +26,13 @@
 
 extern void nand_init(void);
 
-#ifndef CFG_NAND_LEGACY
+#ifndef CONFIG_NAND_LEGACY
 #include <linux/mtd/compat.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/nand.h>
 
+extern int board_nand_init(struct nand_chip *nand);
+
 typedef struct mtd_info nand_info_t;
 
 extern int nand_curr_device;
@@ -84,6 +86,7 @@ struct nand_write_options {
 };
 
 typedef struct nand_write_options nand_write_options_t;
+typedef struct mtd_oob_ops mtd_oob_ops_t;
 
 struct nand_read_options {
 	u_char *buffer;		/* memory block in which read image is written*/
@@ -107,9 +110,10 @@ struct nand_erase_options {
 
 typedef struct nand_erase_options nand_erase_options_t;
 
-int nand_write_opts(nand_info_t *meminfo, const nand_write_options_t *opts);
-
-int nand_read_opts(nand_info_t *meminfo, const nand_read_options_t *opts);
+int nand_read_skip_bad(nand_info_t *nand, size_t offset, size_t *length,
+		       u_char *buffer);
+int nand_write_skip_bad(nand_info_t *nand, size_t offset, size_t *length,
+			u_char *buffer);
 int nand_erase_opts(nand_info_t *meminfo, const nand_erase_options_t *opts);
 
 #define NAND_LOCK_STATUS_TIGHT	0x01
@@ -120,9 +124,11 @@ int nand_lock( nand_info_t *meminfo, int tight );
 int nand_unlock( nand_info_t *meminfo, ulong start, ulong length );
 int nand_get_lock_status(nand_info_t *meminfo, ulong offset);
 
-#ifdef CFG_NAND_SELECT_DEVICE
+#ifdef CONFIG_SYS_NAND_SELECT_DEVICE
 void board_nand_select_device(struct nand_chip *nand, int chip);
 #endif
 
-#endif /* !CFG_NAND_LEGACY */
+__attribute__((noreturn)) void nand_boot(void);
+
+#endif /* !CONFIG_NAND_LEGACY */
 #endif
diff --git a/lib_arm/Makefile b/lib_arm/Makefile
index c8795b2..4f477d3 100644
--- a/lib_arm/Makefile
+++ b/lib_arm/Makefile
@@ -37,6 +37,7 @@ COBJS-y	+= bootm.o
 COBJS-y	+= cache.o
 COBJS-y	+= div0.o
 COBJS-y	+= interrupts.o
+COBJS-y	+= muldi3.o
 
 SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
 OBJS	:= $(addprefix $(obj),$(SOBJS-y) $(COBJS-y))
diff --git a/lib_arm/_ashldi3.S b/lib_arm/_ashldi3.S
index de4403d..bc93a5d 100644
--- a/lib_arm/_ashldi3.S
+++ b/lib_arm/_ashldi3.S
@@ -43,4 +43,4 @@ __ashldi3:
 	movpl	ah, al, lsl r3
 	orrmi	ah, ah, al, lsr ip
 	mov	al, al, lsl r2
-	mov	pc, lr
+        bx      lr
diff --git a/lib_arm/_ashrdi3.S b/lib_arm/_ashrdi3.S
index 5edbcb3..5b0dfef 100644
--- a/lib_arm/_ashrdi3.S
+++ b/lib_arm/_ashrdi3.S
@@ -43,4 +43,4 @@ __ashrdi3:
 	movpl	al, ah, asr r3
 	orrmi	al, al, ah, lsl ip
 	mov	ah, ah, asr r2
-	mov	pc, lr
+        bx      lr
diff --git a/lib_arm/_divsi3.S b/lib_arm/_divsi3.S
index 9dc15f6..8b1756e 100644
--- a/lib_arm/_divsi3.S
+++ b/lib_arm/_divsi3.S
@@ -94,7 +94,8 @@
 
 .endm
 
-	.align	5
+	.align 5
+        
 .globl __divsi3
 __divsi3:
 	cmp	r1, #0
@@ -114,23 +115,23 @@ __divsi3:
 
 	cmp	ip, #0
 	rsbmi	r0, r0, #0
-	mov	pc, lr
+        bx      lr
 
 10:	teq	ip, r0				@ same sign ?
 	rsbmi	r0, r0, #0
-	mov	pc, lr
+        bx      lr
 
 11:	movlo	r0, #0
 	moveq	r0, ip, asr #31
 	orreq	r0, r0, #1
-	mov	pc, lr
+        bx      lr
 
 12:	ARM_DIV2_ORDER r1, r2
 
 	cmp	ip, #0
 	mov	r0, r3, lsr r2
 	rsbmi	r0, r0, #0
-	mov	pc, lr
+        bx      lr
 
 Ldiv0:
 
diff --git a/lib_arm/_modsi3.S b/lib_arm/_modsi3.S
index 539c584..ceb5fbf 100644
--- a/lib_arm/_modsi3.S
+++ b/lib_arm/_modsi3.S
@@ -70,6 +70,7 @@
 .endm
 
 	.align	5
+
 .globl __modsi3
 __modsi3:
 	cmp	r1, #0
@@ -88,9 +89,7 @@ __modsi3:
 
 10:	cmp	ip, #0
 	rsbmi	r0, r0, #0
-	mov	pc, lr
-
-
+        bx      lr
 Ldiv0:
 
 	str	lr, [sp, #-4]!
diff --git a/lib_arm/_udivsi3.S b/lib_arm/_udivsi3.S
index a3f9b59..6916384 100644
--- a/lib_arm/_udivsi3.S
+++ b/lib_arm/_udivsi3.S
@@ -61,7 +61,7 @@ Loop3:
 	bne	Loop3
 Lgot_result:
 	mov	r0, result
-	mov	pc, lr
+        bx      lr
 Ldiv0:
 	str	lr, [sp, #-4]!
 	bl	 __div0       (PLT)
diff --git a/lib_arm/_umodsi3.S b/lib_arm/_umodsi3.S
index 8465ef0..c107a9e 100644
--- a/lib_arm/_umodsi3.S
+++ b/lib_arm/_umodsi3.S
@@ -19,7 +19,7 @@ curbit		.req	r3
 	beq	Ldiv0
 	mov	curbit, #1
 	cmp	dividend, divisor
-	movcc	pc, lr
+        bxcc    lr
 Loop1:
 	@ Unless the divisor is very big, shift it up in multiples of
 	@ four bits, since this is the amount of unwinding in the main
@@ -66,14 +66,14 @@ Loop3:
 	@ then none of the below will match, since the bit in ip will not be
 	@ in the bottom nibble.
 	ands	overdone, overdone, #0xe0000000
-	moveq	pc, lr				@ No fixups needed
+        bxeq    lr
 	tst	overdone, ip, ror #3
 	addne	dividend, dividend, divisor, lsr #3
 	tst	overdone, ip, ror #2
 	addne	dividend, dividend, divisor, lsr #2
 	tst	overdone, ip, ror #1
 	addne	dividend, dividend, divisor, lsr #1
-	mov	pc, lr
+        bx      lr
 Ldiv0:
 	str	lr, [sp, #-4]!
 	bl	 __div0       (PLT)
diff --git a/lib_arm/bootm.c b/lib_arm/bootm.c
index 955a1ae..372bdd2 100644
--- a/lib_arm/bootm.c
+++ b/lib_arm/bootm.c
@@ -1,4 +1,6 @@
 /*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
  * (C) Copyright 2002
  * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
  * Marius Groeger <mgroeger@sysgo.de>
@@ -29,6 +31,11 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
+#if defined (CONFIG_PICOCHIP_PC20X)
+/* We need to call this before going to the kernel on PC20X platforms */
+void emac_set_mac_for_addr(u8 *addr);
+#endif
+
 #if defined (CONFIG_SETUP_MEMORY_TAGS) || \
     defined (CONFIG_CMDLINE_TAG) || \
     defined (CONFIG_INITRD_TAG) || \
@@ -106,6 +113,15 @@ void do_bootm_linux (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[],
 
 	debug ("## Transferring control to Linux (at address %08lx) ...\n",
 	       (ulong) theKernel);
+               
+#if defined (CONFIG_PICOCHIP_PC20X)
+    /* We need to setup the MAC address in the ethernet MAC for the PC20X
+     * processors. These processors do not have a MAC storred anywhere.
+     * Also, the kernel driver looks at the setup of the MAC and uses 
+     * any address that is already programmed.
+     */
+    emac_set_mac_for_addr(bd->bi_enetaddr);
+#endif               
 
 #if defined (CONFIG_SETUP_MEMORY_TAGS) || \
     defined (CONFIG_CMDLINE_TAG) || \
diff --git a/lib_arm/muldi3.c b/lib_arm/muldi3.c
new file mode 100644
index 0000000..bf1ca53
--- /dev/null
+++ b/lib_arm/muldi3.c
@@ -0,0 +1,92 @@
+/*
+ * U-boot - muldi3.c contains routines for mult and div
+ *
+ * Copyright (c) 2005-2007 Analog Devices Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ * MA 02110-1301 USA
+ */
+
+/* Generic function got from GNU gcc package, libgcc2.c */
+#ifndef SI_TYPE_SIZE
+#define SI_TYPE_SIZE 32
+#endif
+#define __ll_B (1L << (SI_TYPE_SIZE / 2))
+#define __ll_lowpart(t) ((USItype) (t) % __ll_B)
+#define __ll_highpart(t) ((USItype) (t) / __ll_B)
+#define BITS_PER_UNIT 8
+
+#if !defined (umul_ppmm)
+#define umul_ppmm(w1, w0, u, v)						\
+do {									\
+	USItype __x0, __x1, __x2, __x3;					\
+	USItype __ul, __vl, __uh, __vh;					\
+									\
+	__ul = __ll_lowpart (u);					\
+	__uh = __ll_highpart (u);					\
+	__vl = __ll_lowpart (v);					\
+	__vh = __ll_highpart (v);					\
+									\
+	__x0 = (USItype) __ul * __vl;					\
+	__x1 = (USItype) __ul * __vh;					\
+	__x2 = (USItype) __uh * __vl;					\
+	__x3 = (USItype) __uh * __vh;					\
+									\
+	__x1 += __ll_highpart (__x0);/* this can't give carry */	\
+	__x1 += __x2;	/* but this indeed can */			\
+	if (__x1 < __x2)	/* did we get it? */			\
+		__x3 += __ll_B;	/* yes, add it in the proper pos. */	\
+									\
+	(w1) = __x3 + __ll_highpart (__x1);				\
+	(w0) = __ll_lowpart (__x1) * __ll_B + __ll_lowpart (__x0);	\
+} while (0)
+#endif
+
+#if !defined (__umulsidi3)
+#define __umulsidi3(u, v)						\
+	({DIunion __w;							\
+	umul_ppmm (__w.s.high, __w.s.low, u, v);			\
+	__w.ll; })
+#endif
+
+typedef unsigned int USItype __attribute__ ((mode(SI)));
+typedef int SItype __attribute__ ((mode(SI)));
+typedef int DItype __attribute__ ((mode(DI)));
+typedef int word_type __attribute__ ((mode(__word__)));
+
+struct DIstruct {
+	SItype low, high;
+};
+typedef union {
+	struct DIstruct s;
+	DItype ll;
+} DIunion;
+
+DItype __muldi3(DItype u, DItype v)
+{
+	DIunion w;
+	DIunion uu, vv;
+
+	uu.ll = u, vv.ll = v;
+	/*  panic("kernel panic for __muldi3"); */
+	w.ll = __umulsidi3(uu.s.low, vv.s.low);
+	w.s.high += ((USItype) uu.s.low * (USItype) vv.s.high
+		     + (USItype) uu.s.high * (USItype) vv.s.low);
+
+	return w.ll;
+}
diff --git a/net/eth.c b/net/eth.c
index 38979aa..0934a16 100644
--- a/net/eth.c
+++ b/net/eth.c
@@ -1,3 +1,7 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+ 
 /*
  * (C) Copyright 2001-2004
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
@@ -43,6 +47,14 @@ int board_eth_init(bd_t *bis) __attribute((weak, alias("__def_eth_init")));
 extern int gt6426x_eth_initialize(bd_t *bis);
 #endif
 
+#if defined (CONFIG_PICOCHIP_PC20X)
+extern int pc20x_eth_initialize(bd_t *bis);
+#endif
+
+#if defined (CONFIG_PICOCHIP_PC302)
+extern int pc302_eth_initialize(bd_t *bis);
+#endif
+
 extern int au1x00_enet_initialize(bd_t*);
 extern int dc21x4x_initialize(bd_t*);
 extern int e1000_initialize(bd_t*);
@@ -291,6 +303,14 @@ int eth_initialize(bd_t *bis)
 	at91sam9_eth_initialize(bis);
 #endif
 
+#if defined(CONFIG_PICOCHIP_PC20X)
+        pc20x_eth_initialize(bis);
+#endif
+
+#if defined(CONFIG_PICOCHIP_PC302)
+        pc302_eth_initialize(bis);
+#endif
+
 	if (!eth_devices) {
 		puts ("No ethernet found.\n");
 		show_boot_progress (-64);
